module Prelude where

data Bool -> Type 0 where
  True : Bool
  False : Bool


data Nat -> Type 0 where
    Zero : Nat
    Succ : (x : Nat) => Nat

pred : Nat -> Nat
pred = \n . case n [_] of
  Zero -> Zero
  Succ n' -> n'

-- S m = S n -> m = n
--
-- Poor man's inversion.
--
-- This strategy provides inversion for any trellys types: join and a
-- projection function (here pred).
sm_eq_Sn__m_eq_n : (m:Nat) -> (n:Nat) -> (Succ m = Succ n) -> m = n
sm_eq_Sn__m_eq_n = \m n sm_eq_Sn .
  let pSm_eq_m [_]   = (join : pred (Succ m) = m) in
  let pSn_eq_n [_]   = (join : pred (Succ n) = n) in
  let pSm_eq_pSn [_] = (conv (join : pred (Succ m) = pred (Succ m))
                        by sm_eq_Sn at h.pred (Succ m) = pred h) in
  conv pSm_eq_pSn by pSm_eq_m, pSn_eq_n at hm hn.hm = hn

-- I'm not sure, but I think generally we can make all
-- proof arguments run-time (since we don't plan to
-- actually run proofs). So I changed some arguments
-- from compile-time to run-time. AS.

-- But this is inconvenient when proving equalities.  You want the
-- arguments to these lemmas to be erased, because you want to use
-- eraseable things in them.  CJC

-- Do we have an example where we care that the arguments are erasable?
-- My intution is that these proofs should only be used in two contexts:
-- as the argument to conv (where they are erased), or as lemmas to build
-- other proofs (so in erasable positions, so the arguments can be runtime). VS

-- SCW: I don't think that we care whether the arguments to sym/trans
-- etc are compiletime or runtime. All equality proofs are irrelevant
-- as the definition of irr below shows. (i.e. even if you use trans'
-- to produce an equality proof, you can still erase it with irr
-- below.) So I think we should just use runtime only arguments for
-- simplicity.


sym : (aTy : Type 0) -> (bTy : Type 0) -> (a : aTy) -> (b : bTy)  -> (p : a = b) -> (b = a)
sym = \ aTy bTy a b p . 
           conv (join 1 : a = a) by p at x.x = a

sym1 : (aTy : Type 1) -> (bTy : Type 1) -> (a : aTy) -> (b : bTy)  -> (p : a = b) -> (b = a)
sym1 = \ aTy bTy a b p . 
           conv (join 1 : a = a) by p at x.x = a

trans : [aTy : Type 0] -> [bTy : Type 0] -> [cTy : Type 0] ->
        [a : aTy] -> [b : bTy] -> [c : cTy] ->
				[p : a = b] -> [q : b = c] -> (a = c)
trans = \ [aTy] [bTy] [cTy] [a] [b] [c] [p] [q] .
             conv join 0 
               by (conv p by q at h.a = h)
               at h.a = h
-- The more natural definition of trans is:
--    conv p by q at h.a = h
-- But this forces p to be a runtime argument to trans, which is
-- annoying

trans1 : (aTy : Type 1) -> (bTy : Type 1) -> (cTy : Type 1) ->
         (a : aTy) -> (b : bTy) -> (c : cTy) ->
				(p : a = b) -> (q : b = c) -> (a = c)
trans1 = \ aTy bTy cTy a b c p q .
             conv q by (sym1 aTy bTy a b p) at x.x = c

trans' : (aTy : Type 0) -> (bTy : Type 0) -> (cTy : Type 0) ->
         (a : aTy) -> (b : bTy) -> (c : cTy) ->
				(p : a = b) -> (q : b = c) -> (a = c)
trans' = \ aTy bTy cTy a b c p q .
             conv join 0 
               by (conv p by q at h.a = h)
               at h.a = h


trans4' : (aTy : Type 0) -> (bTy : Type 0) -> (cTy : Type 0) -> (dTy : Type 0) -> 
         (a : aTy) -> (b : bTy) -> (c : cTy) -> (d : dTy) -> 
				(p : a = b) -> (q : b = c) -> (r : c = d) -> (a = d)
trans4' = \ aTy bTy cTy dTy a b c d p q r . 
		    trans' aTy cTy dTy a c d
             (trans' aTy bTy cTy a b c p q) r

-- [a = b] -> a = b
--
-- Irrelevance for equality types.
--
-- Promote erased equality to run-time equality.
--
-- Useful with erased equalities generated by case matches.

uneraseEq : [aTy:Type 0] -> [bTy:Type 0] -> [a:aTy] -> [b:bTy] -> [a = b] -> (a = b)
uneraseEq = \ [_][_][a][b][eq] . conv join by eq at x . a = x


--uneraseEq : (aTy:Type 0) -> (bTy:Type 0) -> (a:aTy) -> (b:bTy) -> [a = b] -> a = b
--uneraseEq = \_ _ a b [eq] . conv (join : a = a) by eq at h. a = h


-- Existential types.

data Exists (a : Type 0) (p : (x:a) -> Type 0) -> Type 0 where
  Ex : [x : a] -> (witness : p x) -> Exists a p

-- Unit

data Unit -> Type 0 where
  U : Unit

-- Void
--
-- DON'T USE THIS: you probably want (0=1) or (True=False) instead,
-- since contra handles those directly ...
data Void -> Type 0 where {}
