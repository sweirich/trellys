module SK where

-- Disable experimental implicit arguments support
flag ImplicitArgs false



-- Boolean, and associated functions.
data Bool : Type where
    True : Bool
  | False : Bool

Program not : (b:Bool) -> Bool :=
  case b {b_eq} of
    True -> False
   |False -> True

infixr 8 &&
infixr 8 ||

Program (&&) : (x:Bool)(y:Bool) -> Bool :=
   case x {x_eq} of
     True -> y
    | False -> False

Theorem and_term : forall(x:Bool)(y:Bool)(x_term:x!)(y_term:y!).(x && y) ! :=
        case x {x_eq} x_term of
          True -> let u1 [u1_eq] = morejoin {x_term,y_term,sym x_eq} : y = (x && y)
                  in conv y_term at ~(u1) !
         |False -> let u1 [u1_eq] = morejoin {x_term,y_term,sym x_eq} : False = (x && y)
                   -- An example of using autoconv; it uses the proof False = (x && y)...
                   in autoconv (valax False) -- conv valax False at ~(u1) !

Theorem and_commutes :
  forall(x:Bool)(y:Bool)(x_term:x!)(y_term:y!).
     (x && y) = (y && x) :=
     case x {x_eq} x_term of
       True ->
         (case y {y_eq} y_term of
            True -> let u1 = join 100 100 : (True && True) = (True && True)
                    in conv u1 at (~x_eq && ~y_eq) = (~y_eq && ~x_eq)
          | False -> let u1 = join 100 100 : (True && False) = (False && True)
                     in conv u1 at (~x_eq && ~y_eq) = (~y_eq && ~x_eq))
      | False ->
         (case y {y_eq} y_term of
            True -> let u1 = join 100 100 : (False && True) = (True && False)
                    in autoconv u1 -- conv u1 at (~x_eq && ~y_eq) = (~y_eq && ~x_eq)
          | False -> let u1 = join 100 100 : (False && False) = (False && False)
                     in autoconv u1) -- conv u1 at (~x_eq && ~y_eq) = (~y_eq && ~x_eq))
     
Theorem morejoin_and_commutes :
 forall(x:Bool)(y:Bool)(x_term:x!)(y_term:y!).
   (x && y) = (y && x) :=
 case x {x_eq} x_term of
   True ->
    (case y {y_eq} y_term of
      True -> morejoin {sym x_eq,sym y_eq,x_term,y_term}
    | False -> morejoin {sym x_eq,sym y_eq,x_term,y_term})
 | False ->
    (case y {y_eq} y_term of
      True -> morejoin {sym x_eq,sym y_eq,x_term,y_term}
    | False -> morejoin {sym x_eq,sym y_eq,x_term,y_term})
                     

Theorem and_right : forall (t1:Bool)(t2:Bool)(p:(t1 && t2) = True).(t2 = True) :=
   termcase t1 {t1_term} of
     abort -> let u1 = morejoin {sym t1_term} : (abort Bool) = ((abort Bool) && t2);
                  u2 = conv u1 at (abort Bool) = (~t1_term && t2)
              in contraabort u2 (conv valax True at ~(sym p) !)
    | ! -> termcase t2 {t2_term} of
             abort ->
               let u1 = morejoin {t1_term, sym t2_term} : (abort Bool) = (t1 && (abort Bool));
                   u2 = conv u1 at (abort Bool) = (t1 && ~t2_term)
               in contraabort u2 (conv valax True at ~(sym p) !)
           | ! -> case t1 {t1_eq} t1_term of
                   True -> let u3 = morejoin {t1_term,t2_term,sym t1_eq}
                                : t2 = (t1 && t2)
                           in trans u3 p
                 | False -> let u3 = morejoin {t1_term,t2_term,sym t1_eq}
                                : False = (t1 && t2)
                            in contra (trans u3 p)
                            
Theorem and_left : forall (t1:Bool)(t2:Bool)(p:(t1 && t2) = True).(t1 = True) :=
   termcase t1 {t1_term} of
     abort -> let u1 = morejoin {sym t1_term} : (abort Bool) = ((abort Bool) && t2);
                  u2 = conv u1 at (abort Bool) = (~t1_term && t2)
              in contraabort u2 (conv valax True at ~(sym p) !)
    | ! -> termcase t2 {t2_term} of
             abort ->
               let u1 = morejoin {t1_term, sym t2_term} : (abort Bool) = (t1 && (abort Bool));
                   u2 = conv u1 at (abort Bool) = (t1 && ~t2_term)
               in contraabort u2 (conv valax True at ~(sym p) !)
           | ! -> case t1 {t1_eq} t1_term of
                   True -> sym t1_eq
                 | False -> let u3 = morejoin {t1_term,t2_term,sym t1_eq}
                                : False = (t1 && t2)
                            in contra (trans u3 p)

Theorem and_term_left : forall (t1:Bool)(t2:Bool)(p: (t1 && t2)!).t1! :=
  termcase t1 {t1_term} of
    abort -> contraabort (aborts (~t1_term && t2)) p
  | ! -> t1_term

Theorem and_term_right : forall (t1:Bool)(t2:Bool)(p: (t1 && t2)!).t2! :=
  termcase t2 {t2_term} of
    abort -> contraabort (aborts (t1 && ~t2_term)) p
  | ! -> t2_term
  
                   
Program (||) : (x:Bool)(y:Bool) -> Bool :=
   case x {x_eq} of
      False -> y
    | True -> True

    
Theorem or_term : forall(x:Bool)(y:Bool)(x_term:x!)(y_term:y!).(x || y) ! :=
  case x {x_eq} x_term of
    True -> let u1 = morejoin {x_term, y_term, sym x_eq} : True = (x || y)
            in conv valax True at ~u1!
   |False -> let u1 = morejoin {x_term, y_term, sym x_eq} : y = (x || y)
             in conv y_term at ~u1!
  

data Maybe : [a:Type] -> Type where
    Just : (x:a) -> Maybe a
  | Nothing : Maybe a
  
-- Type of SK combinator terms.
data Term : Type where
    S : Term
  | K : Term
  | App : Term -> Term -> Term

  
-- Recursive value predicate
Recursive isValue : (t:Term) -> Bool :=
  case t {t_eq} of
    K -> True
   |S -> True
   |App l r -> (case l {l_eq} of
                   K -> isValue r
                 | S -> isValue r
                 | App l' r' -> (case l' {l'_eq} of
                                    S -> isValue r' && isValue r
                                  | K -> False
                                  | App a b -> False))

-- isValue terminates on terminating terms.
-- Note that this pretty much duplicates the code from isValue.
Inductive isValue_term : forall (t:Term){t_term}.isValue t ! :=
  case t {t_eq} t_term of
    K -> let u1 [u1_eq] = morejoin {t_term, sym t_eq} :  True = isValue t
         in conv valax True at  ~u1 !
   |S -> let u1 [u1_eq] = morejoin {t_term, sym t_eq} :  True = isValue t
         in conv valax True at  ~u1 !
   | App l r ->
      case l {l_eq} (valax l) of
        K -> let u1 [u1_eq] = isValue_term r (ord t_eq)
                            : isValue r !;
                 u2 [u2_eq] = morejoin {sym t_eq, sym l_eq, t_term, valax r}
                            : isValue r = isValue t
        in conv u1 at ~u2 !
       |S -> let u1 [u1_eq] = isValue_term r (ord t_eq)
                            : isValue r !;
                 u2 [u2_eq] = morejoin {sym t_eq, sym l_eq, t_term, valax r}
                            : isValue r = isValue t
              in conv u1 at ~u2 !
       |App l' r' ->
          case l' {l'_eq} valax l' of
            S -> let ih_r = isValue_term r (ord t_eq : r < t);
                     ih_r' = isValue_term r'
                               (ordtrans (ord l_eq : r' < l) (ord t_eq : l < t));
                     u1 [u1_eq] = and_term (isValue r') (isValue r) ih_r' ih_r;
                                
                     u2 [u2_eq] = morejoin {sym t_eq,sym l_eq,sym l'_eq, t_term, valax l,valax l'}
                                : ((isValue r' && isValue r) = isValue t)
                 in conv u1 at ~u2 !
           | K -> let u1 [u1_eq] = morejoin {sym t_eq,sym l_eq,sym l'_eq,t_term,valax l,valax l'} 
                                 : False = isValue t
                  in conv valax False at ~u1 !
           | App a b ->
                  let u1 = morejoin {sym t_eq,sym l_eq,sym l'_eq,t_term,valax l,valax l'}
                         : False = isValue t
                  in conv valax False at ~u1 !

     
-- Evaluation contexts                                     
data Ctx : Type where
    Box : Ctx
  | C1 : Ctx -> Term -> Ctx
  | C2 : (t:Term) -> [p:isValue t = True] -> Ctx ->  Ctx

-- Decompostion of a reducible term -- evaluation context + redex.
data Decomp : Type where
  Dec : (c:Ctx) -> (t:Term) -> Decomp
  

-- Plugging a term into n evaluation context.  
Recursive plug : (c:Ctx)(t:Term) -> Term :=
  case c {c_eq} of
      Box -> t
    | C1 c' t' -> App (plug c' t) t' 
    | C2 v [pf] c' -> App v (plug c' t)


Inductive plug_terminates : forall (t1:Term)(t1_term:t1!)(c:Ctx){c_term}.plug c t1 ! :=
  case c {c_eq} c_term of
    Box -> let u1 [u1_eq] = morejoin {t1_term,sym c_eq,c_term} : t1 = plug c t1
           in conv t1_term at ~u1!
  | C1 c' t' -> let ih [ih_eq] = plug_terminates t1 t1_term c' (ord c_eq);
                    u1 [u1_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App (plug c' t1) t'
                in conv value (App ~ih t') at ~(sym u1)!
  | C2 t' [q] c' -> let ih [ih_eq] = plug_terminates t1 t1_term c' (ord c_eq);
                      u1 [u1_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App t' (plug c' t1)
                in conv value (App t' ~ih) at ~(sym u1)!
    

-- Predicate to determine if a term is a redex.
Program isRedex : (t:Term) -> Bool :=
  case t {t_eq} of
      K -> False
    | S -> False
    | App f1 t1 ->
       case f1 {f2_eq} of
           K -> False
         | S -> False
         | App f2 t2 -> case f2 {f2_eq} of
                           K -> isValue t1 && isValue t2
                         | S -> False
                         | App f2 t3 ->
                            case f2 {f2_eq} of
                              K -> False
                              | S -> isValue t1 && isValue t2 && isValue t3
                              | App f3 t4 -> False


Inductive isRedex_terminates : forall (t:Term){t_term}.isRedex t ! :=
  case t {t_eq} t_term of
      K -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
           in conv valax False at ~u1!
    | S -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
           in conv valax False at ~u1!
    | App f1 t1 ->
       case f1 {f1_eq} valax f1 of
           K -> 
             let u1 [u1_eq] = morejoin {sym t_eq,sym f1_eq,t_term,valax f1} : False = isRedex t
             in conv valax False at ~u1!
         | S -> 
              let u1 [u1_eq] = morejoin {sym t_eq,sym f1_eq,t_term,valax f1} : False = isRedex t
              in conv valax False at ~u1!
         | App f2 t2 -> case f2 {f2_eq} valax f2 of
                           K -> let u1 [u1_eq] =  
                                      morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2} :
                                        (isValue t1 && isValue t2) = isRedex t;
                                    u2 [u2_eq] = and_term (isValue t1) (isValue t2)
                                                  (isValue_term t1 (valax t1)) (isValue_term t2 (valax t2))
                                in conv u2 at ~u1!
                         | S -> 
                            let u1 [u1_eq] =  
                                  morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2} :
                                   False = isRedex t
                            in conv valax False at ~u1!                                
                         | App f3 t3 ->
                            case f3 {f3_eq} valax f3 of
                              K -> 
                                let u1 [u1_eq] =  
                                  morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2, sym f3_eq, valax f3} :
                                   False = isRedex t
                                in conv valax False at ~u1!
                              | App f3 t4 -> 
                                let u1 [u1_eq] =  
                                  morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2, sym f3_eq, valax f3} :
                                   False = isRedex t
                                in conv valax False at ~u1!                                
                              | S ->
                                 let u1 [u1_eq] =  
                                      morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2, sym f3_eq, valax f3} :                                      
                                        (isValue t1 && isValue t2 && isValue t3) = isRedex t;
                                    u2 [u2_eq] = and_term (isValue t2) (isValue t3)
                                                  (isValue_term t2 (valax t2)) (isValue_term t3 (valax t3));
                                    u3 [u3_eq] = and_term (isValue t1) (isValue t2 && isValue t3) (isValue_term t1 (valax t1)) u2
                                in conv u3 at ~u1!
                              

-- A data type representing a proof that a term is a redex. This
-- effectively collects all of the proofs along the way of `isRedex`
-- to get to a `True`. Each path to that point yields a new data
-- constructor. Also note that an application of `&&` results in
-- arguments to the constructor that equate each argument to `&&` to
-- `True`. On the other hand, if the result of the programmatic
-- predicate were an application of `||`, we'd want to generate
-- separate constructors for each `||` argument.
data RedexProp : (t:Term)  -> Type where
  RedexK : (t1:Term) -> (t2:Term) -> [p:t = App (App K t1) t2] ->
           [p1:isValue t1 = True] -> [p2:isValue t2 = True] -> RedexProp t
 |RedexS : (t1:Term) -> (t2:Term) -> (t3:Term) ->
             [p:t = App (App (App S t1) t2) t3] ->
             [p1:isValue t1 = True] -> [p2:isValue t2 = True] -> [p3:isValue t3 = True] ->
             RedexProp t

-- Calculate a RedexProp, given that t is a redex.
Program redexProp' : (t:Term)[p:isRedex t = True] -> RedexProp t :=
  case t {t_eq} of
     K -> abort (RedexProp t) -- Contradiction, since isRedex t = True
   | S -> abort (RedexProp t) -- Contradiction, since isRedex t = True
   | App f1 t1 ->
      case f1 {f1_eq} of
         K -> abort (RedexProp t) -- Contradiction, since isRedex t = True
       | S -> abort (RedexProp t) -- Contradiction, since isRedex t = True
       | App f2 t2 ->
           case f2 {f2_eq} of
              K -> let u1 = conv sym t_eq at t = App ~(sym f1_eq) t1; -- t = App (App f2 t2) t1
                       u2 = conv u1 at t = App (App ~(sym f2_eq) t2) t1; -- t = App (App K t2) t1
                       u3 = morejoin { u2, valax t2, valax t1} : isRedex t = (isValue t1 && isValue t2);
                       u4 = trans (sym p) u3 : True = (isValue t1 && isValue t2)
                   in RedexK t t2 t1 [u2]
                         [and_right (isValue t1) (isValue t2) (sym u4)]
                         [and_left (isValue t1) (isValue t2) (sym u4)]
             | S ->  abort (RedexProp t) -- Contradiction, since isRedex t = True
             | App f3 t3 ->
                 case f3 {f3_eq} of
                    K -> abort (RedexProp t) -- Contradiction, since isRedex t = True
                  | App f4 t4 -> abort (RedexProp t) -- Contradiction, since isRedex t = True
                  | S ->
                      let u1 = conv sym t_eq at t = App ~(sym f1_eq) t1; -- t = App (App f2 t2) t1
                          u2 = conv u1 at t = App (App ~(sym f2_eq) t2) t1; -- t = App (App (App f3 t3) t2) t1
                          u3 = conv u2 at t = App (App (App ~(sym f3_eq) t3) t2) t1;
                          u4 = morejoin { u3, valax t3, valax t2, valax t1} : isRedex t = (isValue t1 && isValue t2 && isValue t3);
                          u5 = trans (sym u4) p : (isValue t1 && isValue t2 && isValue t3) = True
                      in RedexS t t3 t2 t1 [u3]
                          [and_right (isValue t2) (isValue t3) (and_right (isValue t1) (isValue t2 && isValue t3) u5)]
                          [and_left (isValue t2) (isValue t3) (and_right (isValue t1) (isValue t2 && isValue t3) u5)]
                          [and_left (isValue t1) (isValue t2 && isValue t3) u5]             

Theorem redexPropTerm : forall(t:Term)(p:isRedex t = True). redexProp' t [p] ! :=
   termcase t {t_term} of
      abort -> let isredex_t_aborts = aborts (isRedex ~t_term) : ((abort Bool) = (isRedex t));
                   isredex_t_terminates = (conv valax True at ~(sym p) !) : (isRedex t) !
               in  contraabort isredex_t_aborts isredex_t_terminates
     | ! -> 
  case t {t_eq} t_term of
     K -> let u1 = morejoin {t_term,sym t_eq} : False = isRedex t
          in contra (equiv 3 : False = True)
   | S -> let u1 = morejoin {t_term,sym t_eq} : False = isRedex t
          in contra (equiv 3 : False = True)
   | App f1 t1 ->
      case f1 {f1_eq} (valax f1) of
         K -> let t_eq' = (conv sym t_eq at t = App ~(sym f1_eq) t1) : t = App K t1;
                  u1 = morejoin {t_term, t_eq'} : False = isRedex t
              in contra (equiv 3 : False = True)
       | S -> let t_eq' = (conv sym t_eq at t = App ~(sym f1_eq) t1) : t = App S t1;
                  u1 = morejoin {t_term, t_eq'} : False = isRedex t
              in contra (equiv 3 : False = True)
       | App f2 t2 ->
          let t_eq' = (conv sym t_eq at t = App ~(sym f1_eq) t1) : (t = App (App f2 t2) t1)
          in case f2 {f2_eq} (valax f2) of
              K -> let t_eq'' = conv t_eq' at t = App (App ~(sym f2_eq) t2) t1; -- t = App (App K t2) t1
                       u3 = morejoin {t_term, t_eq''} : isRedex t = (isValue t1 && isValue t2);
                       u4 = trans (sym p) u3 : True = (isValue t1 && isValue t2);
                       u6 = morejoin {t_term,t_eq''} :
                              redexProp' t [p] = RedexK t t2 t1 [t_eq'']
                                               [and_right (isValue t1) (isValue t2) (sym u4)]
                                               [and_left (isValue t1) (isValue t2) (sym u4)];
                       res_term = valax (RedexK (tcast t by t_term) t2 t1 [t_eq'']
                                          [and_right (isValue t1) (isValue t2) (sym u4)]
                                          [and_left (isValue t1) (isValue t2) (sym u4)])                                                

                   in conv res_term at ~(sym u6) !
             | S -> let t_eq'' = (conv t_eq' at t = App (App ~(sym f2_eq) t2) t1) : t = App (App S t2) t1;
                        u1 = morejoin {t_term, t_eq''} : False = isRedex t
                    in contra (equiv 3 : False = True)
             | App f3 t3 ->
                 let t_eq'' = (conv t_eq' at t = (App (App ~(sym f2_eq) t2) t1)) :
                               t = App (App (App f3 t3) t2) t1 in
                 case f3 {f3_eq} (valax f3) of
                    K -> let t_eq''' = (conv t_eq'' at t = App (App (App ~(sym f3_eq) t3) t2) t1) :
                                            t = App (App (App K t3) t2) t1;
                             u1 = morejoin {t_term, t_eq'''} : False = isRedex t
                         in contra (equiv 3 : False = True)
                  | App f4 t4 -> 
                         let t_eq''' = (conv t_eq'' at t = App (App (App ~(sym f3_eq) t3) t2) t1) :
                                            t = App (App (App (App f4 t4) t3) t2) t1;
                             u1 = morejoin {t_term, t_eq'''} : False = isRedex t
                         in contra (equiv 3 : False = True)
                  
                  | S ->
                         let t_eq''' = (conv t_eq'' at t = App (App (App ~(sym f3_eq) t3) t2) t1) :
                                            t = App (App (App S t3) t2) t1;
                             u4 = morejoin { t_term, t_eq''', valax t3, valax t2, valax t1} :
                                 isRedex t = (isValue t1 && isValue t2 && isValue t3);
                             u5 = trans (sym u4) p : (isValue t1 && isValue t2 && isValue t3) = True;
                             res = morejoin {t_term, t_eq'''} :
                                redexProp' t [p] =
                                   RedexS t t3 t2 t1 [t_eq''']
                                    [and_right (isValue t2) (isValue t3) (and_right (isValue t1) (isValue t2 && isValue t3) u5)]
                                    [and_left (isValue t2) (isValue t3) (and_right (isValue t1) (isValue t2 && isValue t3) u5)]
                                    [and_left (isValue t1) (isValue t2 && isValue t3) u5];
                             res_term =  valax (RedexS (tcast t by t_term) t3 t2 t1 [t_eq''']
                                        [and_right (isValue t2) (isValue t3) (and_right (isValue t1) (isValue t2 && isValue t3) u5)]
                                        [and_left (isValue t2) (isValue t3) (and_right (isValue t1) (isValue t2 && isValue t3) u5)]
                                        [and_left (isValue t1) (isValue t2 && isValue t3) u5])
                         in conv res_term at ~(sym res) !                          

-- axiom redexPropTerm : forall(t:Term)(p:isRedex t = True). redexProp' t [p] !
-- Inductive data types in Sep3 live purely in the programmatic
-- fragment, so they really aren't of much direct use as inductive
-- logical propostions, because all such values are inhabited by
-- diverging terms.. However, if we package up a value of that type
-- with a proof that the value is terminating, then we can treat it as
-- a proposition in the logical language. In particular, we can case
-- split on the value, after unpacking the existential.

-- Constructing this proof follows pretty directly from the definition
-- of `isRedex`. Since we take as an assumption that `isRedex t =
-- True`, each time isRedex returns `False`, we have a contradiction.
-- Inductive redexProp : forall(t:Term){t_term}(p:isRedex t = True).
--                         (exists (rp:RedexProp t).rp!) :=
--   case t {t_eq} t_term of
--       K -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
--            in contra (trans u1 p)
--     | S -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
--            in contra (trans u1 p)
--     | App f1 t1 ->
--        case f1 {f1_eq} valax f1 of
--            K ->
--              let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq} : False = isRedex t
--              in contra (trans u1 p)
--          | S ->
--              let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq} : False = isRedex t
--              in contra (trans u1 p)

--          | App f2 t2 -> case f2 {f2_eq} valax f2 of
--                            K -> -- FIXME: Need to include isValue proofs.
--                              --  isValue t1 && isValue t2
--                              (let u1 [u1_eq] = conv sym t_eq at t = App ~(sym f1_eq) t1;
--                                  u2 [u2_eq] = conv u1 at t = App (App ~(sym f2_eq) t2) t1;
--                                  val_t1_term [u3_eq] = isValue_term t1 (valax t1);
--                                  val_t2_term [u4_eq] = isValue_term t2 (valax t2)
--                              in (case isValue t1 {val_t1} val_t1_term of
--                                  False -> 
--                                  let notRedex [asd] = morejoin {u2,t_term,val_t1_term,val_t2_term,sym val_t1} : False = isRedex t
--                                   in contra (trans notRedex p)
--                                 |True ->
--                                   (case isValue t2 {val_t2} val_t2_term of
--                                     False ->
--                                      let notRedex [asd] = morejoin {u2,t_term,val_t1_term, val_t2_term, sym val_t1, sym val_t2} : isValue t2 = isRedex t
--                                      in contra trans (trans val_t2 notRedex) p
--                                    | True ->
--                                         pack (RedexK (tcast t by t_term) t2 t1 [u2] [sym val_t2] [sym val_t1]),
--                                              (valax (RedexK (tcast t by t_term) t2 t1 [u2] [sym val_t2] [sym val_t1]))
--                                    )))
--                          | S ->
--                             let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq,sym f2_eq} : False = isRedex t
--                             in contra (trans u1 p)
--                          | App f3 t3 ->
--                             case f3 {f3_eq} (valax f3) of
--                               K ->
--                                let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq,sym f2_eq, sym f3_eq} : False = isRedex t
--                                in contra (trans u1 p)
--                             | S ->
--                              let u1 [u1_eq] = conv sym t_eq at t = App ~(sym f1_eq) t1;
--                                  u2 [u2_eq] = conv u1 at t = App (App ~(sym f2_eq) t2) t1;
--                                  u3 [u3_eq] = conv u2 at t = App (App (App ~(sym f3_eq) t3) t2) t1;
--                                  val_t1_term [u3_eq] = isValue_term t1 (valax t1);
--                                  val_t2_term [u4_eq] = isValue_term t2 (valax t2);
--                                  val_t3_term [u5_eq] = isValue_term t3 (valax t3);
--                                  val_and_t2_t3 [u6_eq] =
--                                     and_term (isValue t2) (isValue t3) val_t2_term val_t3_term
--                              in (case isValue t1 {val_t1} val_t1_term of
--                                    False -> let v1 [v1_eq] =
--                                                  morejoin {u3, t_term, sym val_t1,
--                                                     val_t1_term,val_t2_term,val_t3_term,val_and_t2_t3} : False = isRedex t
--                                             in contra (trans v1 p)
--                                   |True ->
--                                      case isValue t2 {val_t2} val_t2_term of
--                                        False ->
--                                          let v1 [v1_eq] =
--                                                morejoin {u3, t_term, sym val_t1,sym val_t2,
--                                                  val_t1_term,val_t2_term,val_t3_term,val_and_t2_t3} : False = isRedex t
--                                          in contra (trans v1 p)
--                                       |True ->
--                                         (case isValue t3 {val_t3} val_t3_term of
--                                           False ->
--                                              let v1 [v1_eq] =
--                                                morejoin {u3, t_term, sym val_t1,sym val_t2,sym val_t3,
--                                                  val_t1_term,val_t2_term,val_t3_term,val_and_t2_t3} : isValue t3 = isRedex t
--                                              in contra trans (trans val_t3 v1) p
--                                          |True ->
--                                            pack (RedexS t t3 t2 t1 [u3] [sym val_t3] [sym val_t2] [sym val_t1]),
--                                             (valax (RedexS (tcast t by t_term) t3 t2 t1 [u3] [sym val_t3] [sym val_t2] [sym val_t1]))
--                                          )
--                                   )
                              
--                             | App f3 t4 -> 
--                                let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq,sym f2_eq, sym f3_eq} : False = isRedex t
--                                in contra (trans u1 p)
                              

-- | Decompose a term into an evaluation context and redex. This
-- | results in leftmost-outermost reduction.
Recursive decompose : (t:Term) -> Decomp  :=
  case isRedex t {redex_t} of
      True -> Dec Box t
    | False -> (case t {e_eq} of
                  K -> Dec Box t
                | S -> Dec Box t
                | App x y -> (case isValue x {x_val} of
                                True -> (case decompose y {y_eq} of
                                          Dec c' t' -> Dec (C2 x [sym x_val] c') t')
                               | False -> (case decompose x {x_eq} of
                                          Dec c' t' -> Dec (C1 c' y) t')))

Inductive decompose_terminates : forall(t:Term){t_term}. decompose t ! := 
  case isRedex t {redex_t} isRedex_terminates t t_term of
      True -> let u1 [u1_eq] = morejoin {t_term, sym redex_t} : Dec Box t = decompose t
              in  conv (valax (Dec Box (tcast t by t_term))) at ~u1 !
    | False -> (case t {e_eq} t_term of
                  K -> let u1 [u1_eq] = morejoin {t_term, sym redex_t, sym e_eq} : Dec Box t = decompose t
                       in  conv (valax (Dec Box (tcast t by t_term))) at ~u1 !
                | S -> let u1 [u1_eq] = morejoin {t_term, sym redex_t, sym e_eq} : Dec Box t = decompose t
                       in  conv (valax (Dec Box (tcast t by t_term))) at ~u1 !
                | App x y -> (case isValue x {x_val} isValue_term x (valax x) of
                                True -> let u1 [u1_eq] = ord e_eq : y < t
                                        in  (case decompose y {y_eq} decompose_terminates y u1 of
                                               Dec c' t' ->
                                                 let u1 [u1_eq] =
                                                        morejoin {sym x_val,sym e_eq, sym redex_t, sym y_eq, t_term, valax t'}
                                                        : Dec (C2 x [sym x_val] c') t' = decompose t 
                                                 in conv valax (Dec (C2 x [sym x_val] c') t') at ~u1!)
                               | False -> let u1 [u1_eq] = ord e_eq : x < t
                                          in (case decompose x {x_eq} decompose_terminates x u1 of
                                                Dec c' t' ->
                                                  let u2 [u2_eq] =
                                                    morejoin {sym x_val, sym e_eq, sym redex_t, sym x_eq, t_term, valax t'}
                                                      : Dec (C1 c' y) t' = decompose t
                                                  in conv valax (Dec (C1 c' y) t') at ~u2!)))
                                          

Program dec_focus :  (d:Decomp) -> Term :=
  case d {d_eq} of
     Dec c t -> t

Program dec_ctx :  (d:Decomp) -> Ctx :=
  case d {d_eq} of
     Dec c t -> c
     
Theorem dec_ctx_inj : forall (c1:Ctx)(c2:Ctx)(t1:Term)(t2:Term)
                              (c1_term:c1!)(c2_term:c2!)(t1_term:t1!)(t2_term:t2!)
                         (p:Dec c1 t1 = Dec c2 t2).c1 = c2 :=
   let u1 = join 0 0 : dec_ctx (Dec c1 t1) = dec_ctx (Dec c1 t1);
       u1' = conv u1 at dec_ctx (Dec c1 t1) = dec_ctx ~p;
       u2 = morejoin {c1_term,c2_term,t1_term,t2_term} : c1 = dec_ctx (Dec c1 t1);
       u3 = morejoin {c1_term,c2_term,t1_term,t2_term} : c2 = dec_ctx (Dec c2 t2)
   in  equiv 2

-- axiom dec_ctx_inj : forall (c1:Ctx)(c2:Ctx)(t1:Term)(t2:Term)(p:Dec c1 t1 = Dec c2 t2).c1 = c2


Theorem dec_term_inj : forall (c1:Ctx)(c2:Ctx)(t1:Term)(t2:Term)
                              (c1_term:c1!)(c2_term:c2!)(t1_term:t1!)(t2_term:t2!)
                         (p:Dec c1 t1 = Dec c2 t2).t1 = t2 :=
   let u1 = join 0 0 : dec_focus (Dec c1 t1) = dec_focus (Dec c1 t1);
       u1' = conv u1 at dec_focus (Dec c1 t1) = dec_focus ~p;
       u2 = morejoin {c1_term,c2_term,t1_term,t2_term} : t1 = dec_focus (Dec c1 t1);
       u3 = morejoin {c1_term,c2_term,t1_term,t2_term} : t2 = dec_focus (Dec c2 t2)
   in  equiv 3

                                                  
-- Program step : (t:Term) -> Maybe Term :=
--   case t {t_eq} of
--       K -> Nothing [Term] -- K is normal form
--     | S -> Nothing [Term] -- S is normal form
--     | App t1 a1 ->
--       case isValue a1 {val_a1} of
--           False -> Nothing [Term]
--         | True -> (case t1 {t1_eq} of
--                        K -> Nothing [Term] -- K t2 is a value
--                      | S -> Nothing [Term] -- S t2 is a value
--                      | App t2 a2 ->
--                         (case isValue a2 {val_a2} of
--                             False -> Nothing [Term]
--                           | True ->                         
--                               (case t2 {t2_eq} of
--                                    K -> Just [Term] a2 -- K a2 a1 steps to a2
--                                  | S -> Nothing [Term] -- S s2 a1 is a value
--                                  | App t3 a3 ->
--                                    (case isValue a3 {val_a3} of
--                                       False -> Nothing [Term]
--                                      |True ->
--                                        (case t3 {t3_eq} of
--                                           K -> Nothing [Term]
--                                          |S -> Just [Term] (App (App a3 a1) (App a3 a2))
--                                          | App t4 a4  -> Nothing [Term]
--                                          )))))

-- A simpler definition of step, where we use redexProp to eliminate a
-- bunch of case splits. This seems off, though, since we're returning
-- *runtime* data that's extracted from compile-time arguments to a constructor.
-- Program step' : (t:Term)[p:isRedex t = True] -> Term :=
--    let t_term = termcase t {t_term} of
--                   abort -> let u1 = aborts (isRedex ~t_term) : ((abort Bool) = isRedex t)
--                            in contraabort u1 (conv (valax True) at ~(sym p) !) : t !
--                  | ! -> t_term
--        -- rprop = redexProp t t_term p
--    in unpack (redexProp t t_term p) as (prop,prop_term) in
--          case prop {prop_eq} of
--             RedexK t1 t2 [isapp] [isval1] [isval2] -> t2
--           | RedexS t1 t2 t3 [isapp] [isval1] [isval2] [isval3] -> App (App t1 t2) (App t1 t3)

Program step' : (t:Term)[p:isRedex t = True] -> Term :=
   case redexProp' t [p] {redex_eq} of
          RedexK t1 t2 [isapp] [isval1] [isval2] -> t1
        | RedexS t1 t2 t3 [isapp] [isval1] [isval2] [isval3] -> App (App t1 t2) (App t1 t3)
   
Theorem step_terminates : forall (t:Term)(p:isRedex t = True).step' t [p] ! :=
   termcase t {t_term} of
     abort -> let u1 = (aborts (isRedex ~t_term))
                     : (abort Bool) = isRedex t;
                  u2 = conv (valax True) at ~(sym p) !
              in contraabort u1 u2
    | ! ->
   case redexProp' t [p] {redex_eq} redexPropTerm t p of
          RedexK t1 t2 [isapp] [isval1] [isval2] ->
            let u1 = morejoin {sym redex_eq,t_term}
                   : t1 = step' t [p] 
            in conv valax t1 at ~u1 !
        | RedexS t1 t2 t3 [isapp] [isval1] [isval2] [isval3] ->
            let u1 = morejoin {sym redex_eq,t_term}
                   : App (App t1 t2) (App t1 t3) = step' t [p];
                terms = valax (App (App t1 t2) (App t1 t3))
                      : App (App t1 t2) (App t1 t3) !
            in conv terms at ~u1 !
        




-- Decompose a term, reduce it, repeat...
Recursive reduction : (t:Term) -> Term :=
  case decompose t {dec_t} of
    Dec c t' -> case isRedex t' {red_t'} of
                  True -> reduction (plug c (step' t' [sym red_t']))
                 |False -> plug c t'



                 
axiom app_left_inj : forall (t1:Term)(t2:Term)(t3:Term)(t4:Term)
          (p:App t1 t3 = App t2 t4).t1 = t2

data NatS : Type where
    Zero : NatS
  | Succ : NatS -> NatS


Recursive rLen : (t:Term)(t':Term)[p:reduction t = t'] -> NatS :=
  case decompose t {dec_t} of
     Dec c t'' -> case isRedex t'' {red_t''} of
                   True ->
                      let u1 = morejoin {sym dec_t,sym red_t''}
                                  : reduction t = reduction (plug c (step' t'' [sym red_t'']));
                          u2 =  equiv 2 : reduction (plug c (step' t'' [sym red_t''])) = t'
                      in Succ (rLen (plug c (step' t'' [sym red_t''])) t' [u2])
                  | False -> Zero

axiom rLen_terminates :
  forall (t:Term)(t':Term)(t'_term:t'!)(p:reduction t = t').(rLen t t' [p]) !

  

-- This is proven below, I just need to reorder.
axiom plug_decompose_inv :
  forall (t:Term)(t_term:t!)(t':Term)(t'_term:t'!)(c:Ctx)(c_term:c!)(p:decompose t = Dec c t').plug c t' = t


Theorem val_not_redex : forall (t:Term)(p:isValue t = True).isRedex t = False  :=
  termcase t {t_term} of
         abort -> let u1 = (aborts (isValue ~t_term)) : (abort Bool) = isValue t;
                      u2 = conv valax True at ~(sym p) !
                  in contraabort u1 u2
       | ! -> case isRedex t {red_t_eq} isRedex_terminates t t_term of
                False -> (sym red_t_eq)
              | True -> case redexProp' t [sym red_t_eq] {rp_eq} redexPropTerm t (sym red_t_eq) of
                  RedexK t1 t2 [isapp] [val1] [val2] ->
                     let u1 = morejoin {t_term, isapp,val1,val2} : isValue t = False
                     in contra (equiv 2 : True = False)
                | RedexS t1 t2 t3 [isapp] [val1] [val2] [val3]->
                     let u1 = morejoin {t_term, isapp,val1,val2,val3} : isValue t = False
                     in contra (equiv 2 : True = False)

  
Inductive val_decomp_value :
  forall (t:Term){t_term}(t':Term)(t'_term:t'!)(c:Ctx)(c_term:c!)
     (t_val:isValue t = True)(p:decompose t = Dec c t').isValue t' = True :=
     case t {t_eq} t_term of
       K -> let u1 = morejoin {sym t_eq, t_term}
                   : decompose t = Dec Box t;
                u2 = equiv 2 
                   : Dec Box t = Dec c t';
                u3 = dec_term_inj Box c t t' (valax Box) c_term t_term t'_term u2
                   : t = t'
            in conv t_val at isValue ~u3 = True
     | S ->let u1 = morejoin {sym t_eq, t_term}
                   : decompose t = Dec Box t;
                u2 = equiv 2 
                   : Dec Box t = Dec c t';
                u3 = dec_term_inj Box c t t' (valax Box) c_term t_term t'_term u2
                   : t = t'
            in conv t_val at isValue ~u3 = True
     | App f1 t1 ->
         case f1 {f1_eq} valax f1 of
           K -> let 
                    u1 = (conv sym t_eq at t = App ~(sym f1_eq) t1)
                       : t = App K t1;
                    val_t1_t = morejoin {t_term, u1,valax t1}
                       : isValue t = isValue t1;
                    val_t1 = equiv 2
                       : isValue t1 = True;
                    val_t1_term = (conv valax True at ~(sym val_t1) !)
                       : isValue t1 !;
                    t1_not_redex = val_not_redex t1 val_t1
                       : isRedex t1 = False
                    in
                    (case decompose t1 {dec_t1_eq} decompose_terminates t1 (valax t1) of
                      Dec c'' t'' ->
                       let u2 = morejoin {t_term, u1,val_t1,val_t1_term,t1_not_redex,sym dec_t1_eq}
                              : decompose t = Dec (C2 K [join 10 10] c'') t'';
                           u4 = equiv 2
                              : Dec (C2 K [join 10 10] c'') t'' = Dec c t';
                           u5 = dec_term_inj (C2 K [join 10 10] c'') c
                                  t'' t' (valax (C2 K [join 10 10] c'')) c_term
                                  (valax t'') t'_term u4
                              : t'' = t';
                           -- Ready to work with inductive hypothesis
                           u6 = ord t_eq
                              : t1 < t;
                           ih = val_decomp_value t1 u6 t'' (valax t'') c'' (valax c'') val_t1 (sym dec_t1_eq)
                              : isValue t'' = True
                       in conv ih at isValue ~u5 = True)
                    
                    
           |S -> let 
                    u1 = (conv sym t_eq at t = App ~(sym f1_eq) t1)
                       : t = App S t1;
                    val_t1_t = morejoin {t_term, u1,valax t1}
                       : isValue t = isValue t1;
                    val_t1 = equiv 2
                       : isValue t1 = True;
                    val_t1_term = (conv valax True at ~(sym val_t1) !)
                       : isValue t1 !;
                    t1_not_redex = val_not_redex t1 val_t1
                       : isRedex t1 = False
                    in
                    (case decompose t1 {dec_t1_eq} decompose_terminates t1 (valax t1) of
                      Dec c'' t'' ->
                       let u2 = morejoin {t_term, u1,val_t1,val_t1_term,t1_not_redex,sym dec_t1_eq}
                              : decompose t = Dec (C2 S [join 10 10] c'') t'';
                           u4 = equiv 2
                              : Dec (C2 S [join 10 10] c'') t'' = Dec c t';
                           u5 = dec_term_inj (C2 S [join 10 10] c'') c
                                  t'' t' (valax (C2 S [join 10 10] c'')) c_term
                                  (valax t'') t'_term u4
                              : t'' = t';
                           -- Ready to work with inductive hypothesis
                           u6 = ord t_eq
                              : t1 < t;
                           ih = val_decomp_value t1 u6 t'' (valax t'') c'' (valax c'') val_t1 (sym dec_t1_eq)
                              : isValue t'' = True
                       in conv ih at isValue ~u5 = True)
          |App f2 t2 ->
            case f2 {f2_eq} valax f2 of
              K -> 
                let u0 = (conv sym t_eq at t = App ~(sym f1_eq) t1)
                       : t = App (App f2 t2) t1;
                    u1 = (conv u0 at t = App (App ~(sym f2_eq) t2) t1)
                       : t = App (App K t2) t1;
                    u3 = morejoin {u1,t_term}
                       : isValue t = False
                in contra (equiv 2 : True = False)
             |App f3 t3 ->
                let u0 = (conv sym t_eq at t = App ~(sym f1_eq) t1)
                       : t = App (App f2 t2) t1;
                    u1 = (conv u0 at t = App (App ~(sym f2_eq) t2) t1)
                       : t = App (App (App f3 t3) t2) t1;
                    u3 = morejoin {u1,t_term}
                       : isValue t = False
                in contra (equiv 2 : True = False)
             |S ->
               let u0 = (conv sym t_eq at t = App ~(sym f1_eq) t1)
                      : t = App (App f2 t2) t1;
                   u1 = (conv u0 at t = App (App ~(sym f2_eq) t2) t1)
                      : t = App (App S t2) t1;
                   val_t1_term = isValue_term t1 (valax t1)
                               : (isValue t1) !;
                   val_t2_term = isValue_term t2 (valax t2)
                               : (isValue t2) !;
                   t_not_redex = val_not_redex t t_val                   
                               : isRedex t = False;
                   app_s_value = morejoin { valax t2}
                               : isValue (App S t2) = isValue t2
               in case isValue t2 {val_t2_eq} val_t2_term of
                    True ->
                      (case decompose t1 {dec_t1_eq} decompose_terminates t1 (valax t1) of
                        Dec c'' t'' ->
                          let app_s_value = equiv 2
                                          : isValue (App S t2) = True;
                              v0 = morejoin {t_term,u1,app_s_value,sym dec_t1_eq}
                                 : decompose t = Dec (C2 (App S t2) [app_s_value] c'') t'';
                              t1_value = morejoin {u1,t_term,sym val_t2_eq,val_t1_term}
                                       : isValue t = isValue t1;
                              t1_ord = ord t_eq
                                     : t1 < t;
                              t1_val = equiv 2
                                     : isValue t1 = True;
                              -- Apply inductive hypothesis...
                              t1_ih = val_decomp_value t1 t1_ord  t'' (valax t'') c'' (valax c'') t1_val (sym dec_t1_eq)
                                     : isValue t'' = True;
                              -- Use injectivity of Dec
                              dec_eq = trans (sym v0) p
                                     : Dec (C2 (App S t2) [app_s_value] c'') t'' = Dec c t';
                              term_eq = dec_term_inj (C2 (App S t2) [app_s_value] c'') c
                                          t'' t' (valax (C2 (App S t2) [app_s_value] c'')) c_term
                                          (valax t'') t'_term dec_eq
                                      : t'' = t'
                          in conv t1_ih at isValue ~term_eq = True)
                   |False ->
                      -- && is not short-circuited, so this is a pita
                      case isValue t1 {val_t1_eq} val_t1_term of
                          True -> let u1 = morejoin {u1,t_term,sym val_t2_eq,val_t1_term,val_t1_eq} 
                                         : isValue t = False;
                                      u2 = equiv 2
                                         : False = True
                                  in contra u2
                        | False -> let u1 = morejoin {u1,t_term,sym val_t2_eq,val_t1_term,sym val_t1_eq, val_t2_term} 
                                         : isValue t = False;
                                       u2 = equiv 2
                                         : False = True
                                  in contra u2


                               
                --    u2 = morejoin {t_term,u1,val_t1_term,val_t2_term,valax t1, valax t2} 
                --       : isValue t = (isValue t2 && isValue t1);
                --    u3 = equiv 2
                --       : isValue t2 && isValue t1 = True;
                --    val_t1 = False
                --           : isValue t1 = True;
                --    val_t2 = False
                --           : isValue t2 = True;
                --    ord_t1 = ord (sym t1)
                --           : t1 < t;
                --    ord_t2 = False
                --           : t2 < t
                -- in u1





     
           -- let u1 = morejoin {t_term,sym t_eq, valax t1, valax t2}
           --        : isValue t = isValue t1 && isValue t2;
           --     u2 = equiv 2
           --        : isValue t1 && isValue t2 = True;
           --     val_t1 = and_left (isValue t1) (isValue t2) u2
           --            : isValue t1 = True;
           --     val_t2 = and_right (isValue t1) (isValue t2) u2
           --            : isValue t2 = True
           -- in u1                     
  

                     
Theorem val_irreducible :
  forall (t:Term)(p:isValue t = True).(reduction t = t) :=
       termcase t {t_term} of
         abort -> let u1 = (aborts (isValue ~t_term)) : (abort Bool) = isValue t;
                      u2 = conv valax True at ~(sym p) !
                  in contraabort u1 u2
       | ! -> case decompose t {dec_t_eq} decompose_terminates t t_term of
               Dec c t'' ->
                 let u1 = val_decomp_value t t_term t'' (valax t'') c (valax c) p (sym dec_t_eq)
                        : isValue t'' = True;
                     u2 = val_not_redex t'' u1
                        : isRedex t'' = False;
                     u3 = morejoin {t_term,sym dec_t_eq, u2,sym dec_t_eq,u2} 
                        : reduction t = plug c t'';
                     u4 =  plug_decompose_inv t t_term t'' (valax t'') c (valax c) (sym dec_t_eq)
                        : plug c t'' = t
                 in equiv 2

-- Note, using termcase, we can elminate the need to provide any terminatation argumetns except for tn_term.
Inductive red_cong : forall (n:NatS){n_term}(t:Term)(t_term:t!)(t':Term)(t'_term:t'!)(tn:Term)(tn_term:tn!)
      (p:reduction t = t')(red_len:n = rLen t t' [p]).
          reduction (App t tn) = reduction (App t' tn) :=
       let app_term = valax (App (tcast t by t_term) (tcast tn by tn_term))
       in case isRedex (App t tn) {red_eq} isRedex_terminates (App t tn) app_term of
            True ->
               (case redexProp' (App t tn) [sym red_eq] {redProp_eq} redexPropTerm (App t tn) (sym red_eq) of
                    RedexK ta1 ta2 [isapp] [isval1] [isval2] ->
                      let u1 = app_left_inj t (App K ta1) tn ta2 isapp
                                   : t = (App K ta1);
                          t_val = morejoin {t_term,u1, valax ta1, isval1} 
                                   : (isValue t = True);
                          red_id = val_irreducible t t_val 
                                   : reduction t = t;
                          u2 = equiv 2 : t = t';
                          u3 = join 0 0 : reduction (App t tn) = reduction (App t tn);
                          u4 = conv u3 at reduction (App t tn) = reduction (App ~u2 tn)
                      in u4
                  | RedexS ta1 ta2 ta3 [isapp] [isval1] [isval2] [isval3] ->
                      let u1 = app_left_inj t (App (App S ta1) ta2) tn ta3 isapp
                                  : t = (App (App S ta1) ta2);
                          t_val = morejoin {t_term,u1, valax ta1, valax ta2, isval1, isval2} 
                                   : (isValue t = True);
                          red_id = val_irreducible t t_val 
                                   : reduction t = t;
                          u2 = equiv 2 : t = t';                                   
                          u3 = join 0 0 : reduction (App t tn) = reduction (App t tn);
                          u4 = conv u3 at reduction (App t tn) = reduction (App ~u2 tn)
                      in u4)
                                  
                     -- isapp : (App t tn) = App (App (App S t1) t2) tn
                     -- From this, we extract
                     -- t = (App (App S ta1) ta2)
                     -- and we know isvalue ta1 and isvalue ta2
                     -- so we get so we get isvalue (App (App S ta1) ta2)
                     -- and in turn isvalue t
                     -- we apply lemma isvalue t && reduction t = t' implies t = t'
                     -- Giving us t = t'
                     -- and by refl, we have
                     -- reduction (App t tn) = reduction (App t tn)
                     -- with conv, we get reduction (App t tn) = reduction (App t' tn)

           |False ->
               case (App t tn) {app_eq} app_term of
                  K -> contra app_eq
                | S -> contra app_eq
                | App x y ->
                    let u1 = app_left_inj x t y tn app_eq : x = t in
                    case isValue t {t_val} isValue_term t t_term of
                      True ->
                        let red_id = val_irreducible t (sym t_val) 
                              : reduction t = t;
                            u2 = equiv 1 : t = t';
                          u3 = join 0 0 : reduction (App t tn) = reduction (App t tn);
                          u4 = conv u3 at reduction (App t tn) = reduction (App ~u2 tn)
                        -- we have isValue (App t tn) = True
                        -- we can then get isValue t = True by morejoin
                        -- again, we have is isValue t && reduction t = t'
                        --   implies t = t'
                        -- and then we know isValue t'
                        -- so we know decompose t = Dec Box t
                        -- so we know that decompose (App t tn) = C2 t [_] ...
                        -- ... not really sure here....
                        in u4
                    | False ->
                        case decompose t {dec_t_eq} decompose_terminates t t_term of
                          Dec c' t'' -> 
                             let u2 = morejoin {sym red_eq, sym t_val, tn_term, t_term, sym dec_t_eq}
                                          : decompose (App t tn) = Dec (C1 c' tn) t''
                             in (case isRedex t'' {red_t''} isRedex_terminates t'' (valax t'') of
                                 -- we have isValue (App t tn) = False
                                 -- So we know that decompose (App t tn) = (C1 c' tn, t'')
                                 -- and we know that decompose t = (c',t'')                        
                               --  (for some c')
                                 True ->
                                  -- so we know that reduction t = reduction (plug c' (step t''))                                  
                                    let u3 = morejoin {sym red_eq, sym t_val, tn_term, t_term, sym dec_t_eq,sym red_t''}
                                          : reduction t = reduction (plug c' (step' t'' [sym red_t'']));
                                        u4 = morejoin {sym red_eq, sym t_val, tn_term, t_term, sym dec_t_eq,sym red_t''}
                                          : reduction (App t tn) = reduction (plug (C1 c' tn) (step' t'' [sym red_t'']));
                                          -- = reduction (App (plug c' (step' t'' [sym red_t''])) tn)
                                          -- need reduction (plug (C1 c' tn) t'') = reduction (plug (C1 c' tn) (reduction t''))
                                        step_t''_term = step_terminates t'' (sym red_t'')
                                          : (step' t'' [sym red_t'']) !;
                                        plug_step_t''_term = plug_terminates (step' t'' [sym red_t'']) step_t''_term c' (valax c');
                                        u5 = morejoin {sym red_eq, sym t_val, tn_term, t_term, sym dec_t_eq,sym red_t'', step_t''_term}
                                          : plug (C1 c' tn) (step' t'' [sym red_t'']) = App (plug c' (step' t'' [sym red_t''])) tn;
                                        u6 = conv u4 at reduction (App t tn) = reduction ~u5;
                                        u6' = equiv 2 : reduction (plug c' (step' t'' [sym red_t''])) = t';
                                        u7 = morejoin {sym red_eq, sym t_val, tn_term, t_term, sym dec_t_eq,sym red_t'', step_t''_term,t'_term}
                                          : rLen t t' [p] = Succ (rLen (plug c' (step' t'' [sym red_t''])) t' [u6']);
                                        u8 = equiv 2 : Succ (rLen (plug c' (step' t'' [sym red_t''])) t' [u6']) = n;
                                        smaller = ord u8 : (rLen (plug c' (step' t'' [sym red_t''])) t' [u6']) < n;
                                        -- Apply the inductive hypothesis
                                        ih = red_cong (rLen (plug c' (step' t'' [sym red_t''])) t' [u6'])
                                                      smaller
                                                      (plug c' (step' t'' [sym red_t'']))
                                                      plug_step_t''_term -- should be that the above terminates
                                                      t' t'_term
                                                      tn tn_term
                                                      u6' (join 0 0)
                                                : reduction (App (plug c' (step' t'' [sym red_t''])) tn) = reduction (App t' tn)
                                        -- Almost ready to apply the inductive hypothesis:
                                        --  forall (n':NatS)(n_term:n' < n)(t:Term)(t_term:t!)(t':Term)(t'_term:t'!)(tn:Term)(tn_term:tn!)
                                        --      (p:reduction t = t')(n = rLen t t' [p]).reduction (App t tn) = reduction (App t tn)
                                        -- We need n' and n' < n, and
                                        -- Let n' = (rLen (plug c' (step' t'' [sym red_t'']))
                                        -- Let n_term = smaller
                                        -- Let t be (plug c' (step' t'' [sym red_t])).
                                        -- Let t' be t'. Let tn be tn. Let p = u6'.
                                        -- We need n' = rLen t t' [u6']
                                        
                                    in equiv 2

                               | False ->
                                    let u3 = morejoin {sym red_eq, sym t_val, tn_term, t_term, sym dec_t_eq,sym red_t''}
                                         : reduction t = plug c' t'';
                                        -- u4 = equiv 2 : plug c' t'' = t';
                                        u4 = plug_decompose_inv t t_term t'' (valax t'') c' (valax c') (sym dec_t_eq)
                                              : plug c' t'' = t;
                                        u5 = equiv 2 : reduction t = t;
                                        u6 = equiv 2 : t = t';
                                        u7 = join 0 0 : reduction (App t tn) = reduction (App t tn);
                                        u8 = conv u7 at reduction (App t tn) = reduction (App ~u6  tn)
                                    in u8
                             )
                                         
                        -- and reduction (App t tn) = reduction (plug (C1 c' tn) (step t''))
                        -- we should be able to prove that
                        -- plug (C1 c' tn) (step t'') = App (plug c' (step t'')) tn
                        -- (by computation)                        
                        -- Giving us:
                        -- reduction (App t tn) = reduction (App (plug c' (step t'')) tn)

                        
          
Theorem red_cong' : forall (t:Term)(t_term:t!)(t':Term)(t'_term:t'!)(tn:Term)(tn_term:tn!)
      (p:reduction t = t').
    reduction (App t tn) = reduction (App t' tn) :=
       let n [n_eq] = rLen t t' [p];
           rLen_term = rLen_terminates t t' t'_term p : (rLen t t' [p]) !
       in red_cong n (conv rLen_term at ~(sym n_eq) !) t t_term t' t'_term tn tn_term p n_eq

                        
                        
                        -- and we know (working backwords)
                        -- plug c' (step t'') = reduction t
                        -- which by reduction t = t' we get
                        -- plug c' (step t'') = t'
                        -- and then applying conv, we can get
                        -- reduction (App t tn) = reduction t' tn)



                        
                 
data Step : (t1:Term) (t2:Term) -> Type where
   StepK : (v2:Term) ->
           [val1:isValue t2 = True] -> [val2:isValue v2 = True] -> [idx1:t1 = App (App K t2) v2] ->
           Step t1 t2
 | StepS : (v1:Term) -> (v2:Term) -> (v3:Term) ->
            [val1:isValue v1 = True] -> [val2:isValue v2 = True] -> [val3:isValue v3 = True] ->
            [idx1:t1=App (App (App S v1) v2) v3] -> [idx2:t2 = App (App v1 v2) (App v2 v3)] ->
            Step t1 t2


data StepStar : (t1:Term) (t2:Term) -> Type where
     StepBase : StepStar t1 t2
   | StepTrans : (t1':Term) -> [p1:Step t1 t1'] -> [p2:Step t1' t2] -> StepStar t1 t2


Recursive s_free : (t:Term) -> Bool :=
  case t {t_eq} of
      K -> True
    | S -> False
    | App t1 t2 -> s_free t1 && s_free t2


axiom app_left_monotonic : forall(t1:Term)(t2:Term)(t3:Term)(p:t1 < t2).App t1 t3 < App t2 t3
axiom app_right_monotonic : forall(t1:Term)(t2:Term)(t3:Term)(p:t1 < t2).App t3 t1 < App t3 t2

Inductive plug_preserves_ord : forall(t1:Term)(t1_term:t1!)(t2:Term)(t2_term:t2!)(p:t1 < t2)(c:Ctx){c_term}.
   plug c t1 < plug c t2 :=
     case c {c_eq} c_term of
       Box -> let u1 [u1_eq] = morejoin {sym c_eq, c_term, t1_term} : t1 = plug c t1;
                  u2 [u2_eq] = morejoin {sym c_eq, c_term, t2_term} : t2 = plug c t2
               in conv p at ~u1 < ~u2
      |C1 c' t' -> let u1 [u1_eq] = plug_preserves_ord t1 t1_term t2 t2_term p c' (ord c_eq);
                       u2 [u2_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App (plug c' t1) t';
                       u3 [u3_eq] = morejoin {sym c_eq,t2_term,c_term} : (plug c t2) = App (plug c' t2) t';
                       -- Can't directly use the next two lemmas...
                       o1 [o1_eq] = ord (sym u2) : plug c' t1 < plug c t1;
                       o2 [o2_eq] = ord (sym u3) : plug c' t2 < plug c t2;
                       --
                       u4 [u4_eq] = app_left_monotonic (plug c' t1) (plug c' t2) t' u1
                   in conv u4 at ~(sym u2) < ~(sym u3)
      |C2 t' [q] c' -> 
                   let u1 [u1_eq] = plug_preserves_ord t1 t1_term t2 t2_term p c' (ord c_eq);
                       u2 [u2_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App t' (plug c' t1);
                       u3 [u3_eq] = morejoin {sym c_eq,t2_term,c_term} : (plug c t2) = App t' (plug c' t2);
                       -- Can't directly use the next two lemmas...
                       o1 [o1_eq] = ord (sym u2) : plug c' t1 < plug c t1;
                       o2 [o2_eq] = ord (sym u3) : plug c' t2 < plug c t2;
                       --
                       u4 [u4_eq] = app_right_monotonic (plug c' t1) (plug c' t2) t' u1
                   in conv u4 at ~(sym u2) < ~(sym u3)










Theorem redex_val_left : forall(t1:Term)(t2:Term)(t3:Term)
                    (p:t1=(App (App K t2) t3))(q:isRedex t1 = True).isValue t2 = True :=
    termcase t1 {t1_term} of
      abort -> let u1 = morejoin {sym t1_term} : (abort Term) = (isRedex (abort Term));
                   u2 = conv u1 at (abort Term) = (isRedex ~t1_term);
                   u3 = conv valax True at ~(sym q) !
               in  contraabort u2 u3
    | ! -> let u1 = morejoin {p, t1_term} : isRedex t1 = (isValue t3 && isValue t2);
               u2 = trans (sym q) u1 -- True = isValue t3 && isValue t2 
           in and_right (isValue t3) (isValue t2) (sym u2)


Theorem redex_val_right : forall(t1:Term)(t2:Term)(t3:Term)
                    (p:t1=(App (App K t2) t3))(q:isRedex t1 = True).isValue t3 = True :=
    termcase t1 {t1_term} of
      abort -> let u1 = morejoin {sym t1_term} : (abort Term) = (isRedex (abort Term));
                   u2 = conv u1 at (abort Term) = (isRedex ~t1_term);
                   u3 = conv valax True at ~(sym q) !
               in  contraabort u2 u3
    | ! -> let u1 = morejoin {p, t1_term} : isRedex t1 = (isValue t3 && isValue t2);
               u2 = trans (sym q) u1
           in and_left (isValue t3) (isValue t2) (sym u2)
           


-- axiom decomp_inv_box : forall (t:Term)(t':Term)(p:decompose t = Dec Box t').t=t'
-- axiom decomp_inv_c1 : forall (t:Term)(t':Term)(y:Term)(c':Ctx)
--     (p:decompose t = Dec (C1 c' y) t').exists (x:Term).(t=App x y)
-- axiom decomp_inv_c1_dec_x :
--    forall (t:Term)(t':Term)(x:Term)(y:Term)(c':Ctx)(p:decompose t = Dec (C1 c' y) t').
--        (decompose x = Dec c' t')

-- axiom decomp_inv_c2 : forall (t:Term)(x:Term)(y:Term)(c':Ctx)
--                            (q:isValue x = True)
--                            (p:decompose t =
--                              Dec (C2 x [q] c') y).(t=App x y)


-- axiom dec_term_inj : forall (c1:Ctx)(c2:Ctx)(t1:Term)(t2:Term)(p:Dec c1 t1 = Dec c2 t2).t1 = t2

Inductive plug_decompose_inv :
  forall (t:Term)(t_term:t!)(t':Term)(t'_term:t'!)(c:Ctx){c_term}(p:decompose t = Dec c t').plug c t' = t :=
  case isRedex t {redex_eq} isRedex_terminates t t_term of
      True -> let u1 = morejoin {t_term,sym redex_eq } : decompose t = Dec Box t;
                  u2 = valax (Dec (tcast c by c_term) (tcast t' by t'_term));
                  u3 = morejoin {t_term,u2} :
                        dec_focus (tcast (Dec c t) by u2) = t;
                  u4 = trans (sym p) u1 : Dec c t' = Dec Box t;
                  u5 = dec_ctx_inj c Box t' t c_term (valax Box) t'_term t_term u4 : c = Box;
                  u6 = dec_term_inj c Box t' t c_term (valax Box) t'_term t_term u4 : t' = t;
                  u7 = morejoin {t_term} : plug Box t = t
              in conv u7 at plug ~(sym u5) ~(sym u6) = t
    | False -> (case t {e_eq} t_term of
                  K -> let u1 = morejoin {t_term,sym redex_eq,sym e_eq } : decompose t = Dec Box t;
                           u2 = valax (Dec (tcast c by c_term) (tcast t' by t'_term));
                           u3 = morejoin {t_term,u2} :
                                  dec_focus (tcast (Dec c t) by u2) = t;
                           u4 = trans (sym p) u1 : Dec c t' = Dec Box t;
                           u5 = dec_ctx_inj c Box t' t c_term (valax Box) t'_term t_term u4 : c = Box;
                           u6 = dec_term_inj c Box t' t c_term (valax Box) t'_term t_term u4 : t' = t;
                           u7 = morejoin {t_term} : plug Box t = t
                       in conv u7 at plug ~(sym u5) ~(sym u6) = t
                | S -> let u1 = morejoin {t_term,sym redex_eq,sym e_eq } : decompose t = Dec Box t;
                           u2 = valax (Dec (tcast c by c_term) (tcast t' by t'_term));
                           u3 = morejoin {t_term,u2} :
                                  dec_focus (tcast (Dec c t) by u2) = t;
                           u4 = trans (sym p) u1 : Dec c t' = Dec Box t;
                           u5 = dec_ctx_inj c Box t' t c_term (valax Box) t'_term t_term u4 : c = Box;
                           u6 = dec_term_inj c Box t' t c_term (valax Box) t'_term t_term u4 : t' = t;
                           u7 = morejoin {t_term} : plug Box t = t
                       in conv u7 at plug ~(sym u5) ~(sym u6) = t

                | App x y -> (case isValue x {x_val} isValue_term x (valax x) of
                                True -> (case decompose y {y_eq} (decompose_terminates y (valax y)) of
                                          Dec c' t'' -> 
                                             let u1 = morejoin {t_term, sym x_val, sym y_eq,sym e_eq, sym x_val, valax x, sym redex_eq} :
                                                     decompose t = Dec (C2 x [sym x_val] c') t'';
                                                 u2 = (trans (sym p) u1) -- : ((Dec c t') = (Dec (C2 x [sym x_val] c') t'))
                                                       : (Dec c t' = Dec (C2 x [(sym x_val)] c') t'');
                                                 ctx_term = valax (C2 x [sym x_val] c');                                                       
                                                 u3 = dec_ctx_inj c (C2 x [sym x_val] c') t' t'' c_term ctx_term t'_term (valax t'') u2
                                                       : c = (C2 x [sym x_val] c');
                                                 u4 = dec_term_inj c (C2 x [sym x_val] c') t' t'' c_term ctx_term t'_term (valax t'') u2
                                                       : t' = t'';
                                                 u5 = ord (sym u3) : c' < c;
                                                 ih = plug_decompose_inv y (valax y) t'' (valax t'') c' u5 (sym y_eq):
                                                          (plug c' t'' = y);
                                                     -- plug c' t'' = y
                                                 -- Before, I had the following for u6 and u7. Using 
                                                 -- morejoin with u3 simplifies this...
                                                 -- u6 = morejoin {valax x, valax c', valax t''} :
                                                 --       (plug (C2 x [sym x_val] c') t'') =
                                                 --         App x (plug c' t'');
                                                 -- u7 = conv u6 at (plug ~(sym u3) ~(sym u4)) = App x (plug c' t'');
                                                 u7 = morejoin {valax x, valax c', valax t'',u3,c_term} :
                                                       (plug c t'') =
                                                         App x (plug c' t'');
                                                 -- plug c t'' = App x (plug c' t'')
                                                 u8 = conv u7 at plug c t'' = App x ~ih;
                                                 -- plug c t' = App x y
                                                 u9 = conv u8 at plug c ~(sym u4) = ~e_eq
                                                 -- plug c t' = t
                                             in u9)
                               | False -> (case decompose x {x_eq} decompose_terminates x (valax x) of
                                          Dec c' t'' ->
                                             let u1 = morejoin {t_term, sym x_val, sym x_eq,sym e_eq, sym x_val, valax x, sym redex_eq} :
                                                     decompose t = Dec (C1 c' y) t'';
                                                 u2 = (trans (sym p) u1) -- : ((Dec c t') = (Dec (C2 x [sym x_val] c') t'))
                                                       : (Dec c t' = Dec (C1 c' y) t'');
                                                 ctx_term = valax (C1 c' y);                                                                                                              
                                                 u3 = dec_ctx_inj c (C1 c' y) t' t''  c_term ctx_term t'_term (valax t'') u2
                                                       : c = (C1 c' y);
                                                 u4 = dec_term_inj c (C1 c' y) t' t'' c_term ctx_term t'_term (valax t'') u2
                                                       : t' = t'';
                                                 u5 = ord (sym u3) : c' < c;
                                                 ih = plug_decompose_inv x (valax x) t'' (valax t'') c' u5 (sym x_eq):
                                                          (plug c' t'' = x);
                                                     -- plug c' t'' = x
                                                 u7 = morejoin {valax x, valax c', valax t'',u3,c_term} :
                                                       (plug c t'') =
                                                         App (plug c' t'') y;
                                                 -- plug c t'' = App (plug c' t'') y
                                                 u8 = conv u7 at plug c t'' = App ~ih y;
                                                 -- plug c t' = App x y
                                                 u9 = conv u8 at plug c ~(sym u4) = ~e_eq
                                                 -- plug c t' = t
                                             in u9)))

  -- case c {c_eq} c_term of
  --    Box -> let u1 = morejoin {c_term,sym c_eq,t'_term} : plug c t' = t';
  --               p' = (conv p at decompose t = Dec ~(sym c_eq) t');
  --               u2 = decomp_inv_box t t' p'
  --           in conv u1 at plug c t' = ~(sym u2)
  --  | C1 c' y -> let u1 = morejoin {c_term, sym c_eq, t'_term } : plug c t' = App (plug c' t') y;
  --                   u2 = decomp_inv_c1_dec_x t t' 
  --               in u1
  --  | C2 c' [p] x -> False
   
-- axiom plug_preserves_s_free :
--   forall(t:Term)(t':Term)(t'':Term)(c:Ctx)
--       (p:s_free t = True)(q:decompose t = Dec c t')(q:t'' < t).(s_free t'' = True)

      
Inductive decomp_preserves_s_free : forall(t:Term){t_term}(t':Term)(t'_term:t'!)(c:Ctx)(c_term:c!)
                                (p:s_free t = True)(q:decompose t = Dec c t').(s_free t' = True) :=
  case isRedex t {redex_t_eq} isRedex_terminates t t_term of
          True -> let u1 = morejoin {t_term,sym redex_t_eq} : Dec Box t = decompose t;
                      u2 = dec_term_inj Box c t t' (valax Box) c_term t_term t'_term (trans u1 q) : t = t'
                  in conv p at s_free ~u2 = True
        | False ->
           case t {t_eq} t_term of
              K -> let u1 = morejoin {t_term,sym t_eq} : Dec Box t = decompose t;
                       u2 = dec_term_inj Box c t t' (valax Box) c_term t_term t'_term (trans u1 q) : t = t'
                   in conv p at s_free ~u2 = True
            | S -> let u1 = morejoin {t_term,sym t_eq} : False = s_free t
                   in contra (trans u1 p)
            | App t1 t2 ->
               let u1 = morejoin {sym t_eq,t_term} : s_free t = (s_free t1 && s_free t2);
                      t1_s_free = and_left (s_free t1) (s_free t2) (trans (sym u1) p);
                         -- s_free t1 = True                      
                      t2_s_free = and_right (s_free t1) (s_free t2) (trans (sym u1) p)
                         -- s_free t2 = True
                  in case isValue t1 {val_t1_eq} isValue_term t1 (valax t1) of
                       True -> (case decompose t2 {dec_t2_eq} decompose_terminates t2 (valax t2) of
                                 Dec c' t'' -> 
                                  let u1 = morejoin {sym t_eq, t_term, sym val_t1_eq,sym redex_t_eq,sym dec_t2_eq}  :
                                             decompose t = Dec (C2 t1 [sym val_t1_eq] c') t'';
                                      ctx_term = valax (C2 t1 [sym val_t1_eq] c');
                                      same_ctxs = trans (sym q) u1;
                                      u2 = dec_term_inj c (C2 t1 [sym val_t1_eq] c') t' t'' c_term ctx_term t'_term (valax t'') same_ctxs
                                                       : t' = t'';
                                      u3 = conv sym dec_t2_eq at
                                              decompose t2 = Dec c' ~(sym u2);
                                              -- decompose t2 = Dec c' t'
                                      ih = decomp_preserves_s_free t2 (ord t_eq) t'' (valax t'') c'
                                              (valax c') t2_s_free (sym dec_t2_eq)
                                  in conv ih at s_free ~(sym u2) = True)
                     | False -> (case decompose t1 {dec_t1_eq} decompose_terminates t1 (valax t1) of
                                 Dec c' t'' -> 
                                  let u1 = morejoin {sym t_eq, t_term, sym val_t1_eq,sym redex_t_eq,sym dec_t1_eq}  :
                                             decompose t = Dec (C1 c' t2) t'';
                                      ctx_term = valax (C1 c' t2) : (C1 c' t2) !;
                                      same_ctxs = trans (sym q) u1;
                                      u2 = dec_term_inj c (C1 c' t2) t' t'' c_term ctx_term t'_term (valax t'') same_ctxs
                                                       : t' = t'';
                                      u3 = conv sym dec_t1_eq at
                                              decompose t1 = Dec c' ~(sym u2);
                                              -- decompose t2 = Dec c' t'
                                      ih = decomp_preserves_s_free t1 (ord t_eq) t'' (valax t'') c'
                                              (valax c') t1_s_free (sym dec_t1_eq)
                                  in conv ih at s_free ~(sym u2) = True)

                     
-- axiom decomp_preserves_s_free : forall(t:Term)(t':Term)(c:Ctx)
--                                 (p:s_free t = True)(q:decompose t = Dec c t').(s_free t' = True)

-- Most of the work here is in backward reasoning about
-- termination. For instance, we know can prove `s_free t !`, since
-- `s_free t = True` and `True !`. Moreover `s_free t = s_free t1 &&
-- s_free t2`, under the assumption that `t = App t1 t2`. 
Theorem s_free_app_1 : forall (t:Term)(t1:Term)(t2:Term)(p:t = App t1 t2)
   (q:s_free t = True).(s_free t1 = True) :=
    termcase t {t_term} of
      abort -> let abranch = aborts (s_free ~t_term) : (abort Bool) = s_free t;
                   tbranch = (conv (valax True) at ~(sym q)!) : (s_free t) !
               in contraabort abranch tbranch
    | ! ->   
     let u1 = morejoin {t_term, p} : s_free t = (s_free t1 && s_free t2);
         u2 = (conv valax True at ~(trans (sym q) u1)!) : (s_free t1 && s_free t2) !;
         t1_term =  (and_term_left (s_free t1) (s_free t2) u2) : (s_free t1) !;
         t2_term =  (and_term_right (s_free t1) (s_free t2) u2) : (s_free t2) !         
     in case s_free t1 {t1_eq} t1_term of
          True -> sym t1_eq
         |False ->
           let v1 = morejoin {sym t1_eq, t1_term, t2_term} : (s_free t1 && s_free t2) = False;
               v2 = trans u1 v1 : s_free t = False
           in contra (trans (sym v2) q)

                                
-- axiom s_free_app_1 : forall (t:Term)(t1:Term )(t2:Term)(p:t = App t1 t2)(q:s_free t = True).(s_free t1 = True)

{-
-- axiom decom_ord : forall (t1:Term)(t2:Term)(t':Term)(c:Ctx)(p:decomp )
Inductive s_free_term : forall (t:Term){t_term}(p:s_free t = True).(reduction t) ! :=
  case decompose t {dec_t_eq} (decompose_terminates t t_term) of
    Dec c t' ->
      case isRedex t' {t'_redex} (isRedex_terminates t' (valax t')) of
        False -> let u1 [u1_eq] = morejoin {sym dec_t_eq,t_term,valax c,valax t',sym t'_redex} :
                                    reduction t = plug c t';
                     u2 [u2_eq] = plug_terminates t' (valax t') c (valax c)
                 in  conv u2 at ~(sym u1) !
       |True -> case t' {t'_eq} (valax t') of
                  K -> let u1 [u1_eq] = morejoin {sym t'_eq,valax t'} : isRedex t' = False;
                           con [con_eq] =  trans t'_redex u1 : True = False
                       in contra con
                | S -> let u1 [u1_eq] = morejoin {sym t'_eq,valax t'} : isRedex t' = False;
                           con [con_eq] =  trans t'_redex u1 : True = False
                       in contra con
                 | App t1' t2' ->
                     case t1' {t1'_eq} (valax t1') of
                      S -> let u1 [u1_eq] = conv t'_eq at (App ~(sym t1'_eq) t2') = t';
                               -- App (App S t2') = t
                               u2 [con_eq] = morejoin {valax t',sym u1} :
                                               isRedex t' = False;
                               con [con_eq] = trans t'_redex u2 : True = False
                           in contra con
                    | App t1'' t2'' ->
                       (case t1'' {t1''_eq} (valax t1'') of
                         K -> let u1 [u1_eq] = conv t1'_eq at App ~(sym t1''_eq) t2'' = t1';
                                  u2 [u2_eq] = conv t'_eq at App ~(sym u1) t2' = t';
                                  -- we now have t' = K t2'' t2', which we can reduce.
                                  u3 [u3_eq] =
                                   redex_val_left t' t2'' t2' (sym u2) (sym t'_redex);
                                  u4 [u3_eq] =
                                   redex_val_right t' t2'' t2' (sym u2) (sym t'_redex);
                                  u5 [u3_eq] =
                                    morejoin {valax t',sym t'_eq,valax t1',
                                              sym t1'_eq,
                                              sym t1''_eq,u3,u4} :
                                                 step t' = Just t2'';
                                   u6 [u6_eq] =
                                     morejoin {sym dec_t_eq,t_term,valax t',
                                               sym t'_redex, sym t'_eq, u3,u4,
                                               sym t1'_eq, sym t1''_eq}

                                      : reduction t = reduction (plug c t2'');
                                   u7 [u7_eq] = ord t'_eq : t1' < t';
                                   u8 [u8_eq] = ord t1'_eq : t2'' < t1';
                                   u9 [u9_eq] = ordtrans u8 u7 : t2'' < t';
                                   u10 [u10_eq] =
                                    plug_preserves_ord t2'' (valax t2'') t' (valax t') u9 c (valax c);
                                   u11 [u11_eq] = plug_decompose_inv t t' c (sym dec_t_eq);
                                   u12 [u12_eq] = conv u10 at plug c t2'' < ~u11;
                                   -- Get a proof that plug c t2'' is s_free
                                   u13 [u13_eq] = plug_preserves_s_free t t' (plug c t2'') c p (sym dec_t_eq) u12;
                                   -- Apply the induction hypothesis
                                   u14 [u14_eq] = s_free_term (plug c t2'') u12 u13
                                                 
                               in conv u14 at ~(sym u6) !
                        |S -> let u1 [u1_eq] = conv t1'_eq at App ~(sym t1''_eq) t2'' = t1';
                                  u2 [u2_eq] = conv t'_eq at App ~(sym u1) t2' = t';
                                  s_free_t' [dummy] =
                                    decomp_preserves_s_free t t' c p (sym dec_t_eq);
                                  s_free_t1' [u3_eq] = s_free_app_1 t' t1' t2' (sym t'_eq) s_free_t';
                                       -- s_free t1' = True
                                  s_free_t1'' [u4_eq] = s_free_app_1 t1' t1'' t2'' (sym t1'_eq) s_free_t1';
                                  u3 [u3_eq] = morejoin {valax t1'', sym t1''_eq} : s_free t1'' = False;
                                  con [u4_eq] = trans (sym s_free_t1'') u3
                              in contra con
                       |App t1''' t2''' ->
                           case t1''' {t1'''_eq} (valax t1''') of
                              K -> -- Not a redex
                                let u1 [u1_eq] =
                                       morejoin {valax t', sym t'_eq, sym t1'_eq, sym t1''_eq, sym t1'''_eq} 
                                      : isRedex t' = False;
                                    con [con_eq] = trans (t'_redex) u1
                                 in contra con
                             |App adf sfs -> -- Not a redex
                                 let u1 [u1_eq] =
                                       morejoin {valax t', sym t'_eq, sym t1'_eq, sym t1''_eq, sym t1'''_eq} 
                                      : isRedex t' = False;
                                     con [con_eq] = trans (t'_redex) u1
                                 in contra con

                             |S -> -- Not s_free
                                let t'_s_free [a] = decomp_preserves_s_free t t' c p (sym dec_t_eq);
                                    t1'_s_free [a] = s_free_app_1 t' t1' t2' (sym t'_eq) t'_s_free;
                                    t1''_s_free [a] = s_free_app_1 t1' t1'' t2'' (sym t1'_eq) t1'_s_free;
                                    t1'''_s_free [a] = s_free_app_1 t1'' t1''' t2''' (sym t1''_eq) t1''_s_free;
                                    u1 [a] = morejoin {valax t1''', sym t1'''_eq} : s_free t1''' = False;
                                    con [a] = trans (sym u1) t1'''_s_free
                                in contra con)

                       
                    | K -> -- Not a redex
                       let u1 [u1_eq] =
                             morejoin {valax t', sym t'_eq, sym t1'_eq} 
                               : isRedex t' = False;
                             con [con_eq] = trans (t'_redex) u1
                       in  contra con

-}

Theorem decomp_term_focus  :
  forall (t:Term)(t_term:t!)(c:Ctx)(t':Term)
      (p:decompose t = Dec c t'). t'! :=
  termcase t' {t'_term} of
     abort -> let u1 = (aborts (Dec c ~t'_term)) : ((abort Decomp) = Dec c t');
                  u2 = equiv 2 : (abort Decomp) = decompose t
              in contraabort u2 (decompose_terminates t t_term)
   | ! -> t'_term


   
Inductive plug_preserves_s_free :
  forall (t:Term)(t_term:t!)(t':Term)(t'_term:t'!)(c:Ctx){c_term}(t'':Term)(t''_term:t''!)
     (p:decompose t = Dec c t')(q1:s_free t = True)(q2:s_free t'' = True).(s_free (plug c t'') = True) :=
  case isRedex t {redex_eq} isRedex_terminates t t_term of
      True -> let u1 = morejoin {t_term,sym redex_eq } : decompose t = Dec Box t;
                  -- Get a proof that c = Box       
                  u2 = valax (Dec (tcast c by c_term) (tcast t' by t'_term));
                  u3 = morejoin {t_term,u2} :
                        dec_focus (tcast (Dec c t) by u2) = t;
                  u4 = trans (sym p) u1 : Dec c t' = Dec Box t;
                  u5 = dec_ctx_inj c Box t' t c_term (valax Box) t'_term t_term u4 : c = Box;
                  -- Prove plug c t'' = t''
                  u6 = morejoin {u5,c_term,t''_term,u5} : t'' = plug c t''
              in  conv q2 at s_free ~u6 = True 
    | False -> (case t {e_eq} t_term of
                  K -> let u1 = morejoin {t_term,sym redex_eq,sym e_eq } : decompose t = Dec Box t;
                           -- Get a proof that c = Box       
                           u2 = valax (Dec (tcast c by c_term) (tcast t' by t'_term));
                           u3 = morejoin {t_term,u2} :
                                 dec_focus (tcast (Dec c t) by u2) = t;
                           u4 = trans (sym p) u1 : Dec c t' = Dec Box t;
                           u5 = dec_ctx_inj c Box t' t c_term (valax Box) t'_term t_term u4 : c = Box;
                           -- Prove plug c t'' = t''
                           u6 = morejoin {u5,c_term,t''_term,u5} : t'' = plug c t''
                       in conv q2 at s_free ~u6 = True 

                 |S -> let u1 = morejoin {t_term,sym redex_eq,sym e_eq } : decompose t = Dec Box t;
                           -- Get a proof that c = Box       
                           u2 = valax (Dec (tcast c by c_term) (tcast t' by t'_term));
                           u3 = morejoin {t_term,u2} :
                                 dec_focus (tcast (Dec c t) by u2) = t;
                           u4 = trans (sym p) u1 : Dec c t' = Dec Box t;
                           u5 = dec_ctx_inj c Box t' t c_term (valax Box) t'_term t_term u4 : c = Box;
                           -- Prove plug c t'' = t''
                           u6 = morejoin {u5,c_term,t''_term,u5} : t'' = plug c t''
                       in conv q2 at s_free ~u6 = True 
                | App x y ->
                      let s_free_t = morejoin {t_term,sym e_eq} : s_free t = (s_free x && s_free y);
                          s_free_true = equiv 2 : ((s_free x && s_free y) = True);
                          s_free_x = and_left (s_free x) (s_free y) s_free_true : s_free x = True;
                          s_free_x_term = conv valax True at ~(sym s_free_x) !; 
                          s_free_y = and_right (s_free x) (s_free y) s_free_true : s_free y = True;
                          s_free_y_term = conv valax True at ~(sym s_free_y) !                          
                      in

                         (case isValue x {x_val} isValue_term x (valax x) of
                                True -> (case decompose y {y_eq} (decompose_terminates y (valax y)) of
                                          Dec c' dummy -> 
                                             let u1 = morejoin {t_term, sym x_val, sym y_eq,sym e_eq, sym x_val, valax x, sym redex_eq} :
                                                     decompose t = Dec (C2 x [sym x_val] c') dummy;
                                                 u2 = (trans (sym p) u1) -- : ((Dec c t') = (Dec (C2 x [sym x_val] c') t'))
                                                       : (Dec c t' = Dec (C2 x [(sym x_val)] c') dummy);
                                                 ctx_term = valax (C2 x [sym x_val] c');                                                       
                                                 u3 = dec_ctx_inj c (C2 x [sym x_val] c') t' dummy c_term ctx_term t'_term (valax dummy) u2
                                                       : c = (C2 x [sym x_val] c');

                                                 u4 = morejoin {u3,c_term, t''_term} :
                                                       plug c t'' = App x (plug c' t'');
                                                 plug_term = 
                                                    plug_terminates t'' t''_term c' (valax c'): plug c' t'' !;
                                                 u4_term = (conv
                                                            valax (App x ~(plug_term))
                                                          at ~(sym u4) !) : (plug c t'') !;

                                                 u5 = ord (sym u3) : c' < c;
                                                 ih = plug_preserves_s_free
                                                        y (valax y) dummy (valax dummy) c' u5
                                                          t'' t''_term (sym y_eq) s_free_y q2
                                                            : s_free (plug c' t'') = True;

                        
                                                 ih_term = (conv valax True at ~(sym ih) !) : s_free (plug c' t'') ! ;
                                                 -- This should be derivable from `s_free (plug c' t'') !`
                                                 plug_c'_term = plug_terminates t'' (t''_term) c' (valax c');

                                                 
                                                 u6 = morejoin {u4,u4_term,s_free_x,s_free_x_term,ih,ih_term,plug_c'_term} :
                                                          s_free (plug c t'') = True
                                             in u6)
                               | False -> (case decompose x {x_eq} decompose_terminates x (valax x) of
                                          Dec c' dummy -> 
                                             let u1 = morejoin {t_term, sym x_val, sym x_eq,sym e_eq, valax x, sym redex_eq} :
                                                     decompose t = Dec (C1 c' y) dummy;
                                                 u2 = (trans (sym p) u1) -- : ((Dec c t') = (Dec (C2 x [sym x_val] c') t'))
                                                       : (Dec c t' = Dec (C1 c' y) dummy);
                                                 ctx_term = valax (C1 c' y);
                                                 u3 = dec_ctx_inj c  (C1 c' y) t' dummy c_term ctx_term t'_term (valax dummy) u2
                                                       : c = (C1 c' y);

                                                 u4 = morejoin {u3,c_term, t''_term} :
                                                       plug c t'' = App (plug c' t'') y;

                                                 u4_term = plug_terminates t'' t''_term c' (valax c')
                                                             : (plug c' t'') !;

                                                 u5 = ord (sym u3) : c' < c;
                                                 ih = plug_preserves_s_free
                                                        x (valax x) dummy (valax dummy) c' u5
                                                          t'' t''_term (sym x_eq) s_free_x q2
                                                            : s_free (plug c' t'') = True;

                        
                                                 ih_term = (conv valax True at ~(sym ih) !) : s_free (plug c' t'') ! ;
                                                 plug_c'_term = plug_terminates t'' (t''_term) c' (valax c') :
                                                     (plug c' t'') !;
                                                 u6 = morejoin {u4,u4_term,s_free_y,s_free_y_term,ih,ih_term,plug_c'_term} :
                                                          s_free (plug c t'') = True
                                             in u6)))

   
-- axiom plug_preserves_s_free :
--   forall (t:Term)(c:Ctx)(t':Term)(t'':Term)
--      (p:decompose t = Dec c t')(q1:s_free t = True)(q2:s_free t'' = True).(s_free (plug c t'') = True)



Inductive s_free_term' : forall (t:Term){t_term}(p:s_free t = True).(reduction t) ! :=
  case decompose t {dec_t_eq} (decompose_terminates t t_term) of
    Dec c t' ->
      case isRedex t' {t'_redex} (isRedex_terminates t' (valax t')) of
        False -> let u1 [u1_eq] = morejoin {sym dec_t_eq,t_term,valax c,valax t',sym t'_redex} :
                                    reduction t = plug c t';
                     u2 [u2_eq] = plug_terminates t' (valax t') c (valax c)
                 in  conv u2 at ~(sym u1) !
       |True ->
           let prop_term = redexPropTerm t' (sym t'_redex) in 
           case redexProp' t' [sym t'_redex] {prop_eq} prop_term of
              RedexK t1 t2 [isapp] [isval1] [isval2] ->
                 let -- Prove that t1 < t'
                     o1 = ord (sym isapp) : (App K t1) < t';
                     i0 [i0_eq] = App K t1;
                     o2 = ord (sym i0_eq) : t1 < i0;
                     o3 = conv o2 at t1 < ~i0_eq;
                     o4 = ordtrans o3 o1 : t1 < t';
                     -- Prove plug c t1 < plug c t'
                     o5 = plug_preserves_ord t1 (valax t1) t' (valax t') o4 c (valax c); -- plug c t1 < plug c t'

                     -- Need a proof `s_free (plug c t1) = True`
                     u11 [u11_eq] = plug_decompose_inv t t_term t' (valax t') c (valax c) (sym dec_t_eq);  -- plug c t' = t
                     u13 = conv o5 at plug c t1 < ~u11; -- plug c t1 < t

                     -- Prove that t1 is s_free
                     v2 = morejoin {valax t', valax t1, valax t2, isapp} :
                              s_free t' = ((True && s_free t1) && s_free t2);
                     v3 = decomp_preserves_s_free t (t_term) t' (valax t') c (valax c) p (sym dec_t_eq) : s_free t' = True;
                     v4 = trans (sym v3) v2 : True = ((True && s_free t1) && s_free t2);
                     v5 = and_left (True && s_free t1) (s_free t2) (sym v4) : ((True && s_free t1) = True);
                     t1_s_free = and_right True (s_free t1) v5 : s_free t1 = True;

                     u1 = morejoin {valax t',t_term, sym dec_t_eq, sym t'_redex, sym prop_eq} :
                           reduction t = reduction (plug c t1);
                     plug_c_t1 = plug_preserves_s_free t t_term  t' (valax t') c (valax c) t1 (valax t1) (sym dec_t_eq) p t1_s_free;

                     -- Apply Inductive Hypothesis                     
                     ih = s_free_term' (plug c t1) u13 plug_c_t1 : (reduction (plug c t1)) !
                 in conv ih at ~(sym u1) !
            | RedexS t1 t2 t3 [isapp] [isval1] [isval2] [isval3] ->
                   let p' = decomp_preserves_s_free t t_term t' (valax t') c (valax c) p (sym dec_t_eq);
                       p'' = conv p' at s_free ~isapp = True; -- App (App (App S t1) t2) t3 = True
                       p3 = s_free_app_1 (App (App (App S t1) t2) t3) (App (App S t1) t2) t3
                                  (join 0 0) p'' : s_free (App (App S t1) t2) = True;
                       p4 = s_free_app_1 (App (App S t1) t2) (App S t1) t2 (join 10 10) p3 : s_free (App S t1) = True;
                       p5 = s_free_app_1 (App S t1) S t1 (join 10 10) p4 : s_free S = True;
                       p5_counter = join 10 10 : False = s_free S
                   in contra (trans p5_counter p5)

       

data Nat : Type where
    Z : Nat
  | S : Nat -> Nat


data Parity : Type where
    E : Parity
  | O : Parity

Program flip : (p:Parity) -> Parity :=  
  case p {p_eq} of
      E -> O
    | O -> E

Theorem flip_term : forall (p:Parity)(p_term:p!).flip p ! :=
  case p {p_eq} p_term of
    E -> let u1 = morejoin {sym p_eq, p_term} : O = flip p
         in conv valax O at ~u1!
   |O -> let u1 = morejoin {sym p_eq, p_term} : E = flip p
         in conv valax E at ~u1!

Recursive evenOdd : (p:Parity)(n:Nat) -> Bool :=
  case p {p_eq} of
    E -> (case n {n_eq} of
            Z -> True
           |S n' -> evenOdd (flip p) n')
  | O -> (case n {n_eq} of
            Z -> False
           |S n' -> evenOdd (flip p) n')

Recursive evenOdd : (p:Parity)(n:Nat) -> Bool :=
     case n {n_eq} of
            Z -> (case p {p_eq} of
                    E ->  True
                  | O -> False)
           |S n' -> evenOdd (flip p) n'

           
Inductive evenOdd_term : forall (p:Parity)(p_term:p!)(n:Nat){n_term}.evenOdd p n ! :=
  case p {p_eq} p_term of
    E -> (case n {n_eq} n_term of
            Z -> let u1 = morejoin {sym p_eq, p_term, sym n_eq, n_term} : True = evenOdd p n
                 in conv valax True at ~u1!
           |S n' -> let flip_p_term = flip_term p p_term;
                        u2 = morejoin {sym p_eq,sym n_eq, p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
                        ih = evenOdd_term (flip p) (flip_p_term) n' (ord n_eq)
                    in conv ih at ~(sym u2) !)


   |O -> (case n {n_eq} n_term of
            Z -> let u1 = morejoin {sym p_eq, p_term, sym n_eq, n_term} : False = evenOdd p n
                 in conv valax False at ~u1!
           |S n' -> let flip_p_term = flip_term p p_term;
                        u2 = morejoin {sym p_eq,sym n_eq, p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
                        ih = evenOdd_term (flip p) (flip_p_term) n' (ord n_eq)
                    in conv ih at ~(sym u2) !)
                    

-- Inductive even_odd_opposite : forall (n:Nat){n_term}(p:Parity)(q:evenOdd p n = True).evenOdd (flip p) n = False :=
--   termcase p {p_term} of
--     abort -> let u1 = join 0 10 : (abort Bool) = (evenOdd (abort Parity) n);
--                  u2 = conv u1 at  (abort Bool) = (evenOdd ~p_term n);
--                  u3 = conv valax True at ~(sym q) !
--              in contraabort u2 u3
--    | ! -> case n {n_eq} n_term of
--             Z -> (case p {p_eq} p_term of
--                     E -> morejoin {p_term,n_term,sym p_eq, sym n_eq} --  : evenOdd (flip p) n = False
--                   | O -> let u1 = morejoin {p_term,n_term,sym p_eq, sym n_eq} : False = evenOdd p n
--                          in contra (trans u1 q))
--           | S n' -> let u1 = morejoin {sym n_eq,p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
--                         u2 = trans (sym u1) q; -- evenOdd (flip p) n' = True
--                         ih = even_odd_opposite n' (ord n_eq) (flip p) u2 : evenOdd (flip (flip p)) n' = False;
--                         evenOddn = morejoin {p_term,n_term,sym n_eq,(flip_term p p_term)} : evenOdd (flip p) n = evenOdd (flip (flip p)) n'
--                     in trans evenOddn ih


Inductive even_odd_opposite : forall (n:Nat){n_term}(p:Parity)(b:Bool)(b_term:b!)(q:evenOdd p n = b).evenOdd (flip p) n = (not b) :=
  termcase p {p_term} of
    abort -> let u1 = join 0 10 : (abort Bool) = (evenOdd (abort Parity) n);
                 u2 = conv u1 at  (abort Bool) = (evenOdd ~p_term n);
                 u3 = conv b_term at ~(sym q) !
             in contraabort u2 u3
   | ! -> case n {n_eq} n_term of
            Z -> (case p {p_eq} p_term of
                    E -> (case b {b_eq} b_term of
                           True -> morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term} --  : evenOdd (flip p) n = False
                          |False ->
                            let u1 = morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term}
                                       : True = evenOdd p n
                            in contra (conv (trans u1 q) at True = ~(sym b_eq)))
                  | O -> (case b {b_eq} b_term of
                           True ->
                            let u1 = morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term}
                                     : False = evenOdd p n
                            in contra (conv (trans u1 q) at False = ~(sym b_eq))
                          | False -> morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term})
                         )
          | S n' -> let u1 = morejoin {sym n_eq,p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
                        u2 = trans (sym u1) q; -- evenOdd (flip p) n' = True
                        ih = even_odd_opposite n' (ord n_eq) (flip p) b b_term u2 : evenOdd (flip (flip p)) n' = (not b);
                        evenOddn = morejoin {p_term,n_term,sym n_eq,(flip_term p p_term)} : evenOdd (flip p) n = evenOdd (flip (flip p)) n'
                    in trans evenOddn ih

                    
Program even : (n:Nat) -> Bool := evenOdd E n
Program odd : (n:Nat) -> Bool := evenOdd O n

Theorem even_term : forall (n:Nat)(n_term:n!).even n ! :=
  let u1 = evenOdd_term E (valax E) n n_term;
      u2 = morejoin {n_term} : evenOdd E n = even n
  in conv u1 at ~u2!

Theorem odd_term : forall (n:Nat)(n_term:n!).odd n ! :=
  let u1 = evenOdd_term O (valax O) n n_term;
      u2 = morejoin {n_term} : evenOdd O n = odd n
  in conv u1 at ~u2!
  
  
Theorem pred_even_odd : forall(n:Nat)(n':Nat)(p:n = S n')(q:even n = True).odd n' = True :=
  termcase n {n_term} of
     abort -> let even_abort = morejoin {sym n_term} : (abort Nat) = (even (abort Nat));
                  even_abort_n = conv even_abort at (abort Nat) = (even ~n_term);
                  even_term = conv valax True at ~(sym q) !
              in contraabort even_abort_n even_term
   | ! -> termcase n' {n'_term} of
            abort -> let u1 = join 100 100 : (abort Nat) = (S (abort Nat));
                         u2 = conv u1 at (abort Nat) = (S ~n'_term);
                         u3 = trans u2 (sym p)
                     in contraabort u3 n_term
          | ! -> let u1 = morejoin {p, n_term, n'_term} :  odd n' = even n
                 in trans u1 q

Theorem pred_odd_even : forall(n:Nat)(n':Nat)(p:n = S n')(q:odd n = True).even n' = True :=
  termcase n {n_term} of
     abort -> let odd_abort = morejoin {sym n_term} : (abort Nat) = (odd (abort Nat));
                  odd_abort_n = conv odd_abort at (abort Nat) = (odd ~n_term);
                  odd_term = conv valax True at ~(sym q) !
              in contraabort odd_abort_n odd_term
   | ! -> termcase n' {n'_term} of
            abort -> let u1 = join 100 100 : (abort Nat) = (S (abort Nat));
                         u2 = conv u1 at (abort Nat) = (S ~n'_term);
                         u3 = trans u2 (sym p)
                     in contraabort u3 n_term
          | ! -> let u1 = morejoin {p, n_term, n'_term} :  even n' = odd n
                 in trans u1 q

Theorem even_implies_not_odd : forall (n:Nat)(n_term:n!)(b:Bool)(b_term:b!)(p:even n = b). odd n = (not b) :=
          let u1 = morejoin {n_term} : evenOdd E n = even n;
              u2 = morejoin {n_term} : odd n = evenOdd (flip E) n;
              u3 = even_odd_opposite n n_term E b b_term (trans u1 p)
          in trans u2 u3
   
Theorem even_true_odd_false : forall (n:Nat)(p:even n = True). odd n = False :=
  termcase n {n_term} of
     abort -> let even_abort = morejoin {sym n_term} : (abort Nat) = (even (abort Nat));
                  even_abort_n = conv even_abort at (abort Nat) = (even ~n_term);
                  even_term = conv valax True at ~(sym p) !
              in contraabort even_abort_n even_term
   | ! -> let u1 = even_implies_not_odd n n_term True (valax True) p
          in conv u1 at odd n = ~(join 100 100  : not True = False)

Theorem even_false_odd_true : forall (n:Nat)(p:even n = False). odd n = True :=
  termcase n {n_term} of
     abort -> let even_abort = morejoin {sym n_term} : (abort Nat) = (even (abort Nat));
                  even_abort_n = conv even_abort at (abort Nat) = (even ~n_term);
                  even_term = conv valax False at ~(sym p) !
              in contraabort even_abort_n even_term
   | ! -> let u1 = even_implies_not_odd n n_term False (valax False) p
          in conv u1 at odd n = ~(join 100 100  : not False = True)

-- Not even used
Theorem odd_implies_not_even : forall (n:Nat)(p:odd n = True). even n = False :=
  termcase n {n_term} of
     abort -> let odd_abort = morejoin {sym n_term} : (abort Nat) = (odd (abort Nat));
                  odd_abort_n = conv odd_abort at (abort Nat) = (odd ~n_term);
                  odd_term = conv valax True at ~(sym p) !
              in contraabort odd_abort_n odd_term
   | ! -> let u1 = morejoin {n_term} : evenOdd O n = odd n;
              u2 = morejoin {n_term} : even n = evenOdd (flip O) n;
              u3 = even_odd_opposite n n_term O True (valax True) (trans u1 p);
              u4 = trans u2 u3
          in conv u4 at even n = ~(join 100 100  : not True = False)

Recursive ks : (n:Nat) -> Term :=
  case n {n_eq} of
     Z -> K
    |S n' -> App (ks n') K

Inductive ks_term : forall (n:Nat){n_term}.ks n! :=
   case n {n_eq} n_term of
      Z -> let u1 = morejoin {n_term, sym n_eq}
                  : K = ks n
           in conv valax K at ~u1 !
    | S n' -> let ord_n = ord n_eq
                        : n' < n;
                  ks'_term = ks_term n' ord_n
                           : (ks n') !;
                  this = morejoin {sym n_eq,n_term}
                       : App (ks n') K = ks n;
                  terms = valax (App (tcast (ks n') by ks'_term) K)
                        : (App (tcast (ks n') by ks'_term) K) !
               in conv terms at ~this !

               
data ThmPair : [n:Nat] -> Type where
  ThmPf : [p1:(forall (p:even n = True).(reduction (ks n) = K))] ->
          [p2:(forall (p:odd n = True).(reduction (ks n) = App K K))] ->
            ThmPair n

            

-- axiom red_cong : forall (t:Term)(t':Term)(tn:Term)(p:reduction t = t').
--     reduction (App t tn) = reduction (App t' tn)

    
Inductive ks_thm : forall(n:Nat){n_term}.exists (x:ThmPair n).x! :=
   case n {n_eq} n_term of
     Z -> let even_n [u1_eq] = morejoin {sym n_eq,n_term} : even n = True;
              ks_z [ks_z_eq] = morejoin {sym n_eq,n_term} : reduction (ks n) = K
          in (pack (ThmPf [n] [\ (p':even n = True) => ks_z]
                         [\ (p':odd n = True) => contra (trans (sym (even_true_odd_false n even_n)) p')]),
                  (valax
                    (ThmPf [n] [\ (p':even n = True) => ks_z]
                           [\ (p':odd n = True) => contra (trans (sym (even_true_odd_false n even_n)) p')])))
    |S n' -> let u1 [u1_eq] = ks_thm n' (ord n_eq)
             in unpack u1 as (pf, pf_term) in
                  case pf {pf_eq} pf_term of
                    ThmPf [p1] [p2]  ->
                      case even n {even_n} even_term n n_term of
                         True -> let u1 [u1_eq] = p2 (pred_even_odd n n' (sym n_eq) (sym even_n));
                                          -- reduction (ks n') = App K K
                                     u2 [u2_eq] = morejoin {n_term, valax n', sym n_eq} :
                                                    ks n = App (ks n') K;
                                     -- The termination arguments should be eventually removed
                                     ks_n'_term = ks_term n' (valax n');

                                     u3 [u3_eq] = red_cong' (ks n') ks_n'_term (App K K) (valax (App K K)) K (valax K) u1;
                                         -- reduction (App (ks n') K) = reduction (App (App K K) K)
                                     u4 [u4_eq] = join 100 0 : 
                                       reduction (App (App K K) K) = K;
                                     u5 [u5_eq] = trans u3 u4;
                                     u6 [u6_eq] = conv u5 at reduction ~(sym u2) = K

                                 in pack
                                     (ThmPf [n]
                                      [\(p:even n = True) => u6]
                                      [\(q:odd n = True) =>
                                         let v1 [v1_eq] = sym (even_true_odd_false n (sym even_n))
                                         in contra (trans v1 q)
                                      ]),
                                      (valax (ThmPf [n]
                                            [\(p:even n = True) => u6]
                                            [\(q:odd n = True) =>
                                              let v1 [v1_eq] = sym (even_true_odd_false n (sym even_n))
                                              in contra (trans v1 q)
                                            ]))

                        |False -> let odd_true = even_false_odd_true n (sym even_n);
                                      u1 [u1_eq] = p1 (pred_odd_even n n' (sym n_eq) odd_true);
                                          -- reduction (ks n') = K
                                      u2 [u2_eq] = morejoin {n_term, valax n', sym n_eq} :
                                                    ks n = App (ks n') K;
                                      -- Termination stuff               
                                      ks_n'_term = ks_term n' (valax n');
                                      u3 [u3_eq] = red_cong' (ks n') ks_n'_term K (valax K) K (valax K) u1;
                                      u4 [u4_eq] = join 100 0 :
                                       reduction (App K K) = App K K;
                                      u5 [u5_eq] = trans u3 u4;
                                      u6 [u6_eq] = conv u5 at reduction ~(sym u2) = App K K
                                  in 

                                  pack
                                     (ThmPf [n]
                                      [\(q:even n = True) =>
                                          contra (trans even_n q)
                                      ])
                                      [\(p:odd n = True) => u6]
                                      ,
                                      (valax
                                     (ThmPf [n]
                                      [\ (q:even n = True) =>
                                          contra (trans even_n q)
                                      ]
                                      [\ (p:odd n = True) => u6]
                                      ))


