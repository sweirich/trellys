-- Finite maps, implemented by left-leaning red-black trees.

--  Actually, for now I will not even make them red-black, because I'm lazy.

module BST where
import Prelude

data Ord (a:Type 0 @log) : Type 0 where
 OrdDict of (lt : (a@log) -> (a@log) -> Bool  @log) 
            [refl : (x:a@log) -> lt x x = False  @log]
            [antisymm :  (x : a@log) -> (y : a@log) -> lt x y = False -> lt y x = False -> x = y @log]
            [trans :  (x:a@log) -> (y:a@log) -> (z:a@log) -> lt x y = True -> lt y z = True -> lt x z = True @log]

-- Convenient (well, sort of) projection for the first component
log ordLt : [a:Type 0@log] -> (Ord a) -> (a@log) -> (a@log) -> Bool
ordLt = \[a]. \order. case order [_] of
                     OrdDict lt [_] [_] [_] -> lt

-- Restatements of the Ord laws in terms of the projection function
ordLtRefl : [a:Type 0@log] -> (order: Ord a) -> (x: a@log) -> ordLt [a] order x x = False
ordLtRefl = \[a].\order.\x.
  case order [_] of
    OrdDict lt [refl] [antisymm] [trans] -> 
      let _ = (join : ordLt [a] (OrdDict [a] lt [refl] [antisymm] [trans]) x x = lt x x) in
      let [_] = refl x in
      _

ordLtAntiSymm : [a:Type 0@log] -> (order: Ord a) -> (x: a@log) -> (y: a@log) ->
                  ordLt [a] order x y = False -> ordLt [a] order y x = False -> x = y
ordLtAntiSymm = \[a].\order.\x.\y.\h1.\h2.
  case order [_] of
    OrdDict lt [refl] [antisymm] [trans] -> 
      let _ = (join : ordLt [a] (OrdDict [a] lt [refl] [antisymm] [trans]) = lt) in
      let [_] = antisymm x y h1 h2 in
      _

ordLtTrans : [a:Type 0@log] -> (order: Ord a) -> (x: a@log) -> (y: a@log) -> (z: a@log) ->
                  ordLt [a] order x y = True -> ordLt [a] order y z = True -> ordLt [a] order x z = True
ordLtTrans = \[a].\order.\x.\y.\z.\h1.\h2.
  case order [_] of
    OrdDict lt [refl] [antisymm] [trans] -> 
      let _ = (join : ordLt [a] (OrdDict [a] lt [refl] [antisymm] [trans]) = lt) in
      let [_] = trans x y z h1 h2 in
      _

data Tree (a:Type 0 @log) : Type 0 where
  EmptyTree
  BranchTree of (_ : Tree a) (_ : a) (_ : Tree a)

-- An alternative idea might be to try to keep the BST-ness of the tree as proofs 
-- stored in the nodes. But that doesn't work, because we need to define the 
-- tree type before we can define the InTree predicate.

data InTree (a:Type 0 @log) (x : a @log) (t : Tree a @log) : Type 0 where
  InHere  of (t1 : Tree a) (t2 : Tree a) (t = BranchTree [a] t1 x t2)
  InLeft  of (t1 : Tree a) (y : a @log) (t2 : Tree a) (InTree a x t1) (t = BranchTree [a] t1 y t2)
  InRight of (t1 : Tree a) (y : a @log) (t2 : Tree a) (InTree a x t2) (t = BranchTree [a] t1 y t2)

data IsBST (a:Type 0 @log) (t : Tree a @log) (order : Ord a) : Type 0 where
  IsBSTEmpty of (t = EmptyTree [a])
  IsBSTBranch of (t1 : Tree a) (x : a@log) (t2 : Tree a) 
                 (t = BranchTree [a] t1 x t2)
                 (IsBST a t1 order)
                 ((y : a@log) -> (InTree a y t1 @log) -> ordLt [a] order y x = True)
                 (IsBST a t2 order)
                 ((y : a@log) -> (InTree a y t2 @log) -> ordLt [a] order x y = True)

log member : [a:Type 0 @log] -> Ord a -> (x : a@log) -> (t : Tree a @log) -> Bool
member = \[a]. \order. \x. ind member t = 
  case t [t_eq] of 
    EmptyTree -> False
    BranchTree t1 y t2 -> case (ordLt [a] order x y) [_] of
                            True -> member t1 [ord t_eq]
                            False -> case (ordLt [a] order y x) [_] of
                                       True -> member t2 [ord t_eq]
                                       False -> True


log member_In1 : (a:Type 0 @log) -> (order : Ord a) -> (x : a@log) -> (t : Tree a @log)
                  ->  (InTree a x t @log)-> member [a] order x t = True
member_In1 = \a.\order.\x. ind member_In1 t = \in_t.
  case in_t [_] of 
    InHere  t1 t2 t_eq -> 
      let _ = (ordLtRefl [a] order x) in
{-      let _ = (join : member [a] order x (BranchTree [a] t1 x t2) = 
                      ((case (ordLt [a] order x x) [_] of
                          True -> member [a] order x t1
                          False -> case (ordLt [a] order x x) [_] of
                                     True -> member [a] order x t2
                                     False -> True) : Bool)) in -}
          TRUSTME
    InLeft  t1 y t2 in_t1 t_eq -> TRUSTME
    InRight t1 y t2 in_t2 t_eq -> TRUSTME


