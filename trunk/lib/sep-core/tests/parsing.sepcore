
Data nat :: type 0 where
 Z :: nat
| S :: pi x:+nat.nat. 

Data Bool :: Type 0 where
 True :: Bool
| False :: Bool.

pred :: Pi x:+nat.nat. 
pred := \ x:+nat. case x of 
     	  	       Z -> Z
		       | S n -> n.

data Balance :: Pi (hL:nat). Pi (hR:nat). Pi (hMax:nat). Type 0 where
    Less :: Pi $u:-  hR = (S hL).Pi $v:-  hMax = hR.  (Balance hL hR hMax)
  | Same :: pi $u:- hR= hL. pi $v:- hMax = hR. Balance hL hR hMax
  | More :: Pi $u:-  hL = (S hR).pi $v:-  hMax= hL. Balance hL hR hMax.

data tree :: pi x : nat. type 0 where
   Leaf ::  tree x  
 | Node ::  Pi trl : + (tree x) . Pi trr : +tree x. tree x.


largerThan :: Pi a:+nat. Pi b:+nat. Bool. 
largerThan := rec a f : (Pi a:+nat. Pi b:+nat. Bool).\b:+nat. 
   case a of
     Z -> case b of
               Z -> True
              | S b' -> False
    |S a' -> case b of
               Z -> True
              |S b' ->  f a' b'.






plusnat :: pi x:+nat.pi y:+nat.nat.
plusnat := rec x plus : (pi x:+nat.pi y:+nat.nat). \y:+nat. 
    	       case x of  
    	       	   Z -> y
    		 | S u -> plus u y.

--$x :: @y
