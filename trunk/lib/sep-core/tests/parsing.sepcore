
data nat :: type 0 where
Z :: nat
| S :: pi x:+nat.nat 

data Bool :: Type 0 where
 True :: Bool
| False :: Bool

pred :: Pi x:+nat.nat 
pred := \ x:+nat. case x of 
     	  	       Z -> Z
		       | S n -> n


largerThan :: Pi a:+nat. Pi b:+nat. Bool 
largerThan := rec a f : (Pi a:+nat. Pi b:+nat. Bool).\b:+nat. 
  case a of
    Z -> (case b of
              Z -> True
             | S b' -> False)
   |S a' -> case b of
              Z -> True
             |S b' -> (+ (+ f a') b')

data Balance :: Pi hL:nat. Pi hR:nat. Pi hMax:nat. Type 0 where
   Less :: Pi $u:- (eq hR (+ S hL)).Pi $v:- (eq hMax hR). (+ (+ (+ Balance hL) hR) hMax)
 | Same :: pi $u:- (eq hR hL). pi $v:- (eq hMax hR). (+ (+ (+Balance hL) hR) hMax)
 | More :: Pi $u:- (eq hL (+ S hR)).pi $v:- (eq hMax hL). (+ (+ (+Balance hL) hR) hMax)


data tree :: Pi x : nat. type 0 where
  Leaf ::  (+ tree x)  
| Node ::  Pi trl : + (+ tree x) . Pi trr : + (+ tree x).  (+ tree x)



plusnat :: pi x:+nat.pi y:+nat.nat
plusnat := rec x plus : (pi x:+nat.pi y:+nat.nat). \y:+nat. 
   	       case x of  
   	       	   Z -> y
   		 | S u -> (+ (+ plus u) y)

--$x :: @y
