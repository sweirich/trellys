module IndVRDemo where


data Nat : Type where
  Z : Nat
| S : Nat -> Nat


prog bad : Nat -> Nat
def bad = rec bad (n:Nat) . S (bad n)


theorem fz : S (bad Z) = bad Z
proof fz = join 1 1

theorem fzo : bad Z < bad Z
proof fzo = ord fz



theorem g : forall (x:Nat)(u:x!)(p:x = bad Z). Z = S Z
proof g = ind g (x : Nat) [u]. \(p:x = bad Z) =>
  g (bad Z) (conv fzo at bad Z < ~(sym p)) (join 1 1 : bad Z = bad Z)


theorem terrible : Z = S Z
proof terrible = g Z (value Z)  (join 1000 1000)
