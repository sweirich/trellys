module ParseTest where



data Nat : Type where
  | Z : Nat
  | S : Nat -> Nat


theorem idprog : forall (a : Type).forall (x : a).(x = x)
proof idprog = \(a:Type) => \(x:a) => join 1 1



prog plus : (x:Nat) -> (y:Nat) -> Nat
def plus = rec plus (x:Nat) . \(y:Nat) ->
  case x {xeq} of
    Z -> y
    (S x') -> S (plus x' y)

theorem plus_right_unit : forall (x:Nat).plus x Z = x
proof plus_right_unit = \(x:Nat) =>
  termcase x {xterm} of -- abort = x
     | abort -> strict (plus ~xterm Z) -- convert abort = x to  (x + 0) = abort
		                            -- convert x = abort to (x + 0) = x

     | ! -> (ind f (n:Nat) [u] .
		          case n {n_eq} u of -- n_eq = Z = n
                Z -> conv join 0 0 at (plus ~n_eq Z = ~n_eq)
							        -- convert Z + Z = Z to
    								  -- n + Z = n
                S n' ->  -- n_eq = (S n') = n
								         -- ord n_eq : (n' < n)
                   let ih [ih_eq] = f n' (ord n_eq) in -- plus n' 0 = n'
									 let x [xa] =  conv (join 0 1: plus (S n') Z = S(plus n' Z))
                                   at plus ~n_eq Z = S ~ih  in
									 -- x: plus n Z = S n'
									 conv x at plus n Z = ~n_eq -- plus n Z = n
									 ) x xterm

-- theorem idprog : ∀(a:Type).∀(x:a).x = x
-- proof idprog = Λ(a:Type).Λ(x:a). join 1 1

{-

prog a : (x:b) -> a
def a = c


theorem a : (y: Formula 0) -> (Formula 1 = Formula 2)!
proof a = a


theorem a : Formula
proof a = \(x:Formula) => x

theorem a : Formula
proof a = \(x:Formula) -> x

theorem a : Formula
proof a = \[x:Formula] => x

theorem a : Formula
proof a = \[x:Type] -> x


theorem b : Formula
proof b = case a {aEq} b of
   | Cons x xs -> c
   | Nil -> d

theorem b : Formula
proof b = case a {aEq}  of
    | Cons x xs -> c a b [c] [d] e
    | Nil -> d


theorem c : Formula
proof c = termcase a {pf} of
      | abort -> c
      | ! -> d



theorem c : Formula
proof c = join 1 1 : a b c = defue b


theorem e : Formula
proof e = contra a b c

theorem e : Formula
proof e = contraabort a b c using f


theorem e : Formula
proof e = conv C a b c by a, [b], c at a b c. d


theorem e : Formula
proof e = ind f (x:int) [u] -> g h i j

prog e : Type
def e = rec f (x:int) -> g h i j

data A : a where
  | A : (b:A) -> (c:B) -> d
  | B : (a:Type) -> A


-- Predicates
-- The notation \(x:A) => t (with a double arrow =>) corresponds to a capital lambda
theorem predLam : \(x:A) => x
proof predLam = \(x:A) => x

theorem predLamUni : Λ(x:A) . x
proof predLamUni = Λ(x:A) . x


theorem covProof : ∀(P : (∀(n:Nat).Formula)).
		P Z =>
		(∀(n : Nat).(∀(m : Nat). (m < n) -> P m) ->  P n) ->
		(∀(n : Nat) . P n)
proof covProof = P



-}

