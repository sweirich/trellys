module ParseTest where


data Nat : Type where
  Z : Nat
| S : Nat -> Nat




theorem idprog : forall (a : Type).forall (x : a).(x = x)
proof idprog = \(a:Type) => \(x:a) => join 1 1



prog plus : (x:Nat) -> (y:Nat) -> Nat
def plus = rec plus (x:Nat) . \(y:Nat) ->
  case x {xeq} of
    Z -> y
    | S x' -> S (plus x' y)
    
prog plus2 : Pi(x:Nat)(y:Nat) -> Nat
def plus2 = rec plus (x:Nat) . \(y:Nat) ->
  case x {xeq} of
    Z -> y
    | S x' -> S (plus x' y)
    

theorem plus_right_unit_term : forall (n:Nat). forall (u:n!) .plus n Z = n
proof plus_right_unit_term = ind f (n:Nat) [u] .
		          case n {n_eq} u of -- n_eq = Z = n
                Z -> conv join 0 0 at (plus ~n_eq Z = ~n_eq)
							        -- convert Z + Z = Z to
    								  -- n + Z = n
                | S n' ->  -- n_eq = (S n') = n
								         -- ord n_eq : (n' < n)
                   let ih [ih_eq] = f n' (ord n_eq) in -- plus n' 0 = n'
									 let x [xa] =  conv (join 0 1 : plus (S n') Z = S(plus n' Z))
                                    at plus ~n_eq Z = S ~ih  in
									 -- x: plus n Z = S n'
									 conv x at plus n Z = ~n_eq -- plus n Z = n


theorem plus_right_unit : forall (x:Nat). plus x Z = x
proof plus_right_unit = \(x:Nat) =>
  termcase x {xterm} of
     | abort -> -- aborts (plus ~xterm Z)
                sym (conv aborts (plus ~xterm Z) at ~xterm = plus x Z)
		              -- convert abort = x to  (x + 0) = abort
		              -- convert x = abort to (x + 0) = x
     | ! -> plus_right_unit_term x xterm

theorem plus_z_z : plus (plus Z Z) Z = plus Z Z
proof plus_z_z = plus_right_unit (plus Z Z)

prog copy : (x:Nat) -> Nat
def copy = rec copy (x:Nat) .
  case x {xeq} of
    Z -> Z
    | S x' -> S (copy x')


theorem f : forall (n : Nat). forall (p:((S (copy n))) !) . (copy n) !
proof f = \(n:Nat) => \(p:(S (copy n)) !) =>
  termcase copy n {u} of
    | abort -> contraabort (aborts (S ~u)) p
    |	! -> u
    
theorem finv : forall (n : Nat) (p:((copy n)!)) . (S(copy n)) !
proof finv = \(n:Nat) (p:((copy n) !)) =>
  termcase copy n {u} of
    | abort -> contraabort (aborts ~u) p
    |	! -> value (S ~u)
    

theorem copyStrictAndTerminating : forall (n : Nat). forall  (p: n!) . (copy n)!
proof copyStrictAndTerminating = ind f (n:Nat) [p] .
   case n {n_eq} p of -- n_eq = Z = n
       Z -> let x0 [p0] = value Z;                      -- Z! 
                x1 [p1] = join 1 1 : (Z = copy Z);      -- Z = copy Z
                x2 [p2] = conv x1 at (Z = copy ~n_eq);  -- Z = copy n
                x3 [p3] = conv x0 at (~x2)!             -- (copy n)!
            in x3
     | S n' ->  -- n_eq : (S n') = n
            let ih [ih_eq] = f n' (ord n_eq);       -- (copy n')!
                x1 [p1] = value (S ~ih);            -- (S(copy n'))!
                x2 [p2] = ((join 1 1):                 (S(copy n') = copy(S n'))) ;
                x3 [p3] = conv x1 at (~x2 !);        -- copy(S n')!
                x4 [p4] = conv x3 at ((copy ~n_eq)!)
            in x4


theorem funTerm : forall (tT:Type).
                  forall (t'T:tT -> Type).
                  forall (e1 : (t:tT) -> t'T t).
                  forall (e2: tT).
                  forall (p: (e1 e2) !) . e1 !
proof funTerm = \ (tT:Type) => \(t'T:tT -> Type) => \(e1 : (t:tT) -> t'T t)=> \(e2: tT) => \ (p: (e1 e2) !) =>
    termcase e1 {u} of
      | abort -> contraabort (aborts (~u e2)) p
      |	! -> u
      
theorem argTerm : forall (tT:Type).
                  forall (t'T:tT -> Type).
                  forall (e1 : (t:tT) -> t'T t).
                  forall (e2: tT).
                  forall (p: (e1 e2) !) . e2 !
proof argTerm = \ (tT:Type) => \(t'T:tT -> Type) => \(e1 : (t:tT) -> t'T t)=> \(e2: tT) => \ (p: (e1 e2) !) =>
    termcase e2 {u} of
      | abort -> contraabort (aborts (e1 ~u)) p
      |	! -> u      



-- theorem g : forall (e : Nat) .
-- 				forall (f:(Nat -> Nat)) . forall (e':Nat).
-- 				forall (u:e!) . forall (v:e = f e') . e' !
-- proof g = Z




-- theorem idprog : ?(a:Type).?(x:a).x = x
-- proof idprog = ?(a:Type).?(x:a). join 1 1

{-

prog a : (x:b) -> a
def a = c


theorem a : (y: Formula 0) -> (Formula 1 = Formula 2)!
proof a = a


theorem a : Formula
proof a = \(x:Formula) => x

theorem a : Formula
proof a = \(x:Formula) -> x

theorem a : Formula
proof a = \[x:Formula] => x

theorem a : Formula
proof a = \[x:Type] -> x


theorem b : Formula
proof b = case a {aEq} b of
   | Cons x xs -> c
   | Nil -> d

theorem b : Formula
proof b = case a {aEq}  of
    | Cons x xs -> c a b [c] [d] e
    | Nil -> d


theorem c : Formula
proof c = termcase a {pf} of
      | abort -> c
      | ! -> d



theorem c : Formula
proof c = join 1 1 : a b c = defue b


theorem e : Formula
proof e = contra a b c

theorem e : Formula
proof e = contraabort a b c using f


theorem e : Formula
proof e = conv C a b c by a, [b], c at a b c. d


theorem e : Formula
proof e = ind f (x:int) [u] -> g h i j

prog e : Type
def e = rec f (x:int) -> g h i j

data A : a where
  | A : (b:A) -> (c:B) -> d
  | B : (a:Type) -> A


-- Predicates
-- The notation \(x:A) => t (with a double arrow =>) corresponds to a capital lambda
theorem predLam : \(x:A) => x
proof predLam = \(x:A) => x

theorem predLamUni : ?(x:A) . x
proof predLamUni = ?(x:A) . x


theorem covProof : ?(P : (?(n:Nat).Formula)).
		P Z =>
		(?(n : Nat).(?(m : Nat). (m < n) -> P m) ->  P n) ->
		(?(n : Nat) . P n)
proof covProof = P



-}

