module SK where

flag ImplicitArgs false

data Bool : Type where
    True : Bool
  | False : Bool

Program not : (b:Bool) -> Bool :=
  case b {b_eq} of
    True -> False
   |False -> True


data Maybe : [a:Type] -> Type where
    Just : (x:a) -> Maybe a
  | Nothing : Maybe a
  

data Term : Type where
    S : Term
  | K : Term
  | App : Term -> Term -> Term


  
infixr 8 &&
infixr 8 ||

Program (&&) : (x:Bool)(y:Bool) -> Bool :=
   case x {x_eq} of
     True -> y
    | False -> False


Theorem and_term : forall(x:Bool)(y:Bool)(x_term:x!)(y_term:y!).(x && y) ! :=
        case x {x_eq} x_term of
          True -> let u1 [u1_eq] = morejoin {x_term,y_term,sym x_eq} : y = (x && y)
                  in conv y_term at ~(u1) !
         |False -> let u1 [u1_eq] = morejoin {x_term,y_term,sym x_eq} : False = (x && y)
                   in conv valax False at ~(u1) !                 

    

Program (||) : (x:Bool)(y:Bool) -> Bool :=
   case x {x_eq} of
      False -> y
    | True -> True
  
-- Recursive value predicate
Recursive isValue : (t:Term) -> Bool :=
  case t {t_eq} of
    K -> True
   |S -> True
   |App l r -> (case l {l_eq} of
                   K -> isValue r
                 | S -> isValue r
                 | App l' r' -> (case l' {l'_eq} of
                                    S -> isValue r' && isValue r
                                  | K -> False
                                  | App a b -> False))
Inductive isValue_term : forall (t:Term){t_term}.isValue t ! :=
  case t {t_eq} t_term of
    K -> let u1 [u1_eq] = morejoin {t_term, sym t_eq} :  True = isValue t
         in conv valax True at  ~u1 !
   |S -> let u1 [u1_eq] = morejoin {t_term, sym t_eq} :  True = isValue t
         in conv valax True at  ~u1 !
   | App l r -> case l {l_eq} (valax l) of
                  K -> let u1 [u1_eq] = isValue_term r (ord t_eq) : isValue r !;
                           u2 [u2_eq] = morejoin {sym t_eq, sym l_eq, t_term, valax r} : isValue r = isValue t
                       in conv u1 at ~u2 !
                 |S -> let u1 [u1_eq] = isValue_term r (ord t_eq) : isValue r !;
                           u2 [u2_eq] = morejoin {sym t_eq, sym l_eq, t_term, valax r} : isValue r = isValue t
                       in conv u1 at ~u2 !
                 |App l' r' -> case l' {l'_eq} valax l' of
                                  S -> let ih_r = isValue_term r (ord t_eq : r < t);
                                           ih_r' = isValue_term r'
                                                     (ordtrans (ord l_eq : r' < l) (ord t_eq : l < t));
                                           u1 [u1_eq] = and_term (isValue r') (isValue r) ih_r' ih_r;
                                           u2 [u2_eq] =
                                            morejoin {sym t_eq,sym l_eq,sym l'_eq, t_term, valax l,valax l'} :
                                              ((isValue r' && isValue r) = isValue t)
                                       in conv u1 at ~u2 !
                                 | K -> let u1 [u1_eq] = morejoin {sym t_eq,sym l_eq,sym l'_eq,t_term,valax l,valax l'} :
                                              False = isValue t
                                        in conv valax False at ~u1 !
                                 | App a b ->
                                     let u1 = morejoin {sym t_eq,sym l_eq,sym l'_eq,t_term,valax l,valax l'} :
                                              False = isValue t
                                     in conv valax False at ~u1 !

data Ctx : Type where
    Box : Ctx
  | C1 : Ctx -> Term -> Ctx
  | C2 : (t:Term) -> [p:isValue t = True] -> Ctx ->  Ctx


data Decomp : Type where
  Dec : (c:Ctx) -> (t:Term) -> Decomp
  
  
Recursive plug : (c:Ctx)(t:Term) -> Term :=
  case c {c_eq} of
      Box -> t
    | C1 c' t' -> App (plug c' t) t' 
    | C2 v [pf] c' -> App v (plug c' t)

Program isRedex : (t:Term) -> Bool :=
  case t {t_eq} of
      K -> False
    | S -> False
    | App f1 t1 ->
       case f1 {f2_eq} of
           K -> False
         | S -> False
         | App f2 t2 -> case f2 {f2_eq} of
                           K -> isValue t1 && isValue t2
                         | S -> False
                         | App f2 t3 ->
                            case f2 {f2_eq} of
                              K -> False
                              | S -> isValue t1 && isValue t2 && isValue t3
                              | App f3 t4 -> False

data RedexProp : [t:Term]  -> Type where
  RedexK : [t1:Term] -> [t2:Term] -> [p:t = App (App K t1) t2] ->
           [p1:isValue t1 = True] -> [p2:isValue t2 = True] -> RedexProp t
 |RedexS : [t1:Term] -> [t2:Term] -> [t3:Term] ->
             [p:t = App (App (App S t1) t2) t3] ->
             [p1:isValue t1 = True] -> [p2:isValue t2 = True] -> [p3:isValue t3 = True] ->
             RedexProp t
                              


Inductive redexProp : forall(t:Term){t_term}(p:isRedex t = True).
                        (exists (rp:RedexProp t).rp!) :=
  case t {t_eq} t_term of
      K -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
           in contra (trans u1 p)
    | S -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
           in contra (trans u1 p)
    | App f1 t1 ->
       case f1 {f1_eq} valax f1 of
           K ->
             let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq} : False = isRedex t
             in contra (trans u1 p)
         | S ->
             let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq} : False = isRedex t
             in contra (trans u1 p)

         | App f2 t2 -> case f2 {f2_eq} valax f2 of
                           K -> -- FIXME: Need to include isValue proofs.
                             --  isValue t1 && isValue t2
                             (let u1 [u1_eq] = conv sym t_eq at t = App ~(sym f1_eq) t1;
                                 u2 [u2_eq] = conv u1 at t = App (App ~(sym f2_eq) t2) t1;
                                 val_t1_term [u3_eq] = isValue_term t1 (valax t1);
                                 val_t2_term [u4_eq] = isValue_term t2 (valax t2)
                             in (case isValue t1 {val_t1} val_t1_term of
                                 False -> 
                                 let notRedex [asd] = morejoin {u2,t_term,val_t1_term,val_t2_term,sym val_t1} : False = isRedex t
                                  in contra (trans notRedex p)
                                |True ->
                                  (case isValue t2 {val_t2} val_t2_term of
                                    False ->
                                     let notRedex [asd] = morejoin {u2,t_term,val_t1_term, val_t2_term, sym val_t1, sym val_t2} : isValue t2 = isRedex t
                                     in contra trans (trans val_t2 notRedex) p
                                   | True ->
                                        pack (RedexK [t] [t2] [t1] [u2] [sym val_t2] [sym val_t1]),
                                             (valax (RedexK [t] [t2] [t1] [u2] [sym val_t2] [sym val_t1]))
                                   )))


                                 
                         | S ->
                            let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq,sym f2_eq} : False = isRedex t
                            in contra (trans u1 p)
                         | App f3 t3 ->
                            case f3 {f3_eq} (valax f3) of
                              K ->
                               let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq,sym f2_eq, sym f3_eq} : False = isRedex t
                               in contra (trans u1 p)
                            | S ->
                             let u1 [u1_eq] = conv sym t_eq at t = App ~(sym f1_eq) t1;
                                 u2 [u2_eq] = conv u1 at t = App (App ~(sym f2_eq) t2) t1;
                                 u3 [u3_eq] = conv u2 at t = App (App (App ~(sym f3_eq) t3) t2) t1;
                                 val_t1_term [u3_eq] = isValue_term t1 (valax t1);
                                 val_t2_term [u4_eq] = isValue_term t2 (valax t2);
                                 val_t3_term [u5_eq] = isValue_term t3 (valax t3);
                                 val_and_t2_t3 [u6_eq] =
                                    and_term (isValue t2) (isValue t3) val_t2_term val_t3_term
                             in (case isValue t1 {val_t1} val_t1_term of
                                   False -> let v1 [v1_eq] =
                                                 morejoin {u3, t_term, sym val_t1,
                                                    val_t1_term,val_t2_term,val_t3_term,val_and_t2_t3} : False = isRedex t
                                            in contra (trans v1 p)
                                  |True ->
                                     case isValue t2 {val_t2} val_t2_term of
                                       False ->
                                         let v1 [v1_eq] =
                                               morejoin {u3, t_term, sym val_t1,sym val_t2,
                                                 val_t1_term,val_t2_term,val_t3_term,val_and_t2_t3} : False = isRedex t
                                         in contra (trans v1 p)
                                      |True ->
                                        (case isValue t3 {val_t3} val_t3_term of
                                          False ->
                                             let v1 [v1_eq] =
                                               morejoin {u3, t_term, sym val_t1,sym val_t2,sym val_t3,
                                                 val_t1_term,val_t2_term,val_t3_term,val_and_t2_t3} : isValue t3 = isRedex t
                                             in contra trans (trans val_t3 v1) p
                                         |True ->
                                           pack (RedexS [t] [t3] [t2] [t1] [u3] [sym val_t3] [sym val_t2] [sym val_t1]),
                                            (valax (RedexS [t] [t3] [t2] [t1] [u3] [sym val_t3] [sym val_t2] [sym val_t1]))
                                         )
                                  )
                              
                            | App f3 t4 -> 
                               let u1 [u1_eq] = morejoin {sym t_eq,t_term, sym f1_eq,sym f2_eq, sym f3_eq} : False = isRedex t
                               in contra (trans u1 p)
                              

-- | Decompose a term into an evaluation context and a focus term     
Recursive decompose : (t:Term) -> Decomp  :=
  case isRedex t {redex_t} of
      True -> Dec Box t
    | False -> (case t {e_eq} of
                  K -> Dec Box t
                | S -> Dec Box t
                | App x y -> (case isValue x {x_val} of
                                True -> (case decompose y {y_eq} of
                                          Dec c' t' -> Dec (C2 x [sym x_val] c') t')
                               | False -> (case decompose x {x_eq} of
                                          Dec c' t' -> Dec (C1 c' y) t')))

Program step : (t:Term) -> Maybe Term :=
  case t {t_eq} of
      K -> Nothing [Term] -- K is normal form
    | S -> Nothing [Term] -- S is normal form
    | App t1 a1 ->
      case isValue a1 {val_a1} of
          False -> Nothing [Term]
        | True -> (case t1 {t1_eq} of
                       K -> Nothing [Term] -- K t2 is a value
                     | S -> Nothing [Term] -- S t2 is a value
                     | App t2 a2 ->
                        (case isValue a2 {val_a2} of
                            False -> Nothing [Term]
                          | True ->                         
                              (case t2 {t2_eq} of
                                   K -> Just [Term] a2 -- K a2 a1 steps to a2
                                 | S -> Nothing [Term] -- S s2 a1 is a value
                                 | App t3 a3 ->
                                   (case isValue a3 {val_a3} of
                                      False -> Nothing [Term]
                                     |True ->
                                       (case t3 {t3_eq} of
                                          K -> Nothing [Term]
                                         |S -> Just [Term] (App (App a3 a1) (App a3 a2))
                                         | App t4 a4  -> Nothing [Term]
                                         )))))

Recursive reduction : (t:Term) -> Term :=
  case decompose t {dec_t} of
    Dec c t' -> case isRedex t' {red_t'} of
                  True -> (case step t' {step_eq} of
                            Nothing -> t -- Not possible.
                           |Just t2 ->  reduction (plug c t2))
                 |False -> plug c t'

                                         
data Step : (t1:Term) (t2:Term) -> Type where
   StepK : (v2:Term) ->
           [val1:isValue t2 = True] -> [val2:isValue v2 = True] -> [idx1:t1 = App (App K t2) v2] ->
           Step t1 t2

 | StepS : (v1:Term) -> (v2:Term) -> (v3:Term) ->
            [val1:isValue v1 = True] -> [val2:isValue v2 = True] -> [val3:isValue v3 = True] ->
            [idx1:t1=App (App (App S v1) v2) v3] -> [idx2:t2 = App (App v1 v2) (App v2 v3)] ->
            Step t1 t2


data StepStar : (t1:Term) (t2:Term) -> Type where
     StepBase : StepStar t1 t2
   | StepTrans : (t1':Term) -> [p1:Step t1 t1'] -> [p2:Step t1' t2] -> StepStar t1 t2


Recursive s_free : (t:Term) -> Bool :=
  case t {t_eq} of
      K -> True
    | S -> False
    | App t1 t2 -> s_free t1 && s_free t2


axiom app_left_monotonic : forall(t1:Term)(t2:Term)(t3:Term)(p:t1 < t2).App t1 t3 < App t2 t3
axiom app_right_monotonic : forall(t1:Term)(t2:Term)(t3:Term)(p:t1 < t2).App t3 t1 < App t3 t2

Inductive plug_preserves_ord : forall(t1:Term)(t1_term:t1!)(t2:Term)(t2_term:t2!)(p:t1 < t2)(c:Ctx){c_term}.
   plug c t1 < plug c t2 :=
     case c {c_eq} c_term of
       Box -> let u1 [u1_eq] = morejoin {sym c_eq, c_term, t1_term} : t1 = plug c t1;
                  u2 [u2_eq] = morejoin {sym c_eq, c_term, t2_term} : t2 = plug c t2
               in conv p at ~u1 < ~u2
      |C1 c' t' -> let u1 [u1_eq] = plug_preserves_ord t1 t1_term t2 t2_term p c' (ord c_eq);
                       u2 [u2_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App (plug c' t1) t';
                       u3 [u3_eq] = morejoin {sym c_eq,t2_term,c_term} : (plug c t2) = App (plug c' t2) t';
                       -- Can't directly use the next two lemmas...
                       o1 [o1_eq] = ord (sym u2) : plug c' t1 < plug c t1;
                       o2 [o2_eq] = ord (sym u3) : plug c' t2 < plug c t2;
                       --
                       u4 [u4_eq] = app_left_monotonic (plug c' t1) (plug c' t2) t' u1
                   in conv u4 at ~(sym u2) < ~(sym u3)
      |C2 t' [q] c' -> 
                   let u1 [u1_eq] = plug_preserves_ord t1 t1_term t2 t2_term p c' (ord c_eq);
                       u2 [u2_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App t' (plug c' t1);
                       u3 [u3_eq] = morejoin {sym c_eq,t2_term,c_term} : (plug c t2) = App t' (plug c' t2);
                       -- Can't directly use the next two lemmas...
                       o1 [o1_eq] = ord (sym u2) : plug c' t1 < plug c t1;
                       o2 [o2_eq] = ord (sym u3) : plug c' t2 < plug c t2;
                       --
                       u4 [u4_eq] = app_right_monotonic (plug c' t1) (plug c' t2) t' u1
                   in conv u4 at ~(sym u2) < ~(sym u3)


Inductive plug_terminates : forall (t1:Term)(t1_term:t1!)(c:Ctx){c_term}.plug c t1 ! :=
  case c {c_eq} c_term of
    Box -> let u1 [u1_eq] = morejoin {t1_term,sym c_eq,c_term} : t1 = plug c t1
           in conv t1_term at ~u1!
  | C1 c' t' -> let ih [ih_eq] = plug_terminates t1 t1_term c' (ord c_eq);
                    u1 [u1_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App (plug c' t1) t'
                in conv value (App ~ih t') at ~(sym u1)!
  | C2 t' [q] c' -> let ih [ih_eq] = plug_terminates t1 t1_term c' (ord c_eq);
                      u1 [u1_eq] = morejoin {sym c_eq,t1_term,c_term} : (plug c t1) = App t' (plug c' t1)
                in conv value (App t' ~ih) at ~(sym u1)!

Inductive isRedex_terminates : forall (t:Term){t_term}.isRedex t ! :=
  case t {t_eq} t_term of
      K -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
           in conv valax False at ~u1!
    | S -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : False = isRedex t
           in conv valax False at ~u1!
    | App f1 t1 ->
       case f1 {f1_eq} valax f1 of
           K -> 
             let u1 [u1_eq] = morejoin {sym t_eq,sym f1_eq,t_term,valax f1} : False = isRedex t
             in conv valax False at ~u1!
         | S -> 
              let u1 [u1_eq] = morejoin {sym t_eq,sym f1_eq,t_term,valax f1} : False = isRedex t
              in conv valax False at ~u1!
         | App f2 t2 -> case f2 {f2_eq} valax f2 of
                           K -> let u1 [u1_eq] =  
                                      morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2} :
                                        (isValue t1 && isValue t2) = isRedex t;
                                    u2 [u2_eq] = and_term (isValue t1) (isValue t2)
                                                  (isValue_term t1 (valax t1)) (isValue_term t2 (valax t2))
                                in conv u2 at ~u1!
                         | S -> 
                            let u1 [u1_eq] =  
                                  morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2} :
                                   False = isRedex t
                            in conv valax False at ~u1!                                
                         | App f3 t3 ->
                            case f3 {f3_eq} valax f3 of
                              K -> 
                                let u1 [u1_eq] =  
                                  morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2, sym f3_eq, valax f3} :
                                   False = isRedex t
                                in conv valax False at ~u1!
                              | App f3 t4 -> 
                                let u1 [u1_eq] =  
                                  morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2, sym f3_eq, valax f3} :
                                   False = isRedex t
                                in conv valax False at ~u1!                                
                              | S ->
                                 let u1 [u1_eq] =  
                                      morejoin {sym t_eq,sym f1_eq,t_term,valax f1,sym f2_eq, valax f2, sym f3_eq, valax f3} :                                      
                                        (isValue t1 && isValue t2 && isValue t3) = isRedex t;
                                    u2 [u2_eq] = and_term (isValue t2) (isValue t3)
                                                  (isValue_term t2 (valax t2)) (isValue_term t3 (valax t3));
                                    u3 [u3_eq] = and_term (isValue t1) (isValue t2 && isValue t3) (isValue_term t1 (valax t1)) u2
                                in conv u3 at ~u1!

Inductive decompose_terminates : forall(t:Term){t_term}. decompose t ! := 
  case isRedex t {redex_t} isRedex_terminates t t_term of
      True -> let u1 [u1_eq] = morejoin {t_term, sym redex_t} : Dec Box t = decompose t
              in  conv (valax (Dec Box t)) at ~u1 !
    | False -> (case t {e_eq} t_term of
                  K -> let u1 [u1_eq] = morejoin {t_term, sym redex_t, sym e_eq} : Dec Box t = decompose t
                       in  conv (valax (Dec Box t)) at ~u1 !
                | S -> let u1 [u1_eq] = morejoin {t_term, sym redex_t, sym e_eq} : Dec Box t = decompose t
                       in  conv (valax (Dec Box t)) at ~u1 !
                | App x y -> (case isValue x {x_val} isValue_term x (valax x) of
                                True -> let u1 [u1_eq] = ord e_eq : y < t
                                        in  (case decompose y {y_eq} decompose_terminates y u1 of
                                               Dec c' t' ->
                                                 let u1 [u1_eq] =
                                                        morejoin {sym x_val,sym e_eq, sym redex_t, sym y_eq, t_term, valax t'}
                                                        : Dec (C2 x [sym x_val] c') t' = decompose t 
                                                 in conv valax (Dec (C2 x [sym x_val] c') t') at ~u1!)
                               | False -> let u1 [u1_eq] = ord e_eq : x < t
                                          in (case decompose x {x_eq} decompose_terminates x u1 of
                                                Dec c' t' ->
                                                  let u2 [u2_eq] =
                                                    morejoin {sym x_val, sym e_eq, sym redex_t, sym x_eq, t_term, valax t'}
                                                      : Dec (C1 c' y) t' = decompose t
                                                  in conv valax (Dec (C1 c' y) t') at ~u2!)))



axiom plug_decompose_inv : forall (t:Term)(t':Term)(c:Ctx)(p:decompose t = Dec c t').plug c t' = t

Theorem and_right : forall (t1:Bool)(t2:Bool)(p:(t1 && t2) = True).(t2 = True) :=
   termcase t1 {t1_term} of
     abort -> let u1 = morejoin {sym t1_term} : (abort Bool) = ((abort Bool) && t2);
                  u2 = conv u1 at (abort Bool) = (~t1_term && t2)
              in contraabort u2 (conv valax True at ~(sym p) !)
    | ! -> termcase t2 {t2_term} of
             abort ->
               let u1 = morejoin {t1_term, sym t2_term} : (abort Bool) = (t1 && (abort Bool));
                   u2 = conv u1 at (abort Bool) = (t1 && ~t2_term)
               in contraabort u2 (conv valax True at ~(sym p) !)
           | ! -> case t1 {t1_eq} t1_term of
                   True -> let u3 = morejoin {t1_term,t2_term,sym t1_eq}
                                : t2 = (t1 && t2)
                           in trans u3 p
                 | False -> let u3 = morejoin {t1_term,t2_term,sym t1_eq}
                                : False = (t1 && t2)
                            in contra (trans u3 p)

                            
Theorem and_left : forall (t1:Bool)(t2:Bool)(p:(t1 && t2) = True).(t1 = True) :=
   termcase t1 {t1_term} of
     abort -> let u1 = morejoin {sym t1_term} : (abort Bool) = ((abort Bool) && t2);
                  u2 = conv u1 at (abort Bool) = (~t1_term && t2)
              in contraabort u2 (conv valax True at ~(sym p) !)
    | ! -> termcase t2 {t2_term} of
             abort ->
               let u1 = morejoin {t1_term, sym t2_term} : (abort Bool) = (t1 && (abort Bool));
                   u2 = conv u1 at (abort Bool) = (t1 && ~t2_term)
               in contraabort u2 (conv valax True at ~(sym p) !)
           | ! -> case t1 {t1_eq} t1_term of
                   True -> sym t1_eq
                 | False -> let u3 = morejoin {t1_term,t2_term,sym t1_eq}
                                : False = (t1 && t2)
                            in contra (trans u3 p)


Theorem redex_val_left : forall(t1:Term)(t2:Term)(t3:Term)
                    (p:t1=(App (App K t2) t3))(q:isRedex t1 = True).isValue t2 = True :=
    termcase t1 {t1_term} of
      abort -> let u1 = morejoin {sym t1_term} : (abort Term) = (isRedex (abort Term));
                   u2 = conv u1 at (abort Term) = (isRedex ~t1_term);
                   u3 = conv valax True at ~(sym q) !
               in  contraabort u2 u3
    | ! -> let u1 = morejoin {p, t1_term} : isRedex t1 = (isValue t3 && isValue t2);
               u2 = trans (sym q) u1 -- True = isValue t3 && isValue t2 
           in and_right (isValue t3) (isValue t2) (sym u2)


Theorem redex_val_right : forall(t1:Term)(t2:Term)(t3:Term)
                    (p:t1=(App (App K t2) t3))(q:isRedex t1 = True).isValue t3 = True :=
    termcase t1 {t1_term} of
      abort -> let u1 = morejoin {sym t1_term} : (abort Term) = (isRedex (abort Term));
                   u2 = conv u1 at (abort Term) = (isRedex ~t1_term);
                   u3 = conv valax True at ~(sym q) !
               in  contraabort u2 u3
    | ! -> let u1 = morejoin {p, t1_term} : isRedex t1 = (isValue t3 && isValue t2);
               u2 = trans (sym q) u1
           in and_left (isValue t3) (isValue t2) (sym u2)
           

axiom plug_preserves_s_free : forall(t:Term)(t':Term)(t'':Term)(c:Ctx)
                                (p:s_free t = True)(q:decompose t = Dec c t')(q:t'' < t).(s_free t'' = True)

axiom decomp_preserves_s_free : forall(t:Term)(t':Term)(c:Ctx)
                                (p:s_free t = True)(q:decompose t = Dec c t').(s_free t' = True)

                                
axiom s_free_app_1 : forall (t:Term)(t1:Term)(t2:Term)(p:t = App t1 t2)(q:s_free t = True).(s_free t1 = True)

{-
data RedexProp : [t:Term]  -> Type where
  RedexK : [t1:Term] -> [t2:Term] -> [p:t = App (App K t1) t2] -> RedexProp t
 |RedexS : [t1:Term] -> [t2:Term] -> [t3:Term] -> [p:t = App (App (App S t1) t2) t3] -> RedexProp t

Program redexToShape : (t:Term)[t_term:t!][p:isRedex t = True] -> RedexProp t :=
  (case t {t_eq} of
    K -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : isRedex t = False;
             con [con_eq] =  trans (sym p) u1 : True = False
         in contra con
  | S -> let u1 [u1_eq] = morejoin {sym t_eq,t_term} : isRedex t = False;
             con [con_eq] =  trans (sym p) u1 : True = False
         in contra con
  | App t1' t2' -> -- t = App t1' t2'
       (case t1' {t1'_eq} (valax t1') of
         S -> let u1 [u1_eq] = conv t_eq at (App ~(sym t1'_eq) t2') = t;
                  -- App (App S t2') = t
                  u2 [con_eq] = morejoin {t_term,sym u1} : isRedex t = False;
                  con [con_eq] = trans (sym p) u2 : True = False
              in contra con
       | K -> let u1 [u1_eq] = conv t_eq at (App ~(sym t1'_eq) t2') = t;
                  u2 [con_eq] = morejoin {t_term,sym u1} : isRedex t = False;
                  con [con_eq] = trans (sym p) u2 : True = False
              in contra con

       | App t1'' t2'' ->
           (case t1'' {t1''_eq} of
              K -> let u1 [u1_eq] = conv t1'_eq at   App ~(sym t1''_eq) t2'' = t1';
                       u2 [u2_eq] = conv t_eq at App ~(sym u1) t2' = t
                   in RedexK [t] [t2''] [t2'] [sym u2]
            | S -> let u1 [u1_eq] = conv t1'_eq at   App ~(sym t1''_eq) t2'' = t1';
                       u2 [u2_eq] = conv t_eq at App ~(sym u1) t2' = t;
                       u3 [u3_eq] = morejoin {t_term,sym u2} : isRedex t = False;
                       con [con_eq] = trans (sym p) u3 : True = False
                   in contra con
            | App t1''' t2''' ->
               (case t1''' {t1'''_eq} of
                 K -> let u0 [u0_eq] = conv t1''_eq at App ~(sym t1'''_eq) t2''' = t1'';
                          u1 [u1_eq] = conv t1'_eq at   App ~(sym u0) t2'' = t1';
                          u2 [u2_eq] = conv t_eq at App ~(sym u1) t2' = t;
                          u3 [u3_eq] = morejoin {t_term,sym u2} : isRedex t = False;
                         con [con_eq] = trans (sym p) u3 : True = False
                      in contra con
               | S -> let u0 [u0_eq] = conv t1''_eq at App ~(sym t1'''_eq) t2''' = t1'';
                          u1 [u1_eq] = conv t1'_eq at   App ~(sym u0) t2'' = t1';
                          u2 [u2_eq] = conv t_eq at App ~(sym u1) t2' = t
                      in RedexS [t] [t1'''] [t1''] [t1'] [sym u2]
               | App wc wc' ->
                      let u0 [u0_eq] = conv t1''_eq at App ~(sym t1'''_eq) t2''' = t1'';
                          u1 [u1_eq] = conv t1'_eq at   App ~(sym u0) t2'' = t1';
                          u2 [u2_eq] = conv t_eq at App ~(sym u1) t2' = t;
                          u3 [u3_eq] = morejoin {t_term,sym u2} : isRedex t = False;
                          con [con_eq] = trans (sym p) u3 : True = False
                      in contra con))))

axiom redexPropTerm : forall (t:Term)(t_term:t!)(p:RedexProp t).p!
  
-}  


-- axiom decom_ord : forall (t1:Term)(t2:Term)(t':Term)(c:Ctx)(p:decomp )
Inductive s_free_term : forall (t:Term){t_term}(p:s_free t = True).(reduction t) ! :=
  case decompose t {dec_t_eq} (decompose_terminates t t_term) of
    Dec c t' ->
      case isRedex t' {t'_redex} (isRedex_terminates t' (valax t')) of
        False -> let u1 [u1_eq] = morejoin {sym dec_t_eq,t_term,valax c,valax t',sym t'_redex} :
                                    reduction t = plug c t';
                     u2 [u2_eq] = plug_terminates t' (valax t') c (valax c)
                 in  conv u2 at ~(sym u1) !
       |True -> case t' {t'_eq} (valax t') of
                  K -> let u1 [u1_eq] = morejoin {sym t'_eq,valax t'} : isRedex t' = False;
                           con [con_eq] =  trans t'_redex u1 : True = False
                       in contra con
                | S -> let u1 [u1_eq] = morejoin {sym t'_eq,valax t'} : isRedex t' = False;
                           con [con_eq] =  trans t'_redex u1 : True = False
                       in contra con
                 | App t1' t2' ->
                     case t1' {t1'_eq} (valax t1') of
                      S -> let u1 [u1_eq] = conv t'_eq at (App ~(sym t1'_eq) t2') = t';
                               -- App (App S t2') = t
                               u2 [con_eq] = morejoin {valax t',sym u1} :
                                               isRedex t' = False;
                               con [con_eq] = trans t'_redex u2 : True = False
                           in contra con
                    | App t1'' t2'' ->
                       (case t1'' {t1''_eq} (valax t1'') of
                         K -> let u1 [u1_eq] = conv t1'_eq at App ~(sym t1''_eq) t2'' = t1';
                                  u2 [u2_eq] = conv t'_eq at App ~(sym u1) t2' = t';
                                  -- we now have t' = K t2'' t2', which we can reduce.
                                  u3 [u3_eq] =
                                   redex_val_left t' t2'' t2' (sym u2) (sym t'_redex);
                                  u4 [u3_eq] =
                                   redex_val_right t' t2'' t2' (sym u2) (sym t'_redex);
                                  u5 [u3_eq] =
                                    morejoin {valax t',sym t'_eq,valax t1',
                                              sym t1'_eq,
                                              sym t1''_eq,u3,u4} :
                                                 step t' = Just t2'';
                                   u6 [u6_eq] =
                                     morejoin {sym dec_t_eq,t_term,valax t',
                                               sym t'_redex, sym t'_eq, u3,u4,
                                               sym t1'_eq, sym t1''_eq}

                                      : reduction t = reduction (plug c t2'');
                                   u7 [u7_eq] = ord t'_eq : t1' < t';
                                   u8 [u8_eq] = ord t1'_eq : t2'' < t1';
                                   u9 [u9_eq] = ordtrans u8 u7 : t2'' < t';
                                   u10 [u10_eq] =
                                    plug_preserves_ord t2'' (valax t2'') t' (valax t') u9 c (valax c);
                                   u11 [u11_eq] = plug_decompose_inv t t' c (sym dec_t_eq);
                                   u12 [u12_eq] = conv u10 at plug c t2'' < ~u11;
                                   -- Get a proof that plug c t2'' is s_free
                                   u13 [u13_eq] = plug_preserves_s_free t t' (plug c t2'') c p (sym dec_t_eq) u12;
                                   -- Apply the induction hypothesis
                                   u14 [u14_eq] = s_free_term (plug c t2'') u12 u13
                                                 
                               in conv u14 at ~(sym u6) !
                        |S -> let u1 [u1_eq] = conv t1'_eq at App ~(sym t1''_eq) t2'' = t1';
                                  u2 [u2_eq] = conv t'_eq at App ~(sym u1) t2' = t';
                                  s_free_t' [dummy] =
                                    decomp_preserves_s_free t t' c p (sym dec_t_eq);
                                  s_free_t1' [u3_eq] = s_free_app_1 t' t1' t2' (sym t'_eq) s_free_t';
                                       -- s_free t1' = True
                                  s_free_t1'' [u4_eq] = s_free_app_1 t1' t1'' t2'' (sym t1'_eq) s_free_t1';
                                  u3 [u3_eq] = morejoin {valax t1'', sym t1''_eq} : s_free t1'' = False;
                                  con [u4_eq] = trans (sym s_free_t1'') u3
                              in contra con
                       |App t1''' t2''' ->
                           case t1''' {t1'''_eq} (valax t1''') of
                              K -> -- Not a redex
                                let u1 [u1_eq] =
                                       morejoin {valax t', sym t'_eq, sym t1'_eq, sym t1''_eq, sym t1'''_eq} 
                                      : isRedex t' = False;
                                    con [con_eq] = trans (t'_redex) u1
                                 in contra con
                             |App adf sfs -> -- Not a redex
                                 let u1 [u1_eq] =
                                       morejoin {valax t', sym t'_eq, sym t1'_eq, sym t1''_eq, sym t1'''_eq} 
                                      : isRedex t' = False;
                                     con [con_eq] = trans (t'_redex) u1
                                 in contra con

                             |S -> -- Not s_free
                                let t'_s_free [a] = decomp_preserves_s_free t t' c p (sym dec_t_eq);
                                    t1'_s_free [a] = s_free_app_1 t' t1' t2' (sym t'_eq) t'_s_free;
                                    t1''_s_free [a] = s_free_app_1 t1' t1'' t2'' (sym t1'_eq) t1'_s_free;
                                    t1'''_s_free [a] = s_free_app_1 t1'' t1''' t2''' (sym t1''_eq) t1''_s_free;
                                    u1 [a] = morejoin {valax t1''', sym t1'''_eq} : s_free t1''' = False;
                                    con [a] = trans (sym u1) t1'''_s_free
                                in contra con)

                       
                    | K -> -- Not a redex
                       let u1 [u1_eq] =
                             morejoin {valax t', sym t'_eq, sym t1'_eq} 
                               : isRedex t' = False;
                             con [con_eq] = trans (t'_redex) u1
                       in  contra con

data Nat : Type where
    Z : Nat
  | S : Nat -> Nat


data Parity : Type where
    E : Parity
  | O : Parity

Program flip : (p:Parity) -> Parity :=  
  case p {p_eq} of
      E -> O
    | O -> E

Theorem flip_term : forall (p:Parity)(p_term:p!).flip p ! :=
  case p {p_eq} p_term of
    E -> let u1 = morejoin {sym p_eq, p_term} : O = flip p
         in conv valax O at ~u1!
   |O -> let u1 = morejoin {sym p_eq, p_term} : E = flip p
         in conv valax E at ~u1!

Recursive evenOdd : (p:Parity)(n:Nat) -> Bool :=
  case p {p_eq} of
    E -> (case n {n_eq} of
            Z -> True
           |S n' -> evenOdd (flip p) n')
  | O -> (case n {n_eq} of
            Z -> False
           |S n' -> evenOdd (flip p) n')

Recursive evenOdd : (p:Parity)(n:Nat) -> Bool :=
     case n {n_eq} of
            Z -> (case p {p_eq} of
                    E ->  True
                  | O -> False)
           |S n' -> evenOdd (flip p) n'

           
Inductive evenOdd_term : forall (p:Parity)(p_term:p!)(n:Nat){n_term}.evenOdd p n ! :=
  case p {p_eq} p_term of
    E -> (case n {n_eq} n_term of
            Z -> let u1 = morejoin {sym p_eq, p_term, sym n_eq, n_term} : True = evenOdd p n
                 in conv valax True at ~u1!
           |S n' -> let flip_p_term = flip_term p p_term;
                        u2 = morejoin {sym p_eq,sym n_eq, p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
                        ih = evenOdd_term (flip p) (flip_p_term) n' (ord n_eq)
                    in conv ih at ~(sym u2) !)


   |O -> (case n {n_eq} n_term of
            Z -> let u1 = morejoin {sym p_eq, p_term, sym n_eq, n_term} : False = evenOdd p n
                 in conv valax False at ~u1!
           |S n' -> let flip_p_term = flip_term p p_term;
                        u2 = morejoin {sym p_eq,sym n_eq, p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
                        ih = evenOdd_term (flip p) (flip_p_term) n' (ord n_eq)
                    in conv ih at ~(sym u2) !)
                    

-- Inductive even_odd_opposite : forall (n:Nat){n_term}(p:Parity)(q:evenOdd p n = True).evenOdd (flip p) n = False :=
--   termcase p {p_term} of
--     abort -> let u1 = join 0 10 : (abort Bool) = (evenOdd (abort Parity) n);
--                  u2 = conv u1 at  (abort Bool) = (evenOdd ~p_term n);
--                  u3 = conv valax True at ~(sym q) !
--              in contraabort u2 u3
--    | ! -> case n {n_eq} n_term of
--             Z -> (case p {p_eq} p_term of
--                     E -> morejoin {p_term,n_term,sym p_eq, sym n_eq} --  : evenOdd (flip p) n = False
--                   | O -> let u1 = morejoin {p_term,n_term,sym p_eq, sym n_eq} : False = evenOdd p n
--                          in contra (trans u1 q))
--           | S n' -> let u1 = morejoin {sym n_eq,p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
--                         u2 = trans (sym u1) q; -- evenOdd (flip p) n' = True
--                         ih = even_odd_opposite n' (ord n_eq) (flip p) u2 : evenOdd (flip (flip p)) n' = False;
--                         evenOddn = morejoin {p_term,n_term,sym n_eq,(flip_term p p_term)} : evenOdd (flip p) n = evenOdd (flip (flip p)) n'
--                     in trans evenOddn ih


Inductive even_odd_opposite : forall (n:Nat){n_term}(p:Parity)(b:Bool)(b_term:b!)(q:evenOdd p n = b).evenOdd (flip p) n = (not b) :=
  termcase p {p_term} of
    abort -> let u1 = join 0 10 : (abort Bool) = (evenOdd (abort Parity) n);
                 u2 = conv u1 at  (abort Bool) = (evenOdd ~p_term n);
                 u3 = conv b_term at ~(sym q) !
             in contraabort u2 u3
   | ! -> case n {n_eq} n_term of
            Z -> (case p {p_eq} p_term of
                    E -> (case b {b_eq} b_term of
                           True -> morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term} --  : evenOdd (flip p) n = False
                          |False ->
                            let u1 = morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term}
                                       : True = evenOdd p n
                            in contra (conv (trans u1 q) at True = ~(sym b_eq)))
                  | O -> (case b {b_eq} b_term of
                           True ->
                            let u1 = morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term}
                                     : False = evenOdd p n
                            in contra (conv (trans u1 q) at False = ~(sym b_eq))
                          | False -> morejoin {p_term,n_term,sym p_eq, sym n_eq, sym b_eq, b_term})
                         )
          | S n' -> let u1 = morejoin {sym n_eq,p_term,n_term} : evenOdd p n = evenOdd (flip p) n';
                        u2 = trans (sym u1) q; -- evenOdd (flip p) n' = True
                        ih = even_odd_opposite n' (ord n_eq) (flip p) b b_term u2 : evenOdd (flip (flip p)) n' = (not b);
                        evenOddn = morejoin {p_term,n_term,sym n_eq,(flip_term p p_term)} : evenOdd (flip p) n = evenOdd (flip (flip p)) n'
                    in trans evenOddn ih

                    
Program even : (n:Nat) -> Bool := evenOdd E n
Program odd : (n:Nat) -> Bool := evenOdd O n

Theorem even_term : forall (n:Nat)(n_term:n!).even n ! :=
  let u1 = evenOdd_term E (valax E) n n_term;
      u2 = morejoin {n_term} : evenOdd E n = even n
  in conv u1 at ~u2!

Theorem odd_term : forall (n:Nat)(n_term:n!).odd n ! :=
  let u1 = evenOdd_term O (valax O) n n_term;
      u2 = morejoin {n_term} : evenOdd O n = odd n
  in conv u1 at ~u2!
  
  
Theorem pred_even_odd : forall(n:Nat)(n':Nat)(p:n = S n')(q:even n = True).odd n' = True :=
  termcase n {n_term} of
     abort -> let even_abort = morejoin {sym n_term} : (abort Nat) = (even (abort Nat));
                  even_abort_n = conv even_abort at (abort Nat) = (even ~n_term);
                  even_term = conv valax True at ~(sym q) !
              in contraabort even_abort_n even_term
   | ! -> termcase n' {n'_term} of
            abort -> let u1 = join 100 100 : (abort Nat) = (S (abort Nat));
                         u2 = conv u1 at (abort Nat) = (S ~n'_term);
                         u3 = trans u2 (sym p)
                     in contraabort u3 n_term
          | ! -> let u1 = morejoin {p, n_term, n'_term} :  odd n' = even n
                 in trans u1 q

-- axiom pred_odd_even : forall(n:Nat)(n':Nat)(p:n = S n')(q:even n = False).even n' = True
Theorem pred_odd_even : forall(n:Nat)(n':Nat)(p:n = S n')(q:odd n = True).even n' = True :=
  termcase n {n_term} of
     abort -> let odd_abort = morejoin {sym n_term} : (abort Nat) = (odd (abort Nat));
                  odd_abort_n = conv odd_abort at (abort Nat) = (odd ~n_term);
                  odd_term = conv valax True at ~(sym q) !
              in contraabort odd_abort_n odd_term
   | ! -> termcase n' {n'_term} of
            abort -> let u1 = join 100 100 : (abort Nat) = (S (abort Nat));
                         u2 = conv u1 at (abort Nat) = (S ~n'_term);
                         u3 = trans u2 (sym p)
                     in contraabort u3 n_term
          | ! -> let u1 = morejoin {p, n_term, n'_term} :  even n' = odd n
                 in trans u1 q

Theorem even_implies_not_odd : forall (n:Nat)(n_term:n!)(b:Bool)(b_term:b!)(p:even n = b). odd n = (not b) :=
          let u1 = morejoin {n_term} : evenOdd E n = even n;
              u2 = morejoin {n_term} : odd n = evenOdd (flip E) n;
              u3 = even_odd_opposite n n_term E b b_term (trans u1 p)
          in trans u2 u3
   
Theorem even_true_odd_false : forall (n:Nat)(p:even n = True). odd n = False :=
  termcase n {n_term} of
     abort -> let even_abort = morejoin {sym n_term} : (abort Nat) = (even (abort Nat));
                  even_abort_n = conv even_abort at (abort Nat) = (even ~n_term);
                  even_term = conv valax True at ~(sym p) !
              in contraabort even_abort_n even_term
   | ! -> let u1 = even_implies_not_odd n n_term True (valax True) p
          in conv u1 at odd n = ~(join 100 100  : not True = False)

Theorem even_false_odd_true : forall (n:Nat)(p:even n = False). odd n = True :=
  termcase n {n_term} of
     abort -> let even_abort = morejoin {sym n_term} : (abort Nat) = (even (abort Nat));
                  even_abort_n = conv even_abort at (abort Nat) = (even ~n_term);
                  even_term = conv valax False at ~(sym p) !
              in contraabort even_abort_n even_term
   | ! -> let u1 = even_implies_not_odd n n_term False (valax False) p
          in conv u1 at odd n = ~(join 100 100  : not False = True)


          
-- Not even used
Theorem odd_implies_not_even : forall (n:Nat)(p:odd n = True). even n = False :=
  termcase n {n_term} of
     abort -> let odd_abort = morejoin {sym n_term} : (abort Nat) = (odd (abort Nat));
                  odd_abort_n = conv odd_abort at (abort Nat) = (odd ~n_term);
                  odd_term = conv valax True at ~(sym p) !
              in contraabort odd_abort_n odd_term
   | ! -> let u1 = morejoin {n_term} : evenOdd O n = odd n;
              u2 = morejoin {n_term} : even n = evenOdd (flip O) n;
              u3 = even_odd_opposite n n_term O True (valax True) (trans u1 p);
              u4 = trans u2 u3
          in conv u4 at even n = ~(join 100 100  : not True = False)


Recursive ks : (n:Nat) -> Term :=
  case n {n_eq} of
     Z -> K
    |S n' -> App (ks n') K


data ThmPair : [n:Nat] -> Type where
  ThmPf : [p1:(forall (p:even n = True).(reduction (ks n) = K))] ->
          [p2:(forall (p:odd n = True).(reduction (ks n) = App K K))] ->
            ThmPair n

axiom red_cong : forall (t:Term)(t':Term)(tn:Term)(p:reduction t = t').
    reduction (App t tn) = reduction (App t' tn)
    
Inductive ks_thm : forall(n:Nat){n_term}.exists (x:ThmPair n).x! :=
   case n {n_eq} n_term of
     Z -> let even_n [u1_eq] = morejoin {sym n_eq,n_term} : even n = True;
              ks_z [ks_z_eq] = morejoin {sym n_eq,n_term} : reduction (ks n) = K
          in (pack (ThmPf [n] [\ (p':even n = True) => ks_z]
                         [\ (p':odd n = True) => contra (trans (sym (even_true_odd_false n even_n)) p')]),
                  (valax
                    (ThmPf [n] [\ (p':even n = True) => ks_z]
                           [\ (p':odd n = True) => contra (trans (sym (even_true_odd_false n even_n)) p')])))
    |S n' -> let u1 [u1_eq] = ks_thm n' (ord n_eq)
             in unpack u1 as (pf, pf_term) in
                  case pf {pf_eq} pf_term of
                    ThmPf [p1] [p2]  ->
                      case even n {even_n} even_term n n_term of
                         True -> let u1 [u1_eq] = p2 (pred_even_odd n n' (sym n_eq) (sym even_n));
                                          -- reduction (ks n') = App K K
                                     u2 [u2_eq] = morejoin {n_term, valax n', sym n_eq} :
                                                    ks n = App (ks n') K;
                                     u3 [u3_eq] = red_cong (ks n') (App K K) K u1;
                                     u4 [u4_eq] = join 100 0 :
                                       reduction (App (App K K) K) = K;
                                     u5 [u5_eq] = trans u3 u4;
                                     u6 [u6_eq] = conv u5 at reduction ~(sym u2) = K
                                     -- TODO: Need to handle packing
                                 in pack
                                     (ThmPf [n]
                                      [\(p:even n = True) => u6]
                                      [\(q:odd n = True) =>
                                         let v1 [v1_eq] = sym (even_true_odd_false n (sym even_n))
                                         in contra (trans v1 q)
                                      ]),
                                      (valax (ThmPf [n]
                                            [\(p:even n = True) => u6]
                                            [\(q:odd n = True) =>
                                              let v1 [v1_eq] = sym (even_true_odd_false n (sym even_n))
                                              in contra (trans v1 q)
                                            ]))

                        |False -> let odd_true = even_false_odd_true n (sym even_n);
                                      u1 [u1_eq] = p1 (pred_odd_even n n' (sym n_eq) odd_true);
                                          -- reduction (ks n') = K
                                      u2 [u2_eq] = morejoin {n_term, valax n', sym n_eq} :
                                                    ks n = App (ks n') K;
                                      u3 [u3_eq] = red_cong (ks n') K K u1;
                                      u4 [u4_eq] = join 100 0 :
                                       reduction (App K K) = App K K;
                                      u5 [u5_eq] = trans u3 u4;
                                      u6 [u6_eq] = conv u5 at reduction ~(sym u2) = App K K
                                  in 

                                  pack
                                     (ThmPf [n]
                                      [\(q:even n = True) =>
                                          contra (trans even_n q)
                                      ])
                                      [\(p:odd n = True) => u6]
                                      ,
                                      (valax
                                     (ThmPf [n]
                                      [\ (q:even n = True) =>
                                          contra (trans even_n q)
                                      ]
                                      [\ (p:odd n = True) => u6]
                                      ))

              



   
