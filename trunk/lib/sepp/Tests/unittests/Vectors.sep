module Vectors where

data Nat : Type where
  Z : Nat
| S : Nat -> Nat

data List : (a:Type) -> Type where
   Nil : List a
 | Cons : (x:a) -> (xs:List a) -> List a

data Vec : (a:Type)(n:Nat) -> Type where
   VNil : [p:n=Z] -> Vec a n
 | VCons : (size:Nat) -> [p:n = S size] ->
           (x:a) -> (xs:Vec a size) -> Vec a n

type plus : (x:Nat) -> (y:Nat) -> Nat
prog rec plus (x:Nat) = \(y:Nat) ->
    case x {x_eq} of
      Z -> y
    | S x' -> S (plus x' y)

type append : (b:Type) -> (l1:List b) -> (l2:List b)  -> List b
prog append = \(b:Type) ->
  rec app (l1:List b) . \ (l2:List b) ->
    case l1 {l1_eq} of
       Nil -> l2
     | Cons x xs -> Cons b x (app xs l2)

data Unit : Type where Unit : Unit
-- axiom undefined : (x:Type) -> x

-- termcase syntax has all virtcal bars but case doesn't need for the first

theorem append_assoc : forall (a:Type) (l1:List a) (l2:List a) (l3:List a) .
                   append a l1 (append a l2 l3) = append a (append a l1 l2) l3
proof append_assoc = \(a:Type) (l1:List a) (l2:List a) (l3:List a) =>
  termcase l1 {l1term} of
    | abort -> -- l1term : l1 = abort
               let p1 [tmp1] = aborts (append a ~l1term (append a l2 l3))
                   p2 [tmp2] = aborts (append a (append a ~l1term l2) l3)
               in Unit
    | !     -> Unit



type reverse : (a:Type) -> (l:List a) -> List a
prog reverse = \ (a:Type) ->
   rec rev (l:List a) .
     case l { l_eq } of
       Nil -> Nil a
     | Cons x xs -> append a (rev xs) (Cons a x (Nil a))

type vcopy : (a:Type) -> (n:Nat) -> (l:Vec a n) -> (Vec a n)
prog rec vcopy (a:Type) (n:Nat) (l:Vec a n) =
  case l {l_eq} of
     VNil p -> VNil a n [p]
   | VCons size p x xs -> VCons a n size [p] x (vcopy a size xs)

type vapp : (a:Type) -> (m:Nat) -> (n:Nat) -> (v1:Vec a m) ->
     (v2:Vec a n) -> Vec a (plus m n)
prog rec vapp (a:Type) (m:Nat) (n:Nat)(v1:Vec a m)(v2:Vec a n) =
  case v1 {v1_eq} of
    VNil p ->  conv v2 at Vec a ~(morejoin {p} :  (n = plus m n))
  | VCons pred p x xs -> VCons a (plus m n) (plus pred n)
                            [(morejoin {p} : plus m n = S (plus pred n))]
                            x (vapp a pred n xs v2)

