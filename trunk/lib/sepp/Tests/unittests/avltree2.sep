module Avltree where

data Nat : Type where
  Z : Nat
| S : Nat -> Nat

data Bool : Type where
 True : Bool
| False : Bool


Program pred : (a:Nat) -> Nat := 
 case a {a_eq} of
     Z -> Z
   | S n -> n


Recursive eq : (a:Nat)(b:Nat) -> Bool :=
 case a {a_eq} of
      Z -> (case b {b_eq} of
                Z -> True
              | S q -> False)
    | S p -> (case b {b_eq} of
                Z -> False
              | S q -> eq p q)


infixr 5 >=

Recursive (>=) : (a:Nat)(b:Nat) -> Bool :=
  case a {a_eq}  of
    Z -> (case b {b_eq} of
              Z -> True
             | S b' -> False)
   |S a' -> case b {b_eq} of
              Z -> True
             |S b' -> a' >= b'

data Balance : (hL:Nat) (hR:Nat) (hMax:Nat) -> Type where
   Less : [u:hR = (S hL)] -> [v:hMax = hR] -> Balance hL hR hMax
 | Same : [u:hR = hL] -> [v:hMax = hR] -> Balance hL hR hMax
 | More : [u:hL = (S hR)] -> [v:hMax = hL] -> Balance hL hR hMax


data Avl : (h:Nat) -> Type where
  Leaf :[u:h = Z] -> Avl h
| Node : (hL:Nat)-> (hR:Nat)->(hMax:Nat)->(b:Balance hL hR hMax)
         -> [p : h = (S hMax)]-> (trl : Avl hL)
         -> (trr: Avl hR) -> (d:Nat) 
         -> Avl h

data Or : (a : Type) (b : Type) -> Type where
  Left : (x : a) -> Or a b
| Right : (x : b) -> Or a b




-- Program rotateLeft  conv (join 1 1: pred tr1_hR = pred tr1_hR) by p'' at x.(pred tr1_hR = pred x)

Program rotateRight : (y: Nat) (n : Nat) (tr1: Avl (S (S n)))(tr2: Avl n) -> (Or (Avl (S (S n))) (Avl (S (S (S n)))) ) := 
 case tr1 {tr1_eq} of
    Leaf [p] -> abort (Or (Avl (S (S n))) (Avl (S (S (S n)))))
  | Node tr1_hL tr1_hR tr1_hMax tr1_bal [p] tr1_l tr1_r a -> case tr1_bal {tr1_bal_eq} of 
                                                                   Less [u] [v] -> (case tr1_r {tr1_r} of
                                                                                        Leaf [p'] ->  abort (Or (Avl (S (S n))) (Avl (S (S (S n)))))
                                                                                      | Node tr1_r_hL tr1_r_hR tr1__r_hMax tr1_r_bal [p''] tr1_r_l tr1_r_r b -> 
                                                                                        (case tr1_r_bal {tr1_r_bal} of
                                                                                                Same [r] [s] -> 
Left (Avl (S (S n))) (Avl (S (S (S n))))
(Node (S (S n)) (S tr1_hL) (S tr1_hL) (S tr1_hL) (Same (S tr1_hL) (S tr1_hL) (S tr1_hL) [join 1 1] [join 1 1]) 
[conv (conv p by v at x.(S (S n) = S x)) by u at x.(S (S n) = S x)] 
(Node (S tr1_hL) tr1_hL tr1_hL tr1_hL (Same tr1_hL tr1_hL tr1_hL [join 1 1][join 1 1]) [join 1 1] tr1_l 
(conv tr1_r_l by (conv (conv (join 100 100 : tr1_r_hL = pred (S tr1_r_hL)) by (conv (sym (conv (conv (conv (join 1 1: pred tr1_hR = pred tr1_hR) by p'' at x.(pred tr1_hR = pred x)) by s at x.(pred tr1_hR = pred (S x))) by r at x.(pred tr1_hR = pred (S x)))) by u at x.(pred (S tr1_r_hL) = pred x)) at x.(tr1_r_hL = x)) by (join 100 100: pred (S tr1_hL) = tr1_hL) at x.(tr1_r_hL = x) ) at x.(Avl x)) a)
(Node (S tr1_hL) tr1_hL tr1_hL tr1_hL (Same (S tr1_hL) tr1_hL tr1_hL tr1_hL [join 1 1] [join 1 1]) [join 1 1] tr1_r_r tr2 y) 
b)
                                                                                              | Less [r] [s] -> abort (Or (Avl (S (S n))) (Avl (S (S (S n)))))
                                                                                              | More [r] [s] -> abort (Or (Avl (S (S n))) (Avl (S (S (S n)))))

                                                                                         ))
                                                                 | Same [u] [v] -> abort (Or (Avl (S (S n))) (Avl (S (S (S n))))) 
                                                                 | More [u] [v] -> abort (Or (Avl (S (S n))) (Avl (S (S (S n))))) 













Recursive insert : (x : Nat)(n:Nat)(tr : Avl n) -> (Or (Avl n)(Avl (S n))) :=
  case tr {tr_eq} of
       Leaf [p]->
       conv Right (Avl Z) (Avl (S Z)) (Node (S Z) Z Z Z (Same Z Z Z [join 10 10] [join 10 10]) [join 10 10] (Leaf Z [join 10 10]) (Leaf Z [join 10 10]) x) by sym p at x.(Or (Avl x)(Avl (S x)))
     | Node hL hR hMax bal [p] trl trr y ->
              case (eq x y) {eeq} of
                    True -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl trr y)
                  | False -> case (x >= y) {eeeq} of
                                  False -> (case (insert x hL trl) {ins_eq} of
                                                       Left a -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] a trr y)
                                                     | Right b -> case bal {bal_eq} of
                                                                             Same [u] [v] -> 
Right (Avl n)(Avl (S n)) (Node (S n) (S hL) hR (S hL) (More (S hL) hR (S hL) [conv (join 1 1: S hL = S hL) by (sym u) at x.(S hL = S x)][join 10 10]) [ conv (conv (conv (join 1 1: S n = S n) by p at x.(S n = S x)) by v at x.(S n = S (S x))) by u at x.(S n = S (S x))] b trr y) 
                                                                          |  Less [u] [v] ->
Left (Avl n)(Avl (S n)) (Node  n (S hL) hR hR (Same (S hL) hR hR [u][join 10 10]) [conv p by v at x.(n = S x)]  b trr y) 
                                                                          |  More [u] [v] -> rotateRight y hR b trr)
                                 |  True -> (case (insert x hR trr) {ins_eq} of
                                                  Left a -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl a y)
                                                | Right b -> case bal {bal_eq} of
                                                                  Same [u] [v] -> 
Right (Avl n)(Avl (S n)) (Node (S n) hL (S hR) (S hR) (Less hL (S hR) (S hR) [conv (join 1 1: S hR = S hR) by u at x.(S hR = S x)][join 10 10]) [conv (conv (join 1 1: S n = S n) by p at x.(S n = S x)) by v at x.(S n = S (S x)) ] trl b y) 
                                                                | More [u] [v] ->
Left (Avl n)(Avl (S n)) (Node  n hL (S hR) (S hR) (Same hL (S hR) (S hR) [sym u][join 10 10]) [conv (conv p by v at x. (n = S x)) by u at x.(n = S x)] trl b y)
 
                                                                |  Less [u] [v]  -> rotateLeft trl y b )
                                                                    

