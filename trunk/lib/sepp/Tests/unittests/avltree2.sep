module Avltree where

data Nat : Type where
  Z : Nat
| S : Nat -> Nat

data Bool : Type where
 True : Bool
| False : Bool

{-
Program pred : (a:Nat) -> Nat := 
 case a {a_eq} of
     Z -> Z
   | S n -> n
-}

Recursive eq : (a:Nat)(b:Nat) -> Bool :=
 case a {a_eq} of
      Z -> (case b {b_eq} of
                Z -> True
              | S q -> False)
    | S p -> (case b {b_eq} of
                Z -> False
              | S q -> eq p q)


infixr 5 >=

Recursive (>=) : (a:Nat)(b:Nat) -> Bool :=
  case a {a_eq}  of
    Z -> (case b {b_eq} of
              Z -> True
             | S b' -> False)
   |S a' -> case b {b_eq} of
              Z -> True
             |S b' -> a' >= b'

data Balance : (hL:Nat) (hR:Nat) (hMax:Nat) -> Type where
   Less : [u:hR = (S hL)] -> [v:hMax = hR] -> Balance hL hR hMax
 | Same : [u:hR = hL] -> [v:hMax = hR] -> Balance hL hR hMax
 | More : [u:hL = (S hR)] -> [v:hMax = hL] -> Balance hL hR hMax


data Avl : (h:Nat) -> Type where
  Leaf :[u:h = Z] -> Avl h
| Node : (hL:Nat)-> (hR:Nat)->(hMax:Nat)->(b:Balance hL hR hMax)
         -> [p : h = (S hMax)]-> (trl : Avl hL)
         -> (trr: Avl hR) -> (d:Nat) 
         -> Avl h

data Or : (a : Type) (b : Type) -> Type where
  Left : (x : a) -> Or a b
| Right : (x : b) -> Or a b



Program rotateleft : 



Recursive insert : (x : Nat)(n:Nat)(tr : Avl n) -> (Or (Avl n)(Avl (S n))) :=
  case tr {tr_eq} of
       Leaf [p]->
       conv Right (Avl Z) (Avl (S Z)) (Node (S Z) Z Z Z (Same Z Z Z [join 10 10] [join 10 10]) [join 10 10] (Leaf Z [join 10 10]) (Leaf Z [join 10 10]) x) by sym p at x.(Or (Avl x)(Avl (S x)))
     | Node hL hR hMax bal [p] trl trr y ->
              case (eq x y) {eeq} of
                    True -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl trr y)
                  | False -> case (x >= y) {eeeq} of
                                   True -> (case (insert x hR trr) {ins_eq} of
                                                  Left a -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl a y)
                                                | Right b -> case bal {bal_eq} of
                                                                  Same [u] [v] -> 
Right (Avl n)(Avl (S n)) (Node (S n) hL (S hR) (S hR) (Less hL (S hR) (S hR) [morejoin{u}][join 10 10]) [morejoin {p, v}] trl b y) 
                                                                | More [u] [v] ->
Left (Avl n)(Avl (S n)) (Node  n hL (S hR) (S hR) (Same [morejoin{u}][join 10 10]) [morejoin {p,u,v}] trl b y) 
                                                                |  Less [u] [v]  -> rotateleft trl y b )
                                                                    
                                                             |  False -> (case (insert x hR trr) {ins_eq} of
                                                                             Left a -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl a y)
                                                                           | Right b -> case bal {bal_eq} of
                                                                                                 Less hL hR hMax [u] [v]
                                                                                                    -> rotateleft trl y b
                                                                                               |  Same hL hR hMax [u] [v] -> 
Right (Avl n)(Avl (S n)) (Node (S n) hL (S hR) (S hR) (Less [morejoin{u}][join 10 10]) [morejoin {p, v}] trl b y) 
                                                                                               |  More hL hR hMax [u] [v] ->
Left (Avl n)(Avl (S n)) (Node  n hL (S hR) (S hR) (Same [morejoin{u}][join 10 10]) [morejoin {p,u,v}] trl b y) )

