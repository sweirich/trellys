module Avltree where

data Nat : Type where
  Z : Nat
| S : Nat -> Nat

data Bool : Type where
 True : Bool
| False : Bool

{-
Program pred : (a:Nat) -> Nat := 
 case a {a_eq} of
     Z -> Z
   | S n -> n
-}

Recursive eq : (a:Nat)(b:Nat) -> Bool :=
 case a {a_eq} of
      Z -> (case b {b_eq} of
                Z -> True
              | S q -> False)
    | S p -> (case b {b_eq} of
                Z -> False
              | S q -> eq p q)


infixr 5 >=

Recursive (>=) : (a:Nat)(b:Nat) -> Bool :=
  case a {a_eq}  of
    Z -> (case b {b_eq} of
              Z -> True
             | S b' -> False)
   |S a' -> case b {b_eq} of
              Z -> True
             |S b' -> a' >= b'

data Balance : (hL:Nat) (hR:Nat) (hMax:Nat) -> Type where
   Less : [u:hR = (S hL)] -> [v:hMax = hR] -> Balance hL hR hMax
 | Same : [u:hR = hL] -> [v:hMax = hR] -> Balance hL hR hMax
 | More : [u:hL = (S hR)] -> [v:hMax = hL] -> Balance hL hR hMax


data Avl : (h:Nat) -> Type where
  Leaf :[u:h = Z] -> Avl h
| Node : (hL:Nat)-> (hR:Nat)->(hMax:Nat)->(b:Balance hL hR hMax)
         -> [p : h = (S hMax)]-> (trl : Avl hL)
         -> (trr: Avl hR) -> (d:Nat) 
         -> Avl h

data Or : (a : Type) (b : Type) -> Type where
  Left : (x : a) -> Or a b
| Right : (x : b) -> Or a b



-- Program rotateLeft  

-- Program rotateRight

Recursive insert : (x : Nat)(n:Nat)(tr : Avl n) -> (Or (Avl n)(Avl (S n))) :=
  case tr {tr_eq} of
       Leaf [p]->
       conv Right (Avl Z) (Avl (S Z)) (Node (S Z) Z Z Z (Same Z Z Z [join 10 10] [join 10 10]) [join 10 10] (Leaf Z [join 10 10]) (Leaf Z [join 10 10]) x) by sym p at x.(Or (Avl x)(Avl (S x)))
     | Node hL hR hMax bal [p] trl trr y ->
              case (eq x y) {eeq} of
                    True -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl trr y)
                  | False -> case (x >= y) {eeeq} of
                                  False -> (case (insert x hL trl) {ins_eq} of
                                                       Left a -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] a trr y)
                                                     | Right b -> case bal {bal_eq} of
                                                                             Same [u] [v] -> 
Right (Avl n)(Avl (S n)) (Node (S n) (S hL) hR (S hL) (More (S hL) hR (S hL) [conv (join 1 1: S hL = S hL) by (sym u) at x.(S hL = S x)][join 10 10]) [ conv (conv (conv (join 1 1: S n = S n) by p at x.(S n = S x)) by v at x.(S n = S (S x))) by u at x.(S n = S (S x))] b trr y) 
                                                                          |  Less [u] [v] ->
Left (Avl n)(Avl (S n)) (Node  n (S hL) hR hR (Same (S hL) hR hR [u][join 10 10]) [conv p by v at x.(n = S x)]  b trr y) 
                                                                          |  More [u] [v] -> rotateLeft trl y b)
                                 |  True -> (case (insert x hR trr) {ins_eq} of
                                                  Left a -> Left (Avl n)(Avl (S n)) (Node n hL hR hMax bal [p] trl a y)
                                                | Right b -> case bal {bal_eq} of
                                                                  Same [u] [v] -> 
Right (Avl n)(Avl (S n)) (Node (S n) hL (S hR) (S hR) (Less hL (S hR) (S hR) [conv (join 1 1: S hR = S hR) by u at x.(S hR = S x)][join 10 10]) [conv (conv (join 1 1: S n = S n) by p at x.(S n = S x)) by v at x.(S n = S (S x)) ] trl b y) 
                                                                | More [u] [v] ->
Left (Avl n)(Avl (S n)) (Node  n hL (S hR) (S hR) (Same hL (S hR) (S hR) [sym u][join 10 10]) [conv (conv p by v at x. (n = S x)) by u at x.(n = S x)] trl b y)
 
                                                                |  Less [u] [v]  -> rotateRight trl y b )
                                                                    

