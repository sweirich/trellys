module CKMachine where


data String : Type where
     Empstr : String
    | Str0  : String -> String
    | Str1  : String -> String

data Term : Type where
      Var : String-> Term
     |App : Term -> Term -> Term
|Lambdabs : String -> Term -> Term


data Bool : Type where
 False : Bool
| True : Bool

data StateT : Type where
    State: Term -> Cont ->StateT
  

data Cont  : Type where
    MT: Cont
   |Fn: String-> Term->Cont-> Cont
   |Ar: Cont -> Term -> Cont
    

type isLambda : Term -> Bool
 prog isLambda = \(l:Term) ->
   case l {l_eq} of 
     Lambdabs l' t' -> True
    |App l' t' -> False
    |Var l' -> False

 
type eq_str : String -> String -> Bool
prog rec eq_str (t:String)(s:String) =
  case t {t_eq} of
    Empstr -> (case s {s_eq} of
            Empstr -> True
          | Str0 s' -> False
          | Str1 s' -> False)
    | Str0 t' -> (case s {s_eq} of  
            Empstr -> False
           |Str0 s'-> (eq_str t' s') 
           |Str1 s' -> False)
    | Str1 t' -> (case s {s_eq} of  
            Empstr -> False
           |Str0 s' -> False 
           |Str1 s' -> (eq_str t' s'))




type substitute : Term -> String -> Term -> Term
    prog rec substitute (t :Term) (s:String) (t1: Term)=
        
       
          case t1 {t1_eq} of 
                 Var x' -> (case eq_str s x' {eqstr_eq} of
                           True -> t
                          |False -> t1)
                 |Lambdabs s' t' ->  (case (eq_str s s') {eqstr_eq} of
                           True -> t1
                          |False -> Lambdabs s' (substitute t s t') )
                 |App t2 t3 -> App (substitute t s t2)
                                   (substitute t s t3)



type isVar: Term-> Bool
prog isVar = \(t:Term) ->
 case t {t_eq} of
        Var x -> True
       | Lambdabs s t -> False
       | App t1 t2 -> False
 
type or : Bool -> Bool-> Bool
prog or = \(b:Bool)(b2:Bool) ->
     case b {b_eq} of
      True -> True
    | False -> b2

type isLambda : Term -> Bool
 prog isLambda = \(l:Term) ->
   case l {l_eq} of 
     Lambdabs l' t' -> True
    |App l' t' -> False
    |Var l' -> False


type isHeadNorm : Term-> Bool
prog  rec isHeadNorm (t:Term)=
        case t {t_eq} of
           App t1 t2 ->( case (isVar t1) {ivar_eq} of
                        True-> or (isHeadNorm t2) (isLambda t2)
                                 
                       |False-> case t1 {t1_eq} of
		       		  Var x -> abort Bool
				 | Lambdabs s t -> False
				 | App t1' t2' -> isHeadNorm t1)
          |Var x -> True
          |Lambdabs s t -> False

type step : StateT -> StateT
prog  step = \(s: StateT) ->
    case s {s_eq} of
      State t k-> case t {t_eq} of
                    App t1 t2 -> State t1 ( Ar k  t2)

                    |Lambdabs s' t' -> (case k {k_eq} of
                              MT-> State t k  
                             |Fn s'' t'' c' -> State( substitute t s'' t'') c'
                             |Ar  c' t' -> State t' (Fn s' t'  c')) 
                    |Var x' -> abort StateT


{- for the proof about step:

   if s1 and s2 are states, and step s1 = s2, then
   we want to prove that the term t1 (let's call it) which s1 represents
   can transition to the term t2 which s2 represents.

   What do we mean by "represents"?  We know the continuation in a state is
   encoding a context (in a way that enables more efficient interpreting).

   For example, the term 

   (*)    ((\x.x) (\y.y)) (\z.z)

   can be represented by several states actually:

   1.  < ((\x.x) (\y.y)) (\z.z) ,  mt >
   2.  < (\x.x) (\y.y) , <ar , (\z.z),  mt > >
   3.  < \x.x , < ar, (\y.y), <ar , (\z.z), mt>>>
   4.  < \y.y , < fn, (\x.x), <ar , (\z.z), mt>>>



   When this is defined, it should interpret all the example
   states (1) through (4) above as the example term (*).

   Then define


 
   just by calling kplug with the continuation and term which are 
   in the state.

   So then the final theorem to prove would be:

   forall(s1:State)(u1:s1!)(s2:State)(u2:s2!)(u:step s1 = s2).
   exists(v:StepSpec0 (interpstate s1) (interpstate s2)).v!

where we need also this definition, to handle the case
where the CK machine does not do a beta-reduction:

data StepSpec0 : (t1:Term) (t2:Term) -> Type where
  DidStep : StepSpec t1 t2 -> StepSpec0 t1 t2
| DntStep : [u:t1=t2] -> StepSpec0 t1 t2
  

-}

 type kplug : Cont -> Term -> Term
   prog rec kplug (c: Cont)(t:Term) = 
    case c {c_eq} of
         MT -> t 
        |Fn x t' k -> kplug (Ar k t) (Lambdabs x t') 
        |Ar k t' -> (kplug k (App t t'))

type interpstate : StateT -> Term
prog interpstate = \(s:StateT)->
  case s {s_eq} of
    State t' k'-> kplug k' t'

type reduce : StateT -> Term
prog rec reduce (s: StateT) =
    (case s {st_eq} of
      State t k -> (case k {k_eq} of
                    MT-> (case t {t_eq} of
                           Lambdabs s' t' -> t
                          |Var x -> t
                          |App t1 t2->reduce (step(State t1 (Ar k t2))))
                   |Fn s'' t'' c'' -> reduce (step (State t (Fn s'' t'' c'')))
                   |Ar c''' t''' -> reduce (step (State t (Ar c''' t'''))))) 

                            

Eval (reduce (State (App (Lambdabs( Str0 Empstr)
      (App(Var (Str0 Empstr))(Var(Str0 Empstr)))) (Lambdabs (Str1 Empstr)(Var (Str1 Empstr))) )MT))
            
theorem reduce_test1 : reduce (State (App (Lambdabs( Str0 Empstr)
(App(Var (Str0 Empstr))(Var(Str0 Empstr)))) (Lambdabs (Str1 Empstr)(Var (Str1 Empstr))) )MT)= (Lambdabs( Str1 Empstr)( Var (Str1 Empstr)))
proof reduce_test1 = join 10000 10000

           


              



                                     
 


