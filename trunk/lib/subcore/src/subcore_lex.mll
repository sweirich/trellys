{
 (* auto-generated by gt *)

open Subcore_parse;;
 
}

rule token = parse
| ['\t' ' ' '\n' '\r']+ as str { let i = ref 0 in String.iter(fun s -> if s <> ' ' && s <> '\t' then incr i) str; Subcore_util.line := !Subcore_util.line + !i; token lexbuf }
| '#'  (_ # ['\n' '\r'])* { token lexbuf }
| ":" { COLON(Subcore_util.cur_pd()) }
| "=" { EQ(Subcore_util.cur_pd()) }
| ";" { SEMI(Subcore_util.cur_pd()) }
| "*" { STAR(Subcore_util.cur_pd()) }
| "," { COMMA(Subcore_util.cur_pd()) }
| "fold" { FOLD(Subcore_util.cur_pd()) }
| "unfold" { UNFOLD(Subcore_util.cur_pd()) }
| "refl" { REFL(Subcore_util.cur_pd()) }
| "Define" { DEFINE(Subcore_util.cur_pd()) }
| "in" { IN(Subcore_util.cur_pd()) }
| "Set" { SET(Subcore_util.cur_pd()) }
| "Unset" { UNSET(Subcore_util.cur_pd()) }
| "\\" { LAM(Subcore_util.cur_pd()) }
| "!" { PI(Subcore_util.cur_pd()) }
| "->" { ARROW(Subcore_util.cur_pd()) }
| "self" { SELF(Subcore_util.cur_pd()) }
| "substself" { SUBSTSELF(Subcore_util.cur_pd()) }
| "fix" { FIX(Subcore_util.cur_pd()) }
| "to" { TO(Subcore_util.cur_pd()) }
| "eval" { EVAL(Subcore_util.cur_pd()) }
| "Fix" { FIXCMD(Subcore_util.cur_pd()) }
| "Eval" { EVALCMD(Subcore_util.cur_pd()) }
| "by" { BY(Subcore_util.cur_pd()) }
| "conv" { CONV(Subcore_util.cur_pd()) }
| "(" { LP(Subcore_util.cur_pd()) }
| ")" { RP(Subcore_util.cur_pd()) }
| "[" { LS(Subcore_util.cur_pd()) }
| "]" { RS(Subcore_util.cur_pd()) }
| "." { DOT(Subcore_util.cur_pd()) }
| ['a'-'z' 'A'-'Z' '_']['0'-'9' '\'' '_' 'a'-'z' 'A'-'Z' '\'']* as str { ID((Subcore_util.cur_pd(),str)) }
| eof { EOF }
| _ {failwith((Lexing.lexeme lexbuf) ^": lexing error"^(Subcore_util.string_of_pos (Subcore_util.cur_pd())))}{}
