module Arithmetic where

import Prelude

plus : Nat -> Nat -> Nat
recnat plus n = \m .
  case n [cw] of
    Zero -> m
    Succ pred -> Succ (plus pred [cw] m)


mult : Nat -> Nat -> Nat
recnat mult n = \m .
  case n [cw] of
    Zero -> Zero
    Succ pred -> plus m (mult pred [cw] m)


minus : Nat -> Nat -> Nat
recnat minus n = \m .
   case n [cn] of
     Zero -> Zero
     Succ pred -> case m [cm] of
                    Zero -> n
                    Succ mpred -> minus pred [cn] mpred

-- 'x > y'
gt : Nat -> Nat -> Bool
recnat gt x = \y.
   case x [xpf] of
        Zero    -> False
        Succ x' -> case y [_] of
                   Zero -> True
                   Succ y' -> gt x' [xpf] y' 
-- 'x < y'
lt : Nat -> Nat -> Bool
lt = \x.\y.gt y x

-- 'x >= y'
gte : Nat -> Nat -> Bool
gte = \x.\y.case (minus x y) [_] of 
            Zero -> case x [_] of
                    Zero -> case y [_] of
                            Zero -> True
                            Succ y' -> False
                    Succ x' -> False
            Succ z -> True

-- 'x <= y'
lte : Nat -> Nat -> Bool
lte = \x.\y.gte y x

-- 'x = y'
eq : Nat -> Nat -> Bool
eq = \x.\y.case (gt x y) [_] of
           False -> case (lt  x y) [_] of
                    False -> True
                    True -> False
           True  -> False

-- x != y
neq : Nat -> Nat -> Bool
neq = \x.\y.case (eq x y) [_] of
            True -> False
            False -> True

-- 'div' calculates ceiling(n/m+1)
prog div : Nat => Nat => Nat
rec div n = \m .
  case n [_] of
    Zero -> Zero
    Succ pred ->  let prog rc [_] = div (minus pred m) m in
                  Succ rc

minus_same_zero : (n : Nat) -> (minus n n = 0)
recnat minus_same_zero n =
    case n [n_eq] of
      Zero -> conv (join : (minus 0 0 = 0)) by
		  	 		    (sym Nat Nat n 0 n_eq) at
			   			  hole.(minus hole hole = 0)
							  -- minus n n = 0
      Succ pred ->

        let step [step_eq] =
         (join : (minus (Succ pred) (Succ pred)) = minus pred pred) in
				 -- minus (Succ pred) (Succ pred) = minus pred pred
        let ic [ic_eq] = minus_same_zero pred [n_eq] in
				-- minus pred pred = 0
				let tc [_] = trans [Nat] [Nat] [Nat]
                				   [minus (Succ pred) (Succ pred)]
                				   [minus pred pred]
                			           [0] [step] [ic] in
        -- minus (Succ pred) (Succ pred) = 0
				let [n_eq_sym] [n_eq_sym_eq] = sym Nat Nat n (Succ pred) n_eq in
				-- TODO: should really be an application of 'sym'
				conv tc
             by n_eq_sym
 				     at hole.(minus hole hole = 0)


lemma_minus_zero_id : (n : Nat) -> (minus n 0 = n)
lemma_minus_zero_id =
  \n . case n [eq_n] of 
    Zero -> conv (join 10 : minus 0 0 = 0) by (sym Nat Nat n 0 eq_n) at hole.(minus hole 0 = hole)
    Succ n' -> 
      conv (join 10 : minus (Succ n') 0 = Succ n')
        by (sym Nat Nat n (Succ n') eq_n)
	at hole.(minus hole 0 = hole)

lemma_minus_plus_id : (n : Nat) -> (m : Nat) -> ((minus (plus m n) m) = n)
lemma_minus_plus_id = \n. recnat ih m =
   case m [eq_m] of 
     Zero -> conv (conv lemma_minus_zero_id n by (join 10 : n = plus 0 n) at hole.(minus hole 0) = n)
               by (sym Nat Nat m 0 eq_m)
	       at hole.((minus (plus hole n) hole) = n)
     Succ m' -> 
       conv -- (minus (plus m n) m) == (minus (plus (Succ m') n) (Succ m'))
         (conv -- == (minus (Succ (plus m' n) (Succ m')))
            (let p [eq_p] = plus m' n in
               conv --  == minus (Succ p) (Succ m')
                 (conv --  == minus p m'
                    (conv  --  == minus (plus m' n) m'                      
                      (ih m' [eq_m]) --  = n  (by IH)
                      by (sym Nat Nat p (plus m' n) eq_p)
                      at hole.minus hole m' = n)
                    by (join 10 : minus p m' = minus (Succ p) (Succ m'))
                    at hole.hole = n)
		 by eq_p
		 at hole.minus (Succ hole) (Succ m') = n)
	    by (join 10 : (Succ (plus m' n)) = (plus (Succ m') n))
            at hole.minus hole (Succ m') = n)
         by (sym Nat Nat m (Succ m') eq_m)
	 at hole.minus (plus hole n) hole = n

-- n = n*(m+1) / m
log div_mult : (n : Nat) -> (m : Nat) ->
    (n = div (mult n (Succ m)) m)
recnat div_mult n = \m .
  case n [n_eq] of
    Zero ->
            let zc [zc_eq] = (join : 0 = div (mult 0 (Succ m)) m) in
						 -- 0 = div (mult 0 (Succ m)) m
						let [n_eq_sym] [_] = (sym Nat Nat n 0 n_eq) in
						-- 0 = n
						conv zc
						  by n_eq_sym
              at hole.(hole = div (mult hole (Succ m)) m)
    Succ pred ->
		  -- A couple of aliases for controlling normalization under join
      let [p1] [p1_eq] = mult pred (Succ m) in
			let [p2] [p2_eq] = (plus m p1) in


			let n1 [n1_eq] = (join : (let prog rc [rc_eq] = div (minus p2 m) m in Succ rc) = div (Succ p2) m) in

			--*  The left hand side (reducing to n)

			-- { expand the definition of p2 }
			let l1 [l1_eq] = conv n1 by p2_eq at hole.((let prog rc [rc_eq] = div (minus hole m) m in Succ rc) = div (Succ hole) m) in
			--> let prog rc [rc_eq] = div (minus (plus m p1)) m in Succ rc = div (Succ (plus m p1)) m


			-- { apply the minus/plus cancellation lemma }
			let l2 [_] = conv l1
			       by (lemma_minus_plus_id p1 m)
			       at hole.(let prog rc [rc_eq] = div hole m in Succ rc) = div (Succ (plus m p1)) m in
      --> let prog rc [rc_eq] = div p1 m in Succ rc = div (Succ (plus m p1)) m

			-- { expand the def. of p1 }
			let l3 [_] = conv l2
			       by p1_eq
						 at hole.(let prog rc [rc_eq] = div hole m in Succ rc) = div (Succ (plus m p1)) m in
      --> (let prog rc [rc_eq] = div (mult pred (Succ m)) m in Succ rc) = div (Succ (plus m p1)) m

			-- { Apply the induction hypothesis }
 			let [ih] [_] = conv (join : pred = pred)
			                      by (div_mult pred [n_eq] m)
														at hole.(hole = pred) in
      --> div (mult pred (Succ m)) m = pred
			let l4 [_] = conv l3 by ih at
			   hole.(let prog rc [rc_eq] = hole in Succ rc) = div (Succ (plus m p1)) m in
      --> let prog rc [rc_eq] = pred in Succ rc = div (Succ (plus m p1)) m

			-- { Convert 'let prog rc [rc_eq] = pred in Succ rc' to 'Succ pred', then to 'n' }
			let l5 [_] = conv l4
                        by (join : (let prog rc [rc_eq] = pred in Succ rc) = Succ pred)
												at hole.(hole = div (Succ (plus m p1)) m) in
      let l6 [_] = conv l5
                         by (sym Nat Nat n (Succ pred) n_eq)
												 at hole.(hole = div (Succ (plus m p1)) m) in
      --> n = div (Succ (plus m p1)) m

			-- * The right-hand side (converting to 'div (mult n (Succ m)) m'

			-- { Rewrite (Succ (plus m p1)) to plus (Succ m) p1
			let [plus_inv] [_] = (join : Succ (plus m p1) = (plus (Succ m) p1)) in

			let l7 [_] = conv l6 by plus_inv at hole.(n = div hole m) in
			--> n = div (plus (Succ m) p1) m'

			-- { Expand the definition of 'p1' }
			let l8 [_] = conv l7 by p1_eq at hole.(n = div (plus (Succ m) hole) m) in
			--> n = div (plus (Succ m) (mult pred (Succ m))) m

			-- { Rewrite 'plus (Succ m) (mult pred (Succ m))' to 'mult (Succ pred) (Succ m)'
			let mult_inv [_] =
			  (join : plus (Succ m) (mult pred (Succ m)) = mult (Succ pred) (Succ m)) in

      -- { Apply the mult. inv. rule -}
			let l9 [_] = conv l8 by mult_inv at hole.(n = div hole m) in
			--> n = div (mult (Succ pred) (Succ m)) m

			-- { Apply the n = Succ pred rule }
			conv l9 by (sym Nat Nat n (Succ pred) n_eq) at hole.(n = div (mult hole (Succ m)) m)

plus_associates : (i:Nat) -> (j:Nat) -> (k:Nat) -> plus (plus i j) k = plus i (plus j k)
plus_associates = recnat pa i = \j k .
  case i [ieq] of
            -- `join` away `Zero`s on the left of `(+)`: (0+j)+k = j+k = 0+(j+k)
    Zero -> let [ieq'] [_] = sym Nat Nat i 0 ieq -- evidence of backwards equality. NC
            in conv (join 42 : plus (plus 0 j) k = plus 0 (plus j k)) by ieq'
                 at i . plus (plus i j) k = plus i (plus j k)

               -- associate `plus` in `Succ` of the inductive case: S ((i'+j)+k) = S (i'+(j+k))
    Succ i' -> let ih [_] = pa i' [ieq] j k
               in let e1 [p] = conv (join 0) by ih at h . Succ (plus (plus i' j) k) = Succ h

               -- move the `Succ` inside on the left: S ((i+j)+k) = ((S i)+j)+k
               in let [ieq'] [_] = sym Nat Nat i (Succ i') ieq -- evidence of backwards equality. NC
               in let e2 [_] = (join 42 : Succ (plus (plus i' j) k) = plus (plus (Succ i') j) k)
               in let e2' [_] = conv e2 by ieq' at h . Succ (plus (plus i' j) k) = plus (plus h j) k

               -- move the `Succ` inside on the right: S (i+(j+k)) = (S i)+(j+k)
               in let e3 [_] = (join 42 : Succ (plus i' (plus j k)) = plus (Succ i') (plus j k))
               in let e3' [_] = conv e3 by ieq' at h . Succ (plus i' (plus j k)) = plus h (plus j k)

               -- move the `Succ` inside both sides
               in conv (conv e1 by e2' at h . h = Succ (plus i' (plus j k))) by e3' at h . plus (plus i j) k = h

main : Nat
main = plus 2 3
