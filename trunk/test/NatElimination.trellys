-- Nat elimination with examples.
-- 
-- Goal was to write an Ackermann's function using higher-order
-- primitive recursion.  This is easy, but NC was surprised when he
-- heard this could be done, because Ackermann is not (first-order)
-- primitive recursive.
--
-- Includes an example (add') where the lack of extensionality for
-- Pi-types had to be worked around.
module NatElimination where

import Prelude
import Arithmetic
import Logic

-- Higher-order primitive recursion
-- --------------------------------

-- Higher-order primitive recursion / nat
-- elimination. Cf. Vecters.recvec.
primrec : [p: (n:Nat) -> Type 0]
       -> (base:p 0)
       -> (step: (n:Nat) -> (pn:p n) -> p (Succ n))
       -> (n:Nat) -> p n
primrec = \[p]. \base. \step. recnat pr n =
  case n [neq] of
    -- sym is evidence of backwards equality.
    Zero    -> conv base                  by (sym Nat Nat n Zero      neq) at x.p x
    Succ n' -> conv step n' (pr n' [neq]) by (sym Nat Nat n (Succ n') neq) at x.p x

-- Higher order primitive recursion with a constant predicate / nat
-- elimination: easier to compute terms with, when it works, but not
-- much use for proofs.
foldNat : [p: Type 0] -> (base:p) -> (step: (pn:p) -> p) -> (n:Nat) -> p
foldNat = \[p]. \base. \step. recnat pr n =
  case n [neq] of
    -- sym is evidence of backwards equality.
    Zero    -> base
    Succ n' -> step (pr n' [neq])

-- Strong / course-of-values recursion
-- -----------------------------------

-- cf. Arithmetic.lt
--
-- Is it easier to use (lt m n = True) ?
data LT [m:Nat] [n:Nat] -> Type 0 where
  LZ : [Zero = m] -- [m = Zero] would be more consistent here, but this avoids a sym below
    -> [n':Nat] -> [n = Succ n'] 
    -> LT m n
  LS : [m':Nat] -> [m = Succ m']
    -> [n':Nat] -> [n = Succ n'] 
    -> [LT m' n'] -> LT m n

lt_0__F : [m:Nat] -> [LT m Zero] -> Void
lt_0__F = \[m] [p] . case p [_] of
  -- both cases have (Zero = Succ _)
  LZ [_] [_] [q]         -> contra q
  LS [_] [_] [_] [q] [_] -> contra q

-- Poor man's inversion: use join and a projection function (pred).
eqS__eq : (m:Nat) -> (n:Nat) -> (Succ m = Succ n) -> m = n
eqS__eq = \m n sm_eq_Sn .
  let pSm_eq_m [_]   = (join : pred (Succ m) = m) in
  let pSn_eq_n [_]   = (join : pred (Succ n) = n) in
  let pSm_eq_pSn [_] = (conv (join : pred (Succ m) = pred (Succ m)) 
                        by sm_eq_Sn at h.pred (Succ m) = pred h) in
  conv pSm_eq_pSn by pSm_eq_m, pSn_eq_n at hm hn.hm = hn

-- An obvious fact with an exceptionally tedious proof ... anyone know
-- a simple version?
--
-- Proof by induction on m.  Idea is
--
--   case m < S n of
--     m = Z              -> easy case on n.
--     m = S m' /\ m' < n -> case n of
--       Z    -> contradiction.
--       S n' -> IH on m' < S n' gives m' = n' \/ m' < n',
--                               and in either case apply S to both sides.
--
-- details involve a few convs ...
lt__lteq : [m:Nat] -> [n:Nat] -> [LT m (Succ n)] 
                    -- (m = n) is more natural, but then need sym
                    -- below in strongNat. This is evidence of the
                    -- usefulness of convrl
        -> Or (LT m n) (n = m)
lt__lteq = recnat lt__lteq [m] = \[n] [m_lt_Sn] .
  case m_lt_Sn [_] of
    LZ [z_eq_m] [n'] [sn_eq_Sn']                   ->
      let n_eq_n' [_] = eqS__eq n n' sn_eq_Sn' in
      case n' [n'_eq] of
        Zero -> InR [LT m n] [n = m]
                (conv (join : n = n)
                 by trans4' Nat Nat Nat  Nat 
                            n   n'  Zero m 
                            n_eq_n' n'_eq z_eq_m
                 at h.n = h)
        Succ n'' -> InL [LT m n] [n = m]
                    (LZ [m] [n] [z_eq_m] [n'']
                        [conv n'_eq
                         by (sym Nat Nat n n' n_eq_n') -- convrl
                         at h.h = Succ n''])
    LS [m'] [m_eq_Sm'] [n'] [sn_eq_Sn'] [m'_lt_n'] ->
      let n_eq_n' [_] = eqS__eq n n' sn_eq_Sn' in
      let n'_eq_n [_] = sym Nat Nat n n' n_eq_n' in
      case n' [n'_eq] of
        Zero     -> poe [Or (LT m n) (n = m)] 
                        [lt_0__F [m'] [conv m'_lt_n' by n'_eq at h.LT m' h]]
        Succ n'' -> let n_eq_Sn'' [_] = (conv n'_eq by n'_eq_n at h.h = Succ n'') in
                    case (lt__lteq [m'] [m_eq_Sm'] [n'']
                                   [conv m'_lt_n' by n'_eq at h.LT m' h]) [_] of
                      InL m'_lt_n'' ->
                        InL [LT m n] [n = m]                                             
                            (conv (LS [m] [n'] [m'] [m_eq_Sm'] [n''] [n'_eq] [m'_lt_n''])
                             by n'_eq_n at h.LT m h)                                     
                      InR n''_eq_m' ->
                        InR [LT m n] [n = m]                                          
                            (let e1 [_] = (join : Succ n'' = Succ n'') in                             
                             let e2 [_] = conv e1 by (sym Nat Nat n' (Succ n'') n'_eq)               
                                          at h.h = Succ n'' in                                       
                             let e3 [_] = conv e2 by n'_eq_n at h.h = Succ n'' in                    
                             let e4 [_] = conv e3 by n''_eq_m' at h.n = Succ h in                    
                             conv e4 by (sym Nat Nat m (Succ m') m_eq_Sm') at h.n = h)

-- Strong elimination / course-of-values induction / structural
-- induction: allows recursion on any structural subterm, not just the
-- predecessor.
strongNat : [p:Nat -> Type 0]
         -> [(n:Nat) -> ((m:Nat) -> LT m n -> p m) -> p n]
         -> ((n:Nat) -> p n)
strongNat = \[p] [f] .
  -- g n : (m:Nat) -> LT m n -> p m, and so proves p n via f
  let g [_] = ((recnat g n = case n [eq_n] of
    -- m < 0, a contradiction
    Zero    -> \m lt_p . 
      poe [p m] [lt_0__F [m] [conv lt_p by eq_n at h.LT m h]]
    -- m < S n' -> m < n' \/ m = n'
    Succ n' -> \m lt_p .
      case (lt__lteq [m] [n'] [conv lt_p by eq_n at h.LT m h]) [_] of
        -- m < n', so g n' recursively proves p m
        InL lt_p'  -> g n' [eq_n] m lt_p'
        -- n' = m, so f proves p m via g n'
        InR n_eq_m -> (conv (f n' (g n' [eq_n])) by n_eq_m at h.p h)
           -- this is g's type annotation, is there a better way to do
           -- this?
           ): (n:Nat) -> ((m:Nat) -> (LT m n) -> p m))
  in \n . f n (g n)

-- Addition
-- --------
    
-- First with primrec
  
-- Need a predicate with constant value Nat.
--
-- Can build one from const, but it's too much trouble to use ...
const : [aT:Type 1] -> [bT:Type 0] -> (a:aT) -> (b:bT) -> aT
const = \[aT] [bT] a b.a

-- ... it's better to specialize const
constNat : (w:Nat) -> Type 0
constNat = \w.Nat

-- Now get addition, a heavily conv'd version of
--
--   add' = \m. primrec [constNat] m (\n.\add_m_n.Succ add_m_n)
add' : (m:Nat) -> (n:Nat) -> Nat
add' = 
  \m. \n. 
  -- I don't know how (or if it's even possible, since we don't have
  -- extensionality?) to prove equality of arrow types for the
  -- n-eta-reduced version, but it's easy to conv the body of the
  -- n-eta-expanded version:
    conv
      (primrec
        [constNat]
        (conv m by (join: Nat = (constNat 0)) at x.x)
        (\n.\mn.conv (Succ (conv mn by (join: (constNat n) = Nat) at x.x))
                  by (join: Nat = (constNat (Succ n))) at x.x)
        n)
      by (join: (constNat n) = Nat) at x.x
-- trellys can't infer type for [\w.Nat] and annotation causes parse
-- error in my first attempt:
--
--   add' = \m. primrec [\w.Nat : ((w:Nat) -> Type 0)] m (\n.\mn.Succ mn)
--
-- Is this a bug? I'll create a separate, simpler, example ...
-- ... UPDATE: I can't find a simple version, maybe I imagined the problem :P


-- Then with foldNat, which is much easier.
add'' : (m:Nat) -> (n:Nat) -> Nat
add'' = \m. foldNat [Nat] m (\mn.Succ mn)


-- Ackermann
-- ---------

-- primrec version
--
-- left as an exercise for the reader ... may the conv be with you.

-- foldNat version
ack : (m:Nat) -> (n:Nat) -> Nat
ack = foldNat [(w:Nat) -> Nat] (\n.Succ n)
        (\a_m. foldNat [Nat] (a_m 1) (\a_Sm_n. a_m a_Sm_n))

-- recnat version
ack' : (m:Nat) -> (n:Nat) -> Nat
ack' = recnat a m =
  case m [meq] of
    Zero    -> \n. Succ n
    Succ m' -> recnat am n =
      case n [neq] of
        Zero    -> a m' [meq] 1
        Succ n' -> a m' [meq] (am n' [neq])
