-- Nat elimination with examples.
-- 
-- Goal was to write an Ackermann's function using higher-order
-- primitive recursion.  This is easy, but NC was surprised when he
-- heard this could be done, because Ackermann is not (first-order)
-- primitive recursive.
--
-- Includes an example (add') where the lack of extensionality for
-- Pi-types had to be worked around.
module NatElimination where

import Prelude
import Arithmetic
import Logic

-- Higher-order primitive recursion
-- --------------------------------

-- Higher-order primitive recursion / nat
-- elimination. Cf. Vecters.recvec.
primrec : [p: (n:Nat) -> Type 0]
       -> (base:p 0)
       -> (step: (n:Nat) -> (pn:p n) -> p (Succ n))
       -> (n:Nat) -> p n
primrec = \[p]. \base. \step. recnat pr n =
  case n [neq] of
    -- sym is evidence of backwards equality.
    Zero    -> conv base                  by (sym Nat Nat n Zero      neq) at x.p x
    Succ n' -> conv step n' (pr n' [neq]) by (sym Nat Nat n (Succ n') neq) at x.p x

-- Higher order primitive recursion with a constant predicate / nat
-- elimination: easier to compute terms with, when it works, but not
-- much use for proofs.
foldNat : [p: Type 0] -> (base:p) -> (step: (pn:p) -> p) -> (n:Nat) -> p
foldNat = \[p]. \base. \step. recnat pr n =
  case n [neq] of
    -- sym is evidence of backwards equality.
    Zero    -> base
    Succ n' -> step (pr n' [neq])

-- Strong / course-of-values recursion
-- -----------------------------------

-- cf. Arithmetic.lt
--
-- Is it easier to use (lt m n = True) ?  And what about the alternate
-- ADT characterization derived below in lemmas m_lt_Sm and lt_inc?
-- I.e., what if we instead define
{-
data LT [m:Nat] [n:Nat] -> Type 0 where
  LBase : [n = Succ m] -> LT m n
  LStep : [n':Nat] -> [n = Succ n'] 
       -> [LT m n'] -> LT m n
-}
-- and then derive the current LT constructors as lemmas?
data LT [m:Nat] [n:Nat] -> Type 0 where
                  -- There are now many syms ... this comment is
                  -- retained for history:
                  --
  LZ : [Zero = m] -- [m = Zero] would be more consistent here, but this avoids a sym below
    -> [n':Nat] -> [n = Succ n'] 
    -> LT m n
  LS : [m':Nat] -> [m = Succ m']
    -> [n':Nat] -> [n = Succ n'] 
    -> [LT m' n'] -> LT m n

lt_0__F : [m:Nat] -> [LT m Zero] -> Void
lt_0__F = \[m] [p] . contra ((case p [_] of
  -- both cases have (Zero = Succ _)
  LZ [_] [_] [q]         -> contra q
  LS [_] [_] [_] [q] [_] -> contra q) : 0 = 1)

-- Poor man's inversion: use join and a projection function (pred).
eqS__eq : (m:Nat) -> (n:Nat) -> (Succ m = Succ n) -> m = n
eqS__eq = \m n sm_eq_Sn .
  let pSm_eq_m [_]   = (join : pred (Succ m) = m) in
  let pSn_eq_n [_]   = (join : pred (Succ n) = n) in
  let pSm_eq_pSn [_] = (conv (join : pred (Succ m) = pred (Succ m)) 
                        by sm_eq_Sn at h.pred (Succ m) = pred h) in
  conv pSm_eq_pSn by pSm_eq_m, pSn_eq_n at hm hn.hm = hn

-- An obvious fact with an exceptionally tedious proof ... anyone know
-- a simple version?
--
-- (2nd) Proof by induction on m.  Idea is
--
--   case m of
--     Z    -> easy case on n.
--     S m' -> case m < S n of
--       m = Z  -> contradiction.
--       m = S m' /\ n = S n' /\ m' < n' -> case n' of
--         Z     -> contradiction
--         S n'' -> IH on m' < S n'' gives m' = n'' \/ m' < n'',
--                                   and in either case apply S to both sides.
-- details involve a few convs ...
lt__lteq' : [m:Nat] -> [n:Nat] -> [LT m (Succ n)] 
        -> Or (LT m n) (n = m)
                    -- (m = n) is more natural, but then need sym
                    -- below in strongNat. This is evidence of the
                    -- usefulness of convrl
lt__lteq' = recnat lt__lteq [m] = \[n] [m_lt_Sn] .
  case m [m_eq] of
    Zero    -> case n [n_eq] of
      Zero    -> InR [LT m n] [n = m]
                     (conv (join:0=0) by (sym Nat Nat n Zero n_eq), 
                                         (sym Nat Nat m Zero m_eq) 
                      at n m.n = m)
      Succ n' -> InL [LT m n] [n = m]
                     (LZ [m] [n] [sym Nat Nat m Zero m_eq] [n'] [n_eq])
    Succ m' -> case m_lt_Sn [_] of
      LZ [z_eq_m] [n'] [sn_eq_Sn']                   ->
        contra (conv z_eq_m by m_eq at h.Zero = h)
      LS [m'] [m_eq_Sm'] [n'] [sn_eq_Sn'] [m'_lt_n'] ->
        case n' [n'_eq] of
          Zero     -> poe [Or (LT m n) (n = m)] 
                          [lt_0__F [m'] [conv m'_lt_n' by n'_eq at h.LT m' h]]
          Succ n'' -> let n'_eq_n [_] = (sym Nat Nat n n' (eqS__eq n n' sn_eq_Sn')) in
                      case (lt__lteq [m'] [m_eq_Sm'] [n'']                                 
                                     [conv m'_lt_n' by n'_eq at h.LT m' h]) [_] of         
                        InL m'_lt_n'' ->                                                   
                          InL [LT m n] [n = m]                                             
                              (conv (LS [m] [n'] [m'] [m_eq_Sm'] [n''] [n'_eq] [m'_lt_n''])
                               by n'_eq_n at h.LT m h)                                     
                        InR n''_eq_m' ->                                                   
                          InR [LT m n] [n = m]
                              (let e1 [_] = conv n'_eq by n'_eq_n at h.h = Succ n'' in
                               let e2 [_] = conv e1 by n''_eq_m' at h.n = Succ h in                  
                               conv e2 by (sym Nat Nat m (Succ m') m_eq_Sm') at h.n = h)   


-- An obvious fact with an exceptionally tedious proof ... anyone know
-- a simple version?
--
-- (1st) Proof by induction on m.  Idea is
--
--   case m < S n of
--     m = Z              -> easy case on n.
--     m = S m' /\ m' < n -> case n of
--       Z    -> contradiction.
--       S n' -> IH on m' < S n' gives m' = n' \/ m' < n',
--                               and in either case apply S to both sides.
--
-- details involve a few convs ...
lt__lteq : [m:Nat] -> [n:Nat] -> [LT m (Succ n)] 
                    -- (m = n) is more natural, but then need sym
                    -- below in strongNat. This is evidence of the
                    -- usefulness of convrl
        -> Or (LT m n) (n = m)
lt__lteq = recnat lt__lteq [m] = \[n] [m_lt_Sn] .
  case m_lt_Sn [_] of
    LZ [z_eq_m] [n'] [sn_eq_Sn']                   ->
      let n_eq_n' [_] = eqS__eq n n' sn_eq_Sn' in
      case n' [n'_eq] of
        Zero -> InR [LT m n] [n = m]
                (conv (join : n = n)
                 by trans4' Nat Nat Nat  Nat 
                            n   n'  Zero m 
                            n_eq_n' n'_eq z_eq_m
                 at h.n = h)
        Succ n'' -> InL [LT m n] [n = m]
                    (LZ [m] [n] [z_eq_m] [n'']
                        [conv n'_eq
                         by (sym Nat Nat n n' n_eq_n') -- convrl
                         at h.h = Succ n''])
    LS [m'] [m_eq_Sm'] [n'] [sn_eq_Sn'] [m'_lt_n'] ->
      let n_eq_n' [_] = eqS__eq n n' sn_eq_Sn' in
      let n'_eq_n [_] = sym Nat Nat n n' n_eq_n' in
      case n' [n'_eq] of
        Zero     -> poe [Or (LT m n) (n = m)] 
                        [lt_0__F [m'] [conv m'_lt_n' by n'_eq at h.LT m' h]]
        Succ n'' -> let n_eq_Sn'' [_] = (conv n'_eq by n'_eq_n at h.h = Succ n'') in
                    case (lt__lteq [m'] [m_eq_Sm'] [n'']
                                   [conv m'_lt_n' by n'_eq at h.LT m' h]) [_] of
                      InL m'_lt_n'' ->
                        InL [LT m n] [n = m]                                             
                            (conv (LS [m] [n'] [m'] [m_eq_Sm'] [n''] [n'_eq] [m'_lt_n''])
                             by n'_eq_n at h.LT m h)                                     
                      InR n''_eq_m' ->
                        InR [LT m n] [n = m]                                          
                            (let e1 [_] = (join : Succ n'' = Succ n'') in                             
                             let e2 [_] = conv e1 by (sym Nat Nat n' (Succ n'') n'_eq)               
                                          at h.h = Succ n'' in                                       
                             let e3 [_] = conv e2 by n'_eq_n at h.h = Succ n'' in                    
                             let e4 [_] = conv e3 by n''_eq_m' at h.n = Succ h in                    
                             conv e4 by (sym Nat Nat m (Succ m') m_eq_Sm') at h.n = h)

-- Strong elimination / course-of-values induction / structural
-- induction: allows recursion on any structural subterm, not just the
-- predecessor.
strongNat : [p:Nat -> Type 0]
         -> ((n:Nat) -> ((m:Nat) -> [LT m n] -> p m) -> p n)
         -> ((n:Nat) -> p n)
strongNat = \[p] f .
  -- g n : (m:Nat) -> LT m n -> p m, and so proves p n via f
  let g [_] = ((recnat g n = case n [eq_n] of
    -- m < 0, a contradiction
    Zero    -> \m [lt_p] . 
      poe [p m] [lt_0__F [m] [conv lt_p by eq_n at h.LT m h]]
    -- m < S n' -> m < n' \/ m = n'
    Succ n' -> \m [lt_p] .
      case (lt__lteq [m] [n'] [conv lt_p by eq_n at h.LT m h]) [_] of
        -- m < n', so g n' recursively proves p m
        InL lt_p'  -> g n' [eq_n] m [lt_p']
        -- n' = m, so f proves p m via g n'
        InR n_eq_m -> (conv (f n' (g n' [eq_n])) by n_eq_m at h.p h)
           -- this is g's type annotation, is there a better way to do
           -- this?
           ): (n:Nat) -> ((m:Nat) -> [LT m n] -> p m))
  in \n . f n (g n)

-- The next two lemmas give an alternate characterization of LT

-- Every number is less than its successor
m_lt_Sm : (m:Nat) -> LT m (Succ m)
recnat m_lt_Sm m = case m [m_eq] of
  Zero    -> let m_eq' [_] = sym Nat Nat m Zero m_eq in
             conv (LZ [m] [Succ Zero] [m_eq'] [Zero] [join])
             by m_eq' at h.LT m (Succ h)
  Succ m' -> let rec_ [_] = conv (m_lt_Sm m' [m_eq]) 
                            by (sym Nat Nat m (Succ m') m_eq) 
                            at h.LT m' h in 
             LS [m] [Succ m] [m'] [m_eq] [m] [join] [rec_]

-- m < n -> m < n+1
lt_inc : (m:Nat) -> (n:Nat) -> LT m n -> LT m (Succ n)
recnat lt_inc m = \n lt_p . case lt_p [_] of
  LZ [z_eq_m] [_] [_]                           -> 
    LZ [m] [Succ n] [z_eq_m] [n] [join]
  LS [m'] [m_eq_Sm'] [n'] [n_eq_Sn'] [m'_lt_n'] ->
    let m'_lt_n [_]   = conv (lt_inc m' [m_eq_Sm'] n' m'_lt_n')
                        by (sym Nat Nat n (Succ n') n_eq_Sn')
                        at h.LT m' h in
    LS [m] [Succ n] [m'] [m_eq_Sm'] [n] [join] [m'_lt_n]

-- (m+1) - (n+1) < m+1
s_minus_s__lt : (m:Nat) -> (n:Nat) -> LT (minus (Succ m) (Succ n)) (Succ m)
s_minus_s__lt = recnat s_minus_s__lt m = \n. case m [m_eq] of
  Zero    -> let e1 [_] = (join : Zero = minus (Succ Zero) (Succ n)) in
             LZ [minus (Succ m) (Succ n)] [Succ m]
                [conv e1 by (sym Nat Nat m Zero m_eq) 
                 at m.Zero = minus (Succ m) (Succ n)]
                [m] [join]
  Succ m' -> case n [n_eq] of
    Zero    -> let e1 [_] = conv (join : minus m Zero = (minus (Succ m) (Succ Zero)))
                            by (lemma_minus_zero_id m) at h.h = minus (Succ m) (Succ Zero) in
               let e2 [_] = conv e1 by (sym Nat Nat n Zero n_eq)
                            at h.m = (minus (Succ m) (Succ h)) in
               conv (m_lt_Sm m) by e2 at h.LT h (Succ m)
    Succ n' -> let e1 [_] = conv (s_minus_s__lt m' [m_eq] n') 
                            by (sym Nat Nat m (Succ m') m_eq),
                               (sym Nat Nat n (Succ n') n_eq)
                            at m n.LT (minus m n) m in
               let e2 [_] = (join : minus m n = minus (Succ m) (Succ n)) in
               let e3 [_] = conv e1 by e2 at h.LT h m in 
               lt_inc (minus (Succ m) (Succ n)) m e3
--               LS [minus (Succ m) (Succ n)] [Succ m]
--                  [m] [join] [n] [join] [e3]

-- Logical division
--
-- cf. Arithmetic.div
--
-- m `div` n = \ceiling{ m / S n }
div' : Nat -> Nat -> Nat
div' = \m n .
       let p [p_def] = (\w.Nat : Nat -> Type 0) in -- constNat
       let f [f_def] = ((\m g . case m [m_eq] of
         Zero    -> conv Zero by (join : Nat = p m) at h.h                        -- relies on let defs in context
         Succ m' -> let [lt_p] [_] = conv (s_minus_s__lt m' n) 
                                   by (sym Nat Nat m (Succ m') m_eq)
                                   at m.LT ((minus (Succ m') (Succ n))) m in
                    let recg [_] = conv (g (minus (Succ m') (Succ n)) [lt_p])
                                   by (join : p (minus (Succ m') (Succ n)) = Nat) -- relies on let defs in context
                                   at h.h in
                    conv (Succ recg) by (join : Nat = p m) at h.h                 -- relies on let defs in context
                   ) : ((m:Nat) -> ((m_minus_sn:Nat) -> [LT (m_minus_sn) m] -> p m_minus_sn) -> p m))
       in conv (strongNat [p] f m) by (join : p m = Nat) at h.h                   -- relies on let defs in context

test_div'1 : div' 0 0 = 0
test_div'1 = join

test_minus1 : minus 1 1 = 0
test_minus1 = join                

-- Gets stuck ???
--test_div'2 : div' 1 0 = 1
--test_div'2 = join

{- TODO: better error msg:

div' : Nat -> Nat -> Nat
div' = \m n .
       let p [p_def] = (\w.Nat : Nat -> Type 0) in -- constNat
       let f [f_def] = ((\m g . case m [m_eq] of
         Zero    -> conv Zero by (join : Nat = p m) at h.h
         Succ m' -> Succ (g (minus (Succ m') (Succ n)) (s_minus_s__lt m' n))
-- this causes error message unrelated to real problem.  modifying
-- tc code to print first error reveals problem:
--         Succ m' -> Succ (g (minus (Succ m') (Succ n)) (s_minus_s__lt m' n))
-- this reveals real problem, even with orig tc code:
--         Succ m' -> let recurse [_] = (g (minus (Succ m') (Succ n)) (s_minus_s__lt m' n)) in
--                    Succ recurse
                   ) : ((m:Nat) -> ((m_minus_sn:Nat) -> LT (m_minus_sn) m -> p m_minus_sn) -> p m))
       in f
-}

-- Addition
-- --------
    
-- First with primrec
  
-- Need a predicate with constant value Nat.
--
-- Can build one from const, but it's too much trouble to use ...
const : [aT:Type 1] -> [bT:Type 0] -> (a:aT) -> (b:bT) -> aT
const = \[aT] [bT] a b.a

-- ... it's better to specialize const
constNat : (w:Nat) -> Type 0
constNat = \w.Nat

-- Now get addition, a heavily conv'd version of
--
--   add' = \m. primrec [constNat] m (\n.\add_m_n.Succ add_m_n)
add' : (m:Nat) -> (n:Nat) -> Nat
add' = 
  \m. \n. 
  -- I don't know how (or if it's even possible, since we don't have
  -- extensionality?) to prove equality of arrow types for the
  -- n-eta-reduced version, but it's easy to conv the body of the
  -- n-eta-expanded version:
    conv
      (primrec
        [constNat]
        (conv m by (join: Nat = (constNat 0)) at x.x)
        (\n.\mn.conv (Succ (conv mn by (join: (constNat n) = Nat) at x.x))
                  by (join: Nat = (constNat (Succ n))) at x.x)
        n)
      by (join: (constNat n) = Nat) at x.x
-- trellys can't infer type for [\w.Nat] and annotation causes parse
-- error in my first attempt:
--
--   add' = \m. primrec [\w.Nat : ((w:Nat) -> Type 0)] m (\n.\mn.Succ mn)
--
-- Is this a bug? I'll create a separate, simpler, example ...
-- ... UPDATE: I can't find a simple version, maybe I imagined the problem :P


-- Then with foldNat, which is much easier.
add'' : (m:Nat) -> (n:Nat) -> Nat
add'' = \m. foldNat [Nat] m (\mn.Succ mn)


-- Ackermann
-- ---------

-- primrec version
--
-- left as an exercise for the reader ... may the conv be with you.

-- foldNat version
ack : (m:Nat) -> (n:Nat) -> Nat
ack = foldNat [(w:Nat) -> Nat] (\n.Succ n)
        (\a_m. foldNat [Nat] (a_m 1) (\a_Sm_n. a_m a_Sm_n))

-- recnat version
ack' : (m:Nat) -> (n:Nat) -> Nat
ack' = recnat a m =
  case m [meq] of
    Zero    -> \n. Succ n
    Succ m' -> recnat am n =
      case n [neq] of
        Zero    -> a m' [meq] 1
        Succ n' -> a m' [meq] (am n' [neq])
