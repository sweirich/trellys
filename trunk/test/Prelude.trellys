module Prelude where

data Bool -> Type 0 where
  True : Bool
  False : Bool


data Nat -> Type 0 where
    Zero : Nat
    Succ : (x : Nat) => Nat


-- I'm not sure, but I think generally we can make all
-- proof arguments run-time (since we don't plan to
-- actually run proofs). So I changed some arguments
-- from compile-time to run-time. AS.

-- But this is inconvenient when proving equalities.  You want the
-- arguments to these lemmas to be erased, because you want to use
-- eraseable things in them.  CJC

-- Do we have an example where we care that the arguments are erasable?
-- My intution is that these proofs should only be used in two contexts:
-- as the argument to conv (where they are erased), or as lemmas to build
-- other proofs (so in erasable positions, so the arguments can be runtime). VS

-- SCW: I don't think that we care whether the arguments to sym/trans
-- etc are compiletime or runtime. All equality proofs are irrelevant
-- as the definition of irr below shows. (i.e. even if you use trans'
-- to produce an equality proof, you can still erase it with irr
-- below.) So I think we should just use runtime only arguments for
-- simplicity.


sym : (aTy : Type 0) -> (bTy : Type 0) -> (a : aTy) -> (b : bTy)  -> (p : a = b) -> (b = a)
sym = \ aTy bTy a b p . 
           conv (join 1 : a = a) by p at x.x = a

sym1 : (aTy : Type 1) -> (bTy : Type 1) -> (a : aTy) -> (b : bTy)  -> (p : a = b) -> (b = a)
sym1 = \ aTy bTy a b p . 
           conv (join 1 : a = a) by p at x.x = a

trans : [aTy : Type 0] -> [bTy : Type 0] -> [cTy : Type 0] ->
        [a : aTy] -> [b : bTy] -> [c : cTy] ->
				[p : a = b] -> [q : b = c] -> (a = c)
trans = \ [aTy] [bTy] [cTy] [a] [b] [c] [p] [q] .
             conv join 0 
               by (conv p by q at h.a = h)
               at h.a = h
-- The more natural definition of trans is:
--    conv p by q at h.a = h
-- But this forces p to be a runtime argument to trans, which is
-- annoying

trans1 : (aTy : Type 1) -> (bTy : Type 1) -> (cTy : Type 1) ->
         (a : aTy) -> (b : bTy) -> (c : cTy) ->
				(p : a = b) -> (q : b = c) -> (a = c)
trans1 = \ aTy bTy cTy a b c p q .
             conv q by (sym1 aTy bTy a b p) at x.x = c

trans' : (aTy : Type 0) -> (bTy : Type 0) -> (cTy : Type 0) ->
         (a : aTy) -> (b : bTy) -> (c : cTy) ->
				(p : a = b) -> (q : b = c) -> (a = c)
trans' = \ aTy bTy cTy a b c p q .
             conv join 0 
               by (conv p by q at h.a = h)
               at h.a = h


trans4' : (aTy : Type 0) -> (bTy : Type 0) -> (cTy : Type 0) -> (dTy : Type 0) -> 
         (a : aTy) -> (b : bTy) -> (c : cTy) -> (d : dTy) -> 
				(p : a = b) -> (q : b = c) -> (r : c = d) -> (a = d)
trans4' = \ aTy bTy cTy dTy a b c d p q r . 
		    trans' aTy cTy dTy a c d
             (trans' aTy bTy cTy a b c p q) r

-- Irrelevance for equality types

irr : [aTy : Type 0] -> [a:aTy] -> [bTy:Type 0] -> [b:bTy] -> [p: a = b] -> (a = b)
irr = \ [aTy][a][bTy][b][p] . 
	 conv join 0 by p at x . a = x


-- Existential types.

data Exists (a : Type 0) (p : (x:a) -> Type 0) -> Type 0 where
  Ex : [x : a] -> (witness : p x) -> Exists a p

-- Unit

data Unit -> Type 0 where
  U : Unit

-- Void

data Void -> Type 0 where
  