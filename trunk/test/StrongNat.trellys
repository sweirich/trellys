module StrongNat where

import Prelude
import Arithmetic
import Logic

-- * Less-than relation on Nat
--   -------------------------

-- cf. Arithmetic.lt
--
-- Is it easier to use (lt m n = True) ?  And what about the alternate
-- ADT characterization derived below in lemmas m_lt_Sm and lt_inc?
-- I.e., what if we instead define
{-
data LT [m:Nat] [n:Nat] -> Type 0 where
  LBase : [n = Succ m] -> LT m n
  LStep : [n':Nat] -> [n = Succ n']
       -> [LT m n'] -> LT m n
-}
-- and then derive the current LT constructors as lemmas?
data LT [m:Nat] [n:Nat] -> Type 0 where
  LZ : [m = Zero]
    -> (n':Nat) -> [n = Succ n']
    -> LT m n
  LS : (m':Nat) -> [m = Succ m']
    -> (n':Nat) -> [n = Succ n']
    -> (LT m' n') -> LT m n


-- * Misc lemmas (probably belong in a different lib)
--   ------------------------------------------------

-- [a = b] -> a = b
--
-- Promote erased equality to run-time equality.
--
-- Useful with erased equalities generated by case matches.
uneraseEq : (aTy:Type 0) -> (bTy:Type 0) -> (a:aTy) -> (b:bTy) -> [a = b] -> a = b
uneraseEq = \_ _ a b [eq] . conv (join : a = a) by eq at h. a = h

-- S m = S n -> m = n
--
-- Poor man's inversion.
--
-- This strategy provides inversion for any trellys types: join and a
-- projection function (here pred).
sm_eq_Sn__m_eq_n : (m:Nat) -> (n:Nat) -> (Succ m = Succ n) -> m = n
sm_eq_Sn__m_eq_n = \m n sm_eq_Sn .
  let pSm_eq_m [_]   = (join : pred (Succ m) = m) in
  let pSn_eq_n [_]   = (join : pred (Succ n) = n) in
  let pSm_eq_pSn [_] = (conv (join : pred (Succ m) = pred (Succ m))
                        by sm_eq_Sn at h.pred (Succ m) = pred h) in
  conv pSm_eq_pSn by pSm_eq_m, pSn_eq_n at hm hn.hm = hn


-- * Less-than lemmas
--   ----------------

-- The first two lemmas give an abstract version of LT

z_lt_Sn : (n : Nat) -> LT Zero (Succ n)
z_lt_Sn = \n . LZ [Zero] [Succ n] [join] n [join]

m_lt_n__Sm_lt_Sn : (m : Nat) -> (n : Nat) -> LT m n -> LT (Succ m) (Succ n)
m_lt_n__Sm_lt_Sn = \m n m_lt_n . LS [Succ m] [Succ n] m [join] n [join] m_lt_n

-- The next two lemmas give an alternate characterization of LT

-- m < n -> m < n+1
m_lt_n__m_lt_Sm : (m:Nat) -> (n:Nat) -> LT m n -> LT m (Succ n)
recnat m_lt_n__m_lt_Sm m = \n lt_p . case lt_p [_] of
  LZ [z_eq_m] _ [_]                       ->
--  LZ [m] [Succ n] [z_eq_m] n [join]
    conv (z_lt_Sn n)
    by (sym Nat Nat m Zero z_eq_m)
    at m.LT m (Succ n)
  LS m' [m_eq_Sm'] n' [n_eq_Sn'] m'_lt_n' ->
    let m'_lt_Sn' [_] = m_lt_n__m_lt_Sm m' [m_eq_Sm'] n' m'_lt_n' in
--  LS [m] [Succ n] m' [m_eq_Sm'] n [join] m'_lt_n
    conv (m_lt_n__Sm_lt_Sn m' (Succ n') m'_lt_Sn')
    by (sym Nat Nat m (Succ m') m_eq_Sm'),
       (sym Nat Nat n (Succ n') n_eq_Sn')
    at m n.LT m (Succ n)

-- m < S m
--
-- Every number is less than its successor
m_lt_Sm : (m:Nat) -> LT m (Succ m)
recnat m_lt_Sm m = case m [m_eq] of
  Zero    -> conv (z_lt_Sn Zero)
             by (sym Nat Nat m Zero m_eq)
             at m.LT m (Succ m)
  Succ m' -> conv (m_lt_n__Sm_lt_Sn m' (Succ m') (m_lt_Sm m' [m_eq]))
             by (sym Nat Nat m (Succ m') m_eq)
             at m.LT m (Succ m)

-- not (m < 0)
--
-- No number is less than zero
lt_0__contra : (m:Nat) -> (LT m Zero) -> (0 = 1)
lt_0__contra = \m p . case p [_] of
  -- both cases have (Zero = Succ _)
  LZ [_] _ [q]     -> contra q
  LS _ [_] _ [q] _ -> contra q

-- m < n -> exists n' . n = S n'
--
-- Trying to avoid doing this proof by contradiction over and over.
-- Abstracting it was more trouble than expected :P

-- Not sure how usable this version is: annotations and conv ...
m_lt_n__n_eq_SPn' : (m:Nat) -> (n:Nat) -> LT m n -> Exists Nat (\n'.n = Succ n' : Nat -> Type 0)
m_lt_n__n_eq_SPn' = \m n m_lt_n . case n [n_eq] of
  Zero    -> contra (lt_0__contra m (conv m_lt_n by n_eq at h.LT m h))
  Succ n' -> let eq [_] = uneraseEq Nat Nat n (Succ n') [n_eq] in
             Ex [Nat] [((\n'.n = Succ n') : Nat -> Type 0)]
                [n']  (conv eq by (join : (n = Succ n') = ((\n'.n = Succ n') : Nat -> Type 0) n') at h.h)

-- This version works well.
m_lt_n__n_eq_SPn : (m:Nat) -> (n:Nat) -> LT m n -> n = Succ (pred n)
m_lt_n__n_eq_SPn = \m n m_lt_n . case n [n_eq] of
  Zero    -> contra (lt_0__contra m (conv m_lt_n by n_eq at h.LT m h))
  Succ n' -> let e1 [_] = (conv (join : n' = pred (Succ n'))
                           by (sym Nat Nat n (Succ n') n_eq)
                           at h.n'= pred h
                        : n' = pred n) in
             let e2 [_] = uneraseEq Nat Nat n (Succ n') [n_eq] in
             conv e2 by e1 at h.n = Succ h

-- m + 1 < n + 1 -> m < n
--
-- This can be abstracted over LT by providing an LT fold
-- corresponding to casing on LT, but an lt based LT will allow an
-- easy proof by join.
sm_lt_Sn__m_lt_n : (m:Nat) -> (n:Nat) -> LT (Succ m) (Succ n) -> LT m n
sm_lt_Sn__m_lt_n = \m n sm_lt_Sn . case sm_lt_Sn [_] of
  LZ [m_eq] _ [_] -> contra m_eq
  -- The need for conversion here surprised me.
  LS m' [m_eq] n' [n_eq] lt -> let [m'_eq_m] [_] = sym Nat Nat m m' (sm_eq_Sn__m_eq_n m m' m_eq) in
                               let [n'_eq_n] [_] = sym Nat Nat n n' (sm_eq_Sn__m_eq_n n n' n_eq) in
                               conv lt by m'_eq_m, n'_eq_n at hm hn.LT hm hn

-- l < m /\ m < S n' -> l < n'
--
-- Proof idea (P = pred):
--
--   l < m -> m = S (P m)
-- so
--   m < S n' = S (P m) < S n'
-- and
--   P m < n' -> n' = S (P n')
-- now
--   case l of
--     Z    -> LZ using n' = S (P n')
--     S l' -> then S l' < S (P m) -> l' < P m and so
--             LS using (recursion on l' (P m) (P n'))
lt_trans_pred' : (l:Nat) -> (m:Nat) -> (n':Nat) -> LT l m -> LT m (Succ n') -> LT l n'
recnat lt_trans_pred' l = \m n' l_lt_m m_lt_Sn' .
  let m_eq [_]     = m_lt_n__n_eq_SPn l m l_lt_m in -- m = S (P m)
  let pm_lt_n' [_] = sm_lt_Sn__m_lt_n (pred m) n'
                     (conv m_lt_Sn' by m_eq at h.LT h (Succ n')) in -- P m < n'
  let n'_eq [_]    = m_lt_n__n_eq_SPn (pred m) n' pm_lt_n' in -- n' = S (P n')
  case l [l_eq] of
    Zero    -> conv (z_lt_Sn (pred n'))
               by (sym Nat Nat l Zero l_eq),
                  (sym Nat Nat n' (Succ (pred n')) n'_eq)
               at l n'.LT l n'
    Succ l' -> let l'_lt_pm [_]   = sm_lt_Sn__m_lt_n l' (pred m)
                                    (conv l_lt_m by l_eq, m_eq at hl hm.LT hl hm) in -- l' < P m
               let pm_lt_SPn' [_] = conv pm_lt_n' by n'_eq at h.LT (pred m) h in -- P m < S (P n')
               let l'_lt_Pn' [_]  = lt_trans_pred' l' [l_eq] (pred m) (pred n') l'_lt_pm pm_lt_SPn' in -- l' < P n'
               LS [l] [n'] l' [l_eq] (pred n') [n'_eq] l'_lt_Pn'

lt_trans_pred : (l:Nat) -> (m:Nat) -> (n:Nat) -> LT l m -> LT m n -> LT l (pred n)
lt_trans_pred = \l m n l_lt_m m_lt_n .
  lt_trans_pred' l m (pred n)
                 l_lt_m
                 (conv m_lt_n by (m_lt_n__n_eq_SPn m n m_lt_n) at h.LT m h) -- LT m (pred n)

{- This wasn't used in second version of StrongNat, so it was never
   ported, but I'll keep it around to port later ...

-- One of
--
-- m < S n -> m < n \/ m = n
--
-- m < n -> m < pred n \/ m = pred n
--
-- m < n -> m <= pred n                (for some relation (<=))

-- An obvious fact with an exceptionally tedious proof ... anyone know
-- a simple version?
--
-- Proof by induction on m.  Idea is
--
--   case m of
--     Z    -> easy case on n.
--     S m' -> case m < S n of
--       m = Z  -> contradiction.
--       m = S m' /\ n = S n' /\ m' < n' -> case n' of
--         Z     -> contradiction
--         S n'' -> IH on m' < S n'' gives m' = n'' \/ m' < n'',
--                                   and in either case apply S to both sides.
-- details involve a few convs ...

--   case m of
--     Z    -> easy case on n.
--     S m' -> case m < S n of
--       m = Z  -> contradiction.
--       m = S m' /\ n = S n' /\ m' < n' -> case n' of
--         Z     -> contradiction
--         S n'' -> IH on m' < S n'' gives m' = n'' \/ m' < n'',
--                                   and in either case apply S to both sides.


lt__lteq' : [m:Nat] -> [n:Nat] -> [LT m (Succ n)]
        -> Or (LT m n) (n = m)
                    -- (m = n) is more natural, but then need sym
                    -- below in strongNat. This is evidence of the
                    -- usefulness of convrl
lt__lteq' = recnat lt__lteq [m] = \[n] [m_lt_Sn] .
  case m [m_eq] of
    Zero    -> case n [n_eq] of
      Zero    -> InR [LT m n] [n = m]
                     (conv (join:0=0) by (sym Nat Nat n Zero n_eq),
                                         (sym Nat Nat m Zero m_eq)
                      at n m.n = m)
      Succ n' -> InL [LT m n] [n = m]
                     (LZ [m] [n] [sym Nat Nat m Zero m_eq] [n'] [n_eq])
    Succ m' -> case m_lt_Sn [_] of
      LZ [z_eq_m] [n'] [sn_eq_Sn']                   ->
        contra (conv z_eq_m by m_eq at h.Zero = h)
      LS [m'] [m_eq_Sm'] [n'] [sn_eq_Sn'] [m'_lt_n'] ->
        case n' [n'_eq] of
          Zero     -> poe [Or (LT m n) (n = m)]
                          [lt_0__F [m'] [conv m'_lt_n' by n'_eq at h.LT m' h]]
          Succ n'' -> let n'_eq_n [_] = (sym Nat Nat n n' (sm_eq_Sn__m_eq_n n n' sn_eq_Sn')) in
                      case (lt__lteq [m'] [m_eq_Sm'] [n'']
                                     [conv m'_lt_n' by n'_eq at h.LT m' h]) [_] of
                        InL m'_lt_n'' ->
                          InL [LT m n] [n = m]
                              (conv (LS [m] [n'] [m'] [m_eq_Sm'] [n''] [n'_eq] [m'_lt_n''])
                               by n'_eq_n at h.LT m h)
                        InR n''_eq_m' ->
                          InR [LT m n] [n = m]
                              (let e1 [_] = conv n'_eq by n'_eq_n at h.h = Succ n'' in
                               let e2 [_] = conv e1 by n''_eq_m' at h.n = Succ h in
                               conv e2 by (sym Nat Nat m (Succ m') m_eq_Sm') at h.n = h)

{- And here's the earlier version of StrongNat -}

-- Strong elimination / course-of-values induction / structural
-- induction: allows recursion on any structural subterm, not just the
-- predecessor.
strongNat : [p:Nat -> Type 0]
         -> ((n:Nat) -> ((m:Nat) -> [LT m n] -> p m) -> p n)
         -> ((n:Nat) -> p n)
strongNat = \[p] f .
  -- g n : (m:Nat) -> LT m n -> p m, and so proves p n via f
  let g [_] = ((recnat g n = case n [eq_n] of
    -- m < 0, a contradiction
    Zero    -> \m [lt_p] .
      poe [p m] [lt_0__F [m] [conv lt_p by eq_n at h.LT m h]]
    -- m < S n' -> m < n' \/ m = n'
    Succ n' -> \m [lt_p] .
      case (lt__lteq [m] [n'] [conv lt_p by eq_n at h.LT m h]) [_] of
        -- m < n', so g n' recursively proves p m
        InL lt_p'  -> g n' [eq_n] m [lt_p']
        -- n' = m, so f proves p m via g n'
        InR n_eq_m -> (conv (f n' (g n' [eq_n])) by n_eq_m at h.p h)
           -- this is g's type annotation, is there a better way to do
           -- this?
           ): (n:Nat) -> ((m:Nat) -> [LT m n] -> p m))
  in \n . f n (g n)
-}


-- * Strong induction
--   ----------------

-- Strong elimination / course-of-values induction / structural
-- induction: allows recursion on any structural subterm, not just the
-- predecessor.
--
-- Took a few iterations, but I'm quite happy with the current
-- version: strongNat erases to
--
--   sn := \ f . let g = (rec g . \ n . \ m . f m (g m))
--               in                     \ n . f n (g n)
--
-- which is "equivalent", as an untyped lambda term, to
--
--   Y o flip
--
-- for (o) = compose.
--
-- This is not surprising: strong elimination takes an f of the form
--
--   f := \ n g . body g,
--
-- where g is used in recursive positions in body, and produces a
-- version of f that calls itself recursively, i.e.
--
--   sn f = \ n . body (sn f)
--
-- Hence
--
--   sn f = Y (\ g n . body g)
--        = Y (flip (\ n g . body g))
--        = Y (flip f)
--
-- Details for the above term sn: let
--
--   Y g   = g (Y g) -- E.g. \g . U (g o U), for U g = g g
--   K x y = x
--
-- then we can rewrite sn as
--
--   \ f . let g = \g . K (\ m . f m (g m))
--         in              \ n . f n (Y g n)
--
-- where
--
--   \ n . f n (Y g n) =   \ n . f n (g (Y g) n)
--                     =   \ n . f n (\ m . f m (Y g m))
--                     =   flip f    (\ m . f m (Y g m))
--
-- and so \n . f n (Y g n) is a fixed point of flip f, and so,
-- assuming the equivalence of fixed points, we get
--
--   sn = Y o flip.
strongNat : [p:Nat -> Type 0]
         -> ((n:Nat) -> ((m:Nat) -> [LT m n] -> p m) -> p n)
         -> ((n:Nat) -> p n)
strongNat = \[p] f .
  -- g _ n _ : (m:Nat) -> LT m n -> p m, and so proves p n via f
  let g [_] = ((recnat g [i] = \n [n_lt_i] m [m_lt_n] .
    let [i_eq] [_]    = m_lt_n__n_eq_SPn n i n_lt_i in                  -- i = S i'
    let [m_lt_i'] [_] = lt_trans_pred m n i m_lt_n n_lt_i in -- m < i'
    f m (g [pred i] [i_eq] m [m_lt_i'])
           ): [i:Nat] -> (n:Nat) -> [LT n i] -> ((m:Nat) -> [LT m n] -> p m))
  in \n . f n (g [Succ n] n [m_lt_Sm n])


-- * Less-than + arithmetic lemmas
--   -----------------------------

-- (m+1) - (n+1) < m+1
s_minus_s__lt : (m:Nat) -> (n:Nat) -> LT (minus (Succ m) (Succ n)) (Succ m)
recnat s_minus_s__lt m = \n. case m [m_eq] of
  Zero    -> let e1 [_] = conv (join : Zero = minus (Succ Zero) (Succ n))
                          by (sym Nat Nat m Zero m_eq)
                          at m.Zero = minus (Succ m) (Succ n) in
             conv (z_lt_Sn m)
             by e1
             at minus_Sm_Sn.LT minus_Sm_Sn (Succ m)
  Succ m' -> case n [n_eq] of
    Zero    -> let e1 [_] = conv (join : minus m Zero = (minus (Succ m) (Succ Zero)))
                            by (lemma_minus_zero_id m) at h.h = minus (Succ m) (Succ Zero) in
               let e2 [_] = conv e1 by (sym Nat Nat n Zero n_eq)
                            at h.m = (minus (Succ m) (Succ h)) in
               conv (m_lt_Sm m) by e2 at h.LT h (Succ m)
    Succ n' -> let e1 [_] = conv (s_minus_s__lt m' [m_eq] n')
                            by (sym Nat Nat m (Succ m') m_eq),
                               (sym Nat Nat n (Succ n') n_eq)
                            at m n.LT (minus m n) m in
               let e2 [_] = (join : minus m n = minus (Succ m) (Succ n)) in
               let e3 [_] = conv e1 by e2 at h.LT h m in
               m_lt_n__m_lt_Sm (minus (Succ m) (Succ n)) m e3


-- * Logical division
--   ----------------

-- cf. Arithmetic.div
--
-- m `div` n = \ceiling{ m / S n }

-- Define the predicate here to avoid need for let defs in context
p : Nat -> Type 0
p = \w.Nat

div' : Nat -> Nat -> Nat
div' = \m n .
--       let p [p_def] = (\w.Nat : Nat -> Type 0) in -- constNat
       let f [f_def] = ((\m g . case m [m_eq] of
         Zero    -> conv Zero by (join : Nat = p m) at h.h
         Succ m' -> let [lt_p] [_] = conv (s_minus_s__lt m' n)
                                   by (sym Nat Nat m (Succ m') m_eq)
                                   at m.LT ((minus (Succ m') (Succ n))) m in
                    let recg [_] = conv (g (minus (Succ m') (Succ n)) [lt_p])
                                   by (join : p (minus (Succ m') (Succ n)) = Nat)
                                   at h.h in
                    conv (Succ recg) by (join : Nat = p m) at h.h
                   ) : ((m:Nat) -> ((m_minus_sn:Nat) -> [LT (m_minus_sn) m] -> p m_minus_sn) -> p m))
       in conv (strongNat [p] f m) by (join : p m = Nat) at h.h

-- Tests
test_div'1 : div' 0 0 = 0
test_div'1 = join

test_div'2 : div' 1 0 = 1
test_div'2 = join

test_div'3 : div' 10 1 = 5
test_div'3 = join 1000

test_div'4 : div' 10 2 = 4
test_div'4 = join

test_div'5 : div' 10 3 = 3
test_div'5 = join
