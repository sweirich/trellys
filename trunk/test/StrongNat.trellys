module StrongNat where

import Prelude
import Arithmetic
import Logic

data LT [m:Nat] [n:Nat] -> Type 0 where
  LZ : [m = Zero]
    -> (n':Nat) -> [n = Succ n']
    -> LT m n
  LS : (m':Nat) -> [m = Succ m']
    -> (n':Nat) -> [n = Succ n']
    -> (LT m' n') -> LT m n

-- Every number is less than its successor
m_lt_Sm : (m:Nat) -> LT m (Succ m)
recnat m_lt_Sm m = case m [m_eq] of
  Zero    -> let [m_eq'] [_] = sym Nat Nat m Zero m_eq in
             conv (LZ [m] [Succ Zero] [m_eq] Zero [join])
             by m_eq' at h.LT m (Succ h)
  Succ m' -> let rec_ [_] = conv (m_lt_Sm m' [m_eq])
                            by (sym Nat Nat m (Succ m') m_eq)
                            at h.LT m' h in
             LS [m] [Succ m] m' [m_eq] m [join] rec_

-- No number is less than zero
lt_0__F : (m:Nat) -> (LT m Zero) -> Void
lt_0__F = \m p . case p [_] of
  -- both cases have (Zero = Succ _)
  LZ [_] _ [q]         -> contra q
  LS _ [_] _ [q] _ -> contra q

-- Promote erased equality to run-time equality.
--
-- Useful with erased equalities generated by case matches.
uneraseEq : (aTy:Type 0) -> (bTy:Type 0) -> (a:aTy) -> (b:bTy) -> [a = b] -> a = b
uneraseEq = \_ _ a b [eq] . conv (join : a = a) by eq at h. a = h

-- m < n -> exists n' . n = S n'
--
-- Trying to avoid doing this proof by contradiction over and over.
-- Abstracting it was more trouble than expected :P

-- Not sure how usable this version is: annotations and conv ...
lt__S' : (m:Nat) -> (n:Nat) -> LT m n -> Exists Nat (\n'.n = Succ n' : Nat -> Type 0)
lt__S' = \m n m_lt_n . case n [n_eq] of
  Zero    -> poe [Exists Nat (\n'.n = Succ n' : Nat -> Type 0)] [lt_0__F m (conv m_lt_n by n_eq at h.LT m h)]
  Succ n' -> let eq [_] = uneraseEq Nat Nat n (Succ n') [n_eq] in
             Ex [Nat] [((\n'.n = Succ n') : Nat -> Type 0)]
                [n']  (conv eq by (join : (n = Succ n') = ((\n'.n = Succ n') : Nat -> Type 0) n') at h.h)

-- This version works well.
lt__S : (m:Nat) -> (n:Nat) -> LT m n -> n = Succ (pred n)
lt__S = \m n m_lt_n . case n [n_eq] of
  Zero    -> poe [n = Succ (pred n)] [lt_0__F m (conv m_lt_n by n_eq at h.LT m h)]
  Succ n' -> let e1 [_] = (conv (join : n' = pred (Succ n'))
                           by (sym Nat Nat n (Succ n') n_eq)
                           at h.n'= pred h
                        : n' = pred n) in
             let e2 [_] = uneraseEq Nat Nat n (Succ n') [n_eq] in
             conv e2 by e1 at h.n = Succ h

-- Poor man's inversion
--
-- S m = S n -> m = n
--
-- This strategy provides inversion for any trellys types: join and a
-- projection function (here pred).
eqS__eq : (m:Nat) -> (n:Nat) -> (Succ m = Succ n) -> m = n
eqS__eq = \m n sm_eq_Sn .
  let pSm_eq_m [_]   = (join : pred (Succ m) = m) in
  let pSn_eq_n [_]   = (join : pred (Succ n) = n) in
  let pSm_eq_pSn [_] = (conv (join : pred (Succ m) = pred (Succ m))
                        by sm_eq_Sn at h.pred (Succ m) = pred h) in
  conv pSm_eq_pSn by pSm_eq_m, pSn_eq_n at hm hn.hm = hn

-- m + 1 < n + 1 -> m < n
ltSS__lt : (m:Nat) -> (n:Nat) -> LT (Succ m) (Succ n) -> LT m n
ltSS__lt = \m n sm_lt_Sn . case sm_lt_Sn [_] of
  LZ [m_eq] _ [_] -> contra m_eq
  -- The need for conversion here surprised me.
  LS m' [m_eq] n' [n_eq] lt -> let [m'_eq_m] [_] = sym Nat Nat m m' (eqS__eq m m' m_eq) in
                               let [n'_eq_n] [_] = sym Nat Nat n n' (eqS__eq n n' n_eq) in
                               conv lt by m'_eq_m, n'_eq_n at hm hn.LT hm hn

-- l < m /\ m < S n' -> l < n'
--
-- Proof idea (P = pred):
--
--   l < m -> m = S (P m)
-- so
--   m < S n' = S (P m) < S n'
-- and
--   P m < n' -> n' = S (P n')
-- now
--   case l of
--     Z    -> LZ using n' = S (P n')
--     S l' -> then S l' < S (P m) -> l' < P m and so
--             LS using (recursion on l' (P m) (P n'))
lt_trans_pred : (l:Nat) -> (m:Nat) -> (n':Nat) -> LT l m -> LT m (Succ n') -> LT l n'
recnat lt_trans_pred l = \m n' l_lt_m m_lt_Sn' .
  let m_eq [_] = lt__S l m l_lt_m in -- m = S (P m)
  let pm_lt_n' [_] = ltSS__lt (pred m) n' (conv m_lt_Sn' by m_eq at h.LT h (Succ n')) in -- P m < n'
  let n'_eq [_] = lt__S (pred m) n' pm_lt_n' in -- n' = S (P n')
  case l [l_eq] of
    Zero    -> LZ [l] [n'] [l_eq] (pred n') [n'_eq]
    Succ l' -> let l'_lt_pm [_]   = ltSS__lt l' (pred m) (conv l_lt_m by l_eq, m_eq at hl hm.LT hl hm) in -- l' < P m
               let pm_lt_SPn' [_] = conv pm_lt_n' by n'_eq at h.LT (pred m) h in -- P m < S (P n')
               let l'_lt_Pn' [_]  = lt_trans_pred l' [l_eq] (pred m) (pred n') l'_lt_pm pm_lt_SPn' in -- l' < P n'
               LS [l] [n'] l' [l_eq] (pred n') [n'_eq] l'_lt_Pn'

-- Strong elimination / course-of-values induction / structural
-- induction: allows recursion on any structural subterm, not just the
-- predecessor.
strongNat : [p:Nat -> Type 0]
         -> ((n:Nat) -> ((m:Nat) -> [LT m n] -> p m) -> p n)
         -> ((n:Nat) -> p n)
strongNat = \[p] f .
  -- g _ _ n : (m:Nat) -> LT m n -> p m, and so proves p n via f
  let g [_] = ((recnat g i = \n [n_lt_i] m [m_lt_n] . case i [eq_i] of
    -- n < 0, a contradiction
    Zero    ->
      poe [p m] [lt_0__F n (conv n_lt_i by eq_i at h.LT n h)]
    -- n < S i' /\ m < n -> m < i' and we can recurse on i'
    Succ i' ->
      let [n_lt_Si'] [_] = conv n_lt_i by eq_i at h.LT n h in
      let [m_lt_i'] [_] = lt_trans_pred m n i' m_lt_n n_lt_Si' in
      f m (g i' [eq_i] m [m_lt_i'])
           -- making i erased would disallow the case on i above and
           -- probably complicate things considerably ...
           ): (i:Nat) -> (n:Nat) -> [LT n i] -> ((m:Nat) -> [LT m n] -> p m))
  in \n . f n (g (Succ n) n [m_lt_Sm n])


-- Subtraction makes things smaller
axiom s_minus_s__lt : (m:Nat) -> (n:Nat) -> LT (minus (Succ m) (Succ n)) (Succ m)
-- Logical division
--
-- cf. Arithmetic.div
--
-- m `div` n = \ceiling{ m / S n }
p : Nat -> Type 0
p = \w.Nat

div' : Nat -> Nat -> Nat
div' = \m n .
--       let p [p_def] = (\w.Nat : Nat -> Type 0) in -- constNat
       let f [f_def] = ((\m g . case m [m_eq] of
         Zero    -> conv Zero by (join : Nat = p m) at h.h                        -- relies on let defs in context
         Succ m' -> let [lt_p] [_] = conv (s_minus_s__lt m' n)
                                   by (sym Nat Nat m (Succ m') m_eq)
                                   at m.LT ((minus (Succ m') (Succ n))) m in
                    let recg [_] = conv (g (minus (Succ m') (Succ n)) [lt_p])
                                   by (join : p (minus (Succ m') (Succ n)) = Nat) -- relies on let defs in context
                                   at h.h in
                    conv (Succ recg) by (join : Nat = p m) at h.h                 -- relies on let defs in context
                   ) : ((m:Nat) -> ((m_minus_sn:Nat) -> [LT (m_minus_sn) m] -> p m_minus_sn) -> p m))
       in conv (strongNat [p] f m) by (join : p m = Nat) at h.h                   -- relies on let defs in context

-- Tests
test_div'1 : div' 0 0 = 0
test_div'1 = join

test_div'2 : div' 1 0 = 1
test_div'2 = join

test_div'3 : div' 10 1 = 5
test_div'3 = join 1000

test_div'4 : div' 10 2 = 4
test_div'4 = join

test_div'5 : div' 10 3 = 3
test_div'5 = join
