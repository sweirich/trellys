-- Shows how a termination proof can be used to prove equalities
-- arising from linearization in response to the PP value restriction.
--
-- These equalities don't arise if the PP value restriction is
-- dropped, and can be worked around without proving termination if
-- the let-P-in-L value restriction is dropped (just let bind to get
-- the termination equality).
--
-- See
-- https://groups.google.com/group/trellys-team/msg/ab966d88c44ca03b?dmode=source
-- for the context of the contrived theorem t and a claim that t can't
-- be proved in PP value restricted trellys :)
--
-- See ProgrammaticCdiv for a real termination proof (here we
-- just admit).
module TerminationAsValueRestrictionWorkaround where
import Prelude

axiom prog p : Nat -> Nat
ex : Nat -> Nat -> Type 0
ex = \m . (\v . p m = v)
ex_red : (m:Nat) -> (v:Nat) -> (ex m v) = (p m = v)
ex_red = \m v . join
axiom p_terminates : (m:Nat) -> Exists Nat (ex m)
t : (m:Nat) ->
  (let prog d [_] =
     let prog r [_] = p m
     in Succ r
   in d)
   =
  (let prog d [_] =
     let prog r [_] = p m
     in r
   in Succ d)
t = \m . case (p_terminates m) [_] of
  Ex [v] v_eq -> let v_eq' [_] = conv v_eq by (ex_red m v) at t.t
                 in let eql1 [_] = conv join by v_eq'
                                   at h . (let prog d [_] =
                                               let prog r [_] = p m
                                               in Succ r
                                           in d)
                                        =
                                           (let prog d [_] =
                                               let prog r [_] = h
                                               in Succ r
                                           in d)
                 in let eql2 [_] = (join: (let prog d [_] =
                                               let prog r [_] = v
                                               in Succ r
                                           in d)
                                        =
                                           Succ v)
                 in let eqr1 [_] = (join: Succ v
                                        =
                                        (let prog d [_] =
                                           let prog r [_] = v
                                           in r
                                         in Succ d))
                 in let eqr2 [_] = conv join by v_eq'
                                   at h . (let prog d [_] =
                                             let prog r [_] = h
                                             in r
                                           in Succ d)
                                        = (let prog d [_] =
                                             let prog r [_] = p m
                                             in r
                                           in Succ d)
                 in (conv eql1 by (conv eql2 by (conv eqr1 by eqr2 at h . Succ v = h)
                                  at h . (let prog d [_] =
                                               let prog r [_] = v
                                               in Succ r
                                           in d) = h)
                     at h . (let prog d [_] =
                                               let prog r [_] = p m
                                               in Succ r
                                           in d) = h)

-- Dependent pair.  Like Exists in Prelude, except with both
-- components run-time
data Exists' (xTy:Type 0) (p:xTy -> Type 0) -> Type 0 where
  Ex' : (x:xTy) -> (p x) -> Exists' xTy p
-- projections
fst : (p:Nat -> Type 0) -> (Exists' Nat p) -> Nat
fst = \p ex . case ex [_] of Ex' x _ -> x

snd : (p:Nat -> Type 0) -> (ex:Exists' Nat p) -> p (fst p ex)
snd = \p ex . case ex [ex_eq] of
  Ex' x px -> let    f_eq1 [_] = conv join by ex_eq at h . (fst p h) = (fst p ex)
              in let f_eq2 [_] = conv f_eq1 by (join : fst p (Ex' [Nat] [p] x px) = x)
                                 at h . h = (fst p ex)
              in conv px by f_eq2 at x . p x

{-
unwrap : (p:Nat -> Type 0) -> (ex:Exists' Nat p) -> (ex = Ex' [Nat] [p] (fst p ex) (snd p ex))
-}

-- Extensional equality specialized to Nat -> Nat and with first
-- argument P, second L
data Leibniz (prog f:Nat -> Nat) (g:Nat -> Nat) -> Type 0 where
  LeibnizEq : ((n:Nat) -> f n = g n) -> Leibniz f g

valOf : (Nat -> Nat) => Nat -> Nat -> Type 0
valOf = \f n . \ v . v = f n

-- specialize one value while keeping rest abstract to guide join
snd_valOf_red : (f:Nat -> Nat) => (n:Nat) -> (v:Nat)
             -> ((valOf f n) v = (v = f n))
snd_valOf_red = \f n v . join

-- Promote a terminating P function to an L function
promote : (f:Nat -> Nat) => ((n:Nat) -> Exists' Nat (valOf f n))
       -> Exists' (Nat -> Nat) (Leibniz f)
promote = \f tf .
  let g [g_eq] = (\n . fst (valOf f n) (tf n) -- fst . tf
               : Nat -> Nat)
  in let eq [_] = (\n .
    let    gn_eq1 [_] = conv join by g_eq at h . h n = g n
    in let gn_eq2 [_] =
      conv gn_eq1
      by (join : (\ n1 . fst (valOf f n1) (tf n1) : Nat -> Nat) n
               = fst (valOf f n) (tf n))
      at h . h = g n
    in let fn_eq1 [_] = conv (snd (valOf f n) (tf n))
                        by (snd_valOf_red f n (fst (valOf f n) (tf n)))
                        at t.t
    in conv gn_eq2 by fn_eq1 at h . h = g n
                : (n:Nat) -> f n = g n)
  in Ex' [Nat -> Nat] [Leibniz f] g (LeibnizEq [f] [g] eq)
