module Append where

import Prelude
import Vectors
import Arithmetic

plus0 : [n:Nat] -> n = plus 0 n
plus0 = \[n] . join 3

plusSucc : [n:Nat] -> [m:Nat] -> Succ (plus n m) = plus (Succ n) m
plusSucc = \[n] [m] . join 42

--Why is the type variable a not erased? Because (ind app [n]) is not a value. This should be revisited
-- when switching to 'quasi-implit' erasure.
append : (a: Type 0@log) -> [n:Nat] -> [m:Nat] -> (xs:Vector a n@log) -> (ys:Vector a m@log) -> Vector a (plus n m)
append = \a . ind app [n] = \[m] . \xs ys .
  case xs [p] of
    VNil [neq] ->
      let _ = (join : m = plus 0 m) in 
      ys
    VCons [n'] [neq] x xs' -> 
      let _ = (join : Succ (plus n' m) = plus (Succ n') m) in
      VCons [a] [Succ (plus n' m)] [plus n' m] [_] x (app [n'] [ord neq] [m] xs' ys)


appendAssociates : (a: Type 0@log) -> [i:Nat] -> [j:Nat] -> [k:Nat]
                   -> (xs:Vector a i@log) -> (ys:Vector a j@log) -> (zs:Vector a k@log)
                   -> append a [(plus i j)] [k] (append a [i] [j] xs ys) zs
                    = append a [i] [(plus j k)] xs (append a [j] [k] ys zs)

appendAssociates = \a . ind aa [i] = \[j] [k] xs ys zs .
  case xs [xseq] of
    VNil [ieq] ->  
      let _ = (join : append a [i] [j] (VNil [a] [i] [ieq]) ys
                      = ys) in     
      let _ = (join : append a [i] [plus j k] (VNil [a] [i] [ieq]) (append a [j] [k] ys zs)
                      = append a [j] [k] ys zs) in
      _

    VCons [i'] [ieq] x xs' ->
      let ih = aa [i'] [ord ieq] [j] [k] xs' ys zs in
      let unfold_append = (join :
			     append a [plus i j] [k] (append a [i] [j] (VCons [a] [i] [i'] [ieq] x xs') ys) zs
                             = VCons [a] [Succ (plus (plus i' j) k)] [plus (plus i' j) k] [(join : Succ (plus (plus i' j) k) = Succ (plus (plus i' j) k))] x 
                                 (append a [plus i' j] [k] (append a [i'] [j] xs' ys) zs)) in
      let unfold_append' = (join :
                             append a [i] [plus j k] (VCons [a] [i] [i'] [ieq] x xs') (append a [j] [k] ys zs)
                             = VCons [a] [Succ (plus i' (plus j k))] [plus i' (plus j k)] [(join : Succ (plus i' (plus j k)) =  Succ (plus i' (plus j k)))] x
                                 (append a [i'] [plus j k] xs' (append a [j] [k] ys zs))) in

      
      let example = (_ : (append a [i'] [plus j k] xs' (append a [j] [k] ys zs)) = (append a [plus i' j] [k] (append a [i'] [j] xs' ys) zs)) in
      _



