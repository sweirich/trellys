module Fin where

import Prelude

data Fin (n : Nat) : Type 0 where
  FZ of [m:Nat][ m_eq : (n = Succ m) ] 
  FS of [m:Nat][ m_eq : (n = Succ m) ](_ : Fin m)

fin_succ : [n : Nat] => [m:Nat] -> [ m_eq : (n = Succ m) ] -> (Fin m @ log) -> Fin n
fin_succ = \[n][m][m_eq] f . FS [m][m_eq] f

-- equality is decidable
log fin_eq : [n: Nat] -> (Fin n) -> (Fin n) -> Bool
fin_eq =  
 ind eq [n] = \fn1 fn2 .
   case fn1 [n1_eq], fn2 [_] of 
      FZ [m1][m1_eq], FZ [m2][m2_eq] -> True
      FS [m1][m1_eq] fn1', FS [m2][m2_eq] fn2' -> 
		   let _ = uneraseEq [Nat][Nat][m1][m2] [sm_eq_Sn__m_eq_n m1 m2 _] in
		   eq [m1] [ord m1_eq] fn1' ( fn2' : Fin m1 )
      _ , _ -> False

-- correctness of fin_eq
log fin_eq_True : [n: Nat] -> (i : Fin n) -> (j : Fin n) -> (fin_eq [n] i j = True) -> i = j
ind fin_eq_True [n] = \i j h.
  case i [_], j [_] of
      FZ [m1][m1_eq], FZ [m2][m2_eq] -> _
      FS [m1][m1_eq] i', FS [m2][m2_eq] j' -> 
        -- Note: unfold will not give the recursion equation on the next line. 
        let _ = (join : fin_eq [n] (FS [_][_] i') (FS [_][_] j') = fin_eq [m1] i' j') in
        let _ = fin_eq_True [m1] [ord m1_eq] i' j' _ in
          _
      FZ [m1][m1_eq], FS [m2][m2_eq] j' -> 
        unfold (fin_eq [n] (FZ [m1][_]) (FS [m2][_] j')) in
          contra (_ : True = False)
      FS [m1][m1_eq] i', FZ [m2][m2_eq] ->
        unfold (fin_eq [n] (FS [m1][_] i') (FZ [m2][_])) in
          contra (_ : True = False)

-- inject a fin into a larger set
log promote : [n:Nat] -> (Fin n) -> Fin (Succ n)
ind promote [n] = \ x .
  case x [x_eq] of 
    FZ [m][m_eq]    -> FZ [Succ m][_]
    FS [m][m_eq] m' -> FS [Succ m][_] (promote [m] [ord m_eq] m')

-- take advantage of heterogeneous equality
log promote_spec : [n:Nat] -> (x : Fin n) -> promote [n] x = x
ind promote_spec [n] = \ x. 
   case x [x_eq] of 
    FZ [m][m_eq]    -> 
	   -- explicit unfold of promote
	   let _ = (join : promote [n] (FZ [m][m_eq]) = 
		                  (FZ [Succ m][_] : Fin (Succ (Succ m)))) in
		_
    FS [m][m_eq] m' ->  
       let _ = promote_spec [m] [ord m_eq] m' in
		 let _ = (join : promote [n] (FS [m][m_eq] m') = 
		                 (FS [Succ m][_] (promote [m] m') : Fin (Succ (Succ m)))) in
       _
       
	  
-- compute the predecessor of the number
log fin_pred : [n:Nat] => Fin n -> Fin n
fin_pred = \ [n] x . 
  case x [x_eq] of 
     FZ [_][_] -> x 
     FS [m][m_eq] m' -> (promote [m] m')


