-- The standard list data type.

module List where
import Prelude
import Arithmetic
import LessThanNat_lt_eq_True

-- We fix @log throughout this file.
usually log

data List (a : Type 0) : Type 0 where
  Nil
  Cons of (x : a) (xs : List a)

map : [a : Type 0] => [b : Type  0] => (f : (x:a) -> b) -> 
      (xs : List a) -> List b
map = \ [a] [b] f . ind map xs = 
  case xs [xs_eq] of
    Nil -> Nil 
    Cons x xs -> Cons (f x) (map xs [ord xs_eq])

fold : [a: Type 0] => [b:Type 0] => (x : b) -> (f : a -> b -> b) -> List a -> b
fold = \[a] [b] n f . ind fold xs = 
  case xs [xs_eq] of 
    Nil -> n
    Cons x xs -> f x (fold xs [ord xs_eq]) 

null : [a : Type 0] => (List a @ log) -> Bool
null = \ [a] xs . case xs [_] of 
  Nil -> True
  Cons _ _ -> False

-- added @ log so that we can use in partial application
-- see Sat.trellys
all : [a : Type 0] => (a -> Bool) -> (List a @ log) -> Bool
all = \ [a] f . ind all xs = 
  case xs [xs_eq] of 
    Nil -> True
    Cons x xs -> and (f x) (all xs [ord xs_eq])

any : [a : Type 0] => (a -> Bool) -> (List a @ log) -> Bool
any = \ [a] f . ind any xs = 
  case xs [xs_eq] of 
    Nil -> False
    Cons x xs -> or (f x) (any xs [ord xs_eq])

filter : [a : Type 0] => (a -> Bool) -> (List a @ log) -> List a
filter = \ [a] f . ind filter xs = 
  case xs [xs_eq] of 
     Nil -> Nil
     Cons x xs -> case (f x) [_] of 
        True -> Cons x (filter xs [ord xs_eq])
        False -> filter xs [ord xs_eq]

elem : [a : Type 0] => (eq : a -> a -> Bool) -> a -> List a -> Bool
elem = \ [a] eqa x . ind elem xs = 
  case xs [xs_eq] of 
    Nil -> False
    Cons y ys -> or (eqa x y) (elem ys [ord xs_eq])


append : [a:Type 0] => (List a) -> (List a) -> List a
append = \[a]. ind append xs = \ys.
  case xs [xs_eq] of
    Nil -> ys
    Cons x xs -> Cons x (append xs [ord xs_eq] ys) 

concat : [a:Type 0] -> List (List a) -> List a 
concat = \ [a] . ind concat xss =
  case xss [xss_eq] of
    Nil -> Nil 
    Cons xs xss -> append xs (concat xss [ord xss_eq])

concatMap : [a : Type 0] => [b : Type  0] => (f : (x:a) -> List b) ->
      (xs : List a) -> List b
concatMap = \[a] [b] f xs . concat [b] (map f xs)

replicate : [a : Type 0] => Nat -> a -> List a
replicate = \[a] . ind replicate n = \ x .
  case n [neq] of 
    Zero -> Nil 
    Succ n -> Cons x (replicate n [ord neq] x)

length : [a:Type 0] => (List a) -> Nat
length = \[a]. ind length xs =
  case xs [xs_eq] of
    Nil -> Zero
    Cons x xs -> Succ (length xs [ord xs_eq])

nth : [a : Type 0] => Nat -> (List a) -> (default : a) -> a
nth = \[a]. ind nth n = \xs default.
 case xs [_] of
   Nil -> default
   Cons x xs' -> case n [n_eq] of 
                   Zero -> x
                   Succ n' -> nth n' [ord n_eq] xs' default

nth_safe : [a : Type 0] => (n : Nat) -> (xs : List a) -> [safe : lt n (length xs) = True] -> a
nth_safe = \[a]. ind nth_safe n = \xs [safe].
  case xs [_] of 
   Nil -> let _ = (join : lt n (length (Nil : List a)) = False) in
            contra (_ : True = False)
   Cons x xs' -> case n [n_eq] of 
                  Zero -> x
                  Succ n' ->  let _ = (join : length (Cons x xs')  = Succ (length  xs')) 
                              in nth_safe n' [ord n_eq] xs' [sm_lt_Sn__m_lt_n_LT n' (length xs') safe]
