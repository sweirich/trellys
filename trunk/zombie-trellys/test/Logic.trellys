module Logic where

import Prelude -- for Void

data And (xT:Type 0@log) (yT:Type 0@log) : Type 0 where
  And of (x:xT@log) (y:yT@log)

data Or (xT:Type 0@log) (yT:Type 0@log) : Type 0 where
  InL of (x:xT@log)
  InR of (y:yT@log)

-- Principle of explosion / ex falso quodlibet
--
-- NB: THIS IS REALLY STUPID: DON'T USE IT:
--
-- Notice that the body of poe simply invokes contra with *no type
-- annotation*.  The point is that contra *is* POE, except it's better
-- than this implementation, because the type checker can infer the
-- type you want, whereas POE requires the type as an argument.
--
-- Wherever you used Void and POE, use (0=1) and contra instead.
poe : [t:Type 0@log] -> [v:Void] -> t
-- A direct case on v, e.g.
--
--   \[_] [v] . case v [_] of {}
--
-- won't work, because v is free in the body.  But using v in a place
-- that's erased, to produce something that in turn produces t, works.
-- E.g.
--
--   \[t] [v] . conv U by (case v [_] of {} : Unit = t) at t.t
--
-- or

-- Well, actually this is also not accepted because contra is not considered a value.
--poe = \[_] [v] . contra (case v [_] of {} : 0 = 1)

-- So let's do
poe = \[t] [v] . conv (join : 0=0)
		   by (case v [_] of {} : (0=0) = t)
                   at x.x
