module Prelude where

data Bool : Type 0 where
  True 
  False

data Nat : Type 0 where
    Zero
    Succ of (x : Nat)

pred : Nat -> Nat
pred = \n . case n [_] of
  Zero -> Zero
  Succ n' -> n'

-- S m = S n -> m = n
--
-- Poor man's inversion.
--
-- This strategy provides inversion for any trellys types: join and a
-- projection function (here pred).
sm_eq_Sn__m_eq_n : (m:Nat) -> (n:Nat) -> (Succ m = Succ n) -> m = n
sm_eq_Sn__m_eq_n = \m n sm_eq_Sn .
  let pSm_eq_m [_]   = (join : pred (Succ m) = m) in
  let pSn_eq_n [_]   = (join : pred (Succ n) = n) in
  let pSm_eq_pSn [_] = (conv (join : pred (Succ m) = pred (Succ m))
                        by sm_eq_Sn at h.pred (Succ m) = pred h) in
  conv pSm_eq_pSn by pSm_eq_m, pSn_eq_n at hm hn.hm = hn

-- I'm not sure, but I think generally we can make all
-- proof arguments run-time (since we don't plan to
-- actually run proofs). So I changed some arguments
-- from compile-time to run-time. AS.

-- But this is inconvenient when proving equalities.  You want the
-- arguments to these lemmas to be erased, because you want to use
-- eraseable things in them.  CJC

-- Do we have an example where we care that the arguments are erasable?
-- My intution is that these proofs should only be used in two contexts:
-- as the argument to conv (where they are erased), or as lemmas to build
-- other proofs (so in erasable positions, so the arguments can be runtime). VS

-- SCW: I don't think that we care whether the arguments to sym/trans
-- etc are compiletime or runtime. All equality proofs are irrelevant
-- as the definition of uneraseEq below shows. (i.e. even if you use trans'
-- to produce an equality proof, you can still erase it with uneraseEq
-- below.) So I think we should just use runtime only arguments for
-- simplicity.


sym : (A : Type 0@prog) -> (B : Type 0@prog) -> (a : A@prog) -> (b : B@prog)  -> (p : a = b) -> (b = a)
sym = \ A B a b p . 
           conv (join 1 : a = a) by p at x.x = a

sym1 : (A : Type 1@prog) -> (B : Type 1@prog) -> (a : A@prog) -> (b : B@prog)  -> (p : a = b) -> (b = a)
sym1 = \ A B a b p . 
           conv (join 1 : a = a) by p at x.x = a

trans : [A : Type 0@prog] -> [B : Type 0@prog] -> [C : Type 0@prog] ->
        [a : A@prog] -> [b : B@prog] -> [c : C@prog] ->
				[p : a = b] -> [q : b = c] -> (a = c)
trans = \ [A] [B] [C] [a] [b] [c] [p] [q] .
             conv join 0 
               by (conv p by q at h.a = h)
               at h.a = h
-- The more natural definition of trans is:
--    conv p by q at h.a = h
-- But this forces p to be a runtime argument to trans, which is
-- annoying

trans1 : (A : Type 1@prog) -> (B : Type 1@prog) -> (C : Type 1@prog) ->
         (a : A@prog) -> (b : B@prog) -> (c : C@prog) ->
				(p : a = b) -> (q : b = c) -> (a = c)
trans1 = \ A B C a b c p q .
             conv q by (sym1 A B a b p) at x.x = c

trans' : (A : Type 0@prog) -> (B : Type 0@prog) -> (C : Type 0@prog) ->
         (a : A@prog) -> (b : B@prog) -> (c : C@prog) ->
				(p : a = b) -> (q : b = c) -> (a = c)
trans' = \ A B C a b c p q .
             conv join 0 
               by (conv p by q at h.a = h)
               at h.a = h

trans4' : (A : Type 0@prog) -> (B : Type 0@prog) -> (C : Type 0@prog) -> (D : Type 0@prog) -> 
         (a : A@prog) -> (b : B@prog) -> (c : C@prog) -> (d : D@prog) -> 
				(p : a = b) -> (q : b = c) -> (r : c = d) -> (a = d)
trans4' = \ A B cTy dTy a b c d p q r . 
		    trans' A cTy dTy a c d
             (trans' A B cTy a b c p q) r

-- [a = b] -> a = b
--
-- Irrelevance for equality types.
--
-- Promote erased equality to run-time equality.
--
-- Useful with erased equalities generated by case matches.

uneraseEq : [A:Type 0@prog] -> [B:Type 0@prog] -> [a:A@prog] -> [b:B@prog] -> [a = b] -> (a = b)
uneraseEq = \ [_][_][a][b][eq] . conv join by eq at x . a = x

-- Existential types.

data Exists (a : Type 0@log) (p : ((x:a@log) -> Type 0)@log) : Type 0 where
  Ex of [x : a] (witness : p x)

-- Unit

data Unit : Type 0 where
  U

-- Void
--
-- DON'T USE THIS: you probably want (0=1) or (True=False) instead,
-- since contra handles those directly ...
data Void : Type 0 where {}
