-- Programmatic ceiling Nat division (cdivP)
--
-- Includes a proof that cdivP terminates when dividing by non-zero:
--
--   cdivP_t : (m:Nat) -> (n:Nat) -> Exists Nat (\v . cdivP m (Succ n) = v)
--
-- NB: this proof is compatible with the PP value restriction and may
-- allow the bound proofs to go through with the PP value restriction
-- in place (which I thought was impossible) ...
--
-- ... does indeed allow my simplified thm to be proven.  See
-- TerminationAsValueRestrictionWorkaround.
module ProgrammaticCdiv where
import Prelude
import Arithmetic
import StrongNat
import LessThanNat
import LessThanNat_lt_eq_True

prog cdivP : Nat -> Nat -> Nat
rec cdivP m = \n . case m [m_eq] of
  Zero -> Zero
  Succ m' -> let prog r [_] = cdivP (minus m n) n
             in Succ r

--Why the @log ? To match the definition of Exists
cdivP_ex : Nat -> Nat -> (Nat@log) -> Type 0
cdivP_ex = \m n v . cdivP m (Succ n) = v
cdivP_ex_red : (m:Nat) -> (n:Nat) -> (v:Nat) -> (cdivP_ex m n v = (cdivP m (Succ n) = v))
cdivP_ex_red = \m n v . join
cdivP_ex_red' : (m:Nat) -> (n:Nat) -> (v:Nat) -> ((cdivP m (Succ n) = v) = cdivP_ex m n v)
cdivP_ex_red' = \m n v . join

cdivP_t_p : Nat -> Type 0
cdivP_t_p = \m . (n:Nat) -> Exists Nat (cdivP_ex m n)
cdivP_t_p_red : (m:Nat) -> (cdivP_t_p m = (n:Nat) -> Exists Nat (cdivP_ex m n))
cdivP_t_p_red = \m . join
cdivP_t_p_red' : (m:Nat) -> (((n:Nat) -> Exists Nat (cdivP_ex m n)) = cdivP_t_p m)
cdivP_t_p_red' = \m . join

cdivP_t_f_base : (m:Nat) -> [m = Zero] -> (n:Nat) -> Exists Nat (cdivP_ex m n)
cdivP_t_f_base = \m [m_eq] n .
  let    _ = (join: cdivP Zero (Succ n) = Zero)
  in let _ = (join: cdivP_ex m n m = (cdivP m (Succ n) = m))
  in Ex [m] (_ : cdivP m (Succ n) = m)

cdivP_t_f_step : (m:Nat) -> (m':Nat) -> [m = Succ m']
              -> ((k:Nat) -> [ltT k m @log] -> (n:Nat) -> Exists Nat (cdivP_ex k n) @log)
              -> (n:Nat) -> Exists Nat (cdivP_ex m n)
cdivP_t_f_step = \m m' [m_eq] gm n .
  let            _ = (join: cdivP (Succ m') (Succ n)
                        = (let prog r [_] = cdivP (minus (Succ m') (Succ n)) (Succ n)
                           in Succ r))
  in let lt_Sn [_] = s_minus_s__lt m' n
  in let ih [_]    = gm (minus m (Succ n)) [lt_Sn] n
  in case ih [_] of
       Ex [v] v_eq -> let    [_] = (cdivP_ex_red (minus m (Succ n)) n v
                                   : cdivP_ex (minus m (Succ n)) n v 
                                   = (cdivP (minus m (Succ n)) (Succ n) = v))
                      -- Look: here is a case where "assumption up to congruence" is actually useful!
                      -- Revisit this spot after implementing that, and when writing the paper.
--                      in let v_eq' = (v_eq : cdivP (minus m (Succ n)) (Succ n) = v)
                      in let [_] = (cdivP_ex_red' m n (Succ v)
                                   : (cdivP m (Succ n) = Succ v)
                                   = cdivP_ex m n (Succ v))
                      in let _   = (join: (let prog r [_] = v
                                            in Succ r)  
                                        = Succ v)
                      in let h   = (_ : cdivP m (Succ n) = Succ v)
                      in Ex [Succ v] h

cdivP_t_f' : (m:Nat) -> ((k:Nat) -> [ltT k m @log] -> (n:Nat) -> Exists Nat (cdivP_ex k n) @log)
         -> (n:Nat) -> Exists Nat (cdivP_ex m n)
cdivP_t_f' = \m gm n . case m [m_eq] of
  Zero    -> cdivP_t_f_base m [m_eq] n
  Succ m' -> cdivP_t_f_step m m' [m_eq] gm n

cdivP_t_f :  (m:Nat) -> ((k:Nat) -> [ltT k m @log] -> cdivP_t_p k @log) -> cdivP_t_p m
cdivP_t_f = \m gm .
  let gm' [_] = ((\k [k_lt_m] .
                 unfold (cdivP_t_p k) in
                   (gm k [k_lt_m]))
                  : (k:Nat) -> [ltT k m @log] -> (n:Nat) -> Exists Nat (cdivP_ex k n))
  in unfold (cdivP_t_p m)
  in (cdivP_t_f' m gm')

cdivP_t' : (m:Nat) -> cdivP_t_p m
cdivP_t' = cov [cdivP_t_p] cdivP_t_f

-- It's tricky to state these equalities so that trellys can infer the
-- type of the (Nat@log) -> Type 0 lambda
--
-- (Why @log? Because of the definition of the Exists datatype).
--
cdivP_ex_red2 : (m:Nat) -> (n:Nat) -> Exists Nat (cdivP_ex m n)
                                    = Exists Nat (\v . cdivP m (Succ n) = v)
cdivP_ex_red2 = \m n . 
  let lemma = (join : cdivP_ex m n = (\v. cdivP m (Succ n) = v : (Nat@log) -> Type 0))
  in _

cdivP_t : (m:Nat) -> (n:Nat) -> Exists Nat (\v . cdivP m (Succ n) = v)
cdivP_t m n = 
   let _ = (cdivP_t_p_red m) in
   let _ = (cdivP_ex_red2 m n) in
    -- Another example where the more liberal application rule is useful,
    -- revisit when writing paper.
    (cdivP_t' m : (n:Nat) -> Exists Nat (cdivP_ex m n)) n
