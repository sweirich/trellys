module RLE where

import Prelude
import List
import Logic  --non-dependent pairs and union.

data Maybe (a : Type 0) : Type 0 where
  Nothing
  Just of (a@log)

encodeFrom : [a:Type 0] -> (eq : (x:a@log) -> (y:a@log) -> Maybe (x=y) @log) -> List a
             -> Nat -> (a@log) ->  List (And Nat a)
encodeFrom = \[a] eq . ind encodeFrom xs = \ n current .
  case xs [xsq] of
    Nil -> (Cons [?] (Conj [?] [?] n current) (Nil [?]))
    Cons x xs ->
      case (eq x current) [_] of
        Just q -> encodeFrom xs [ord xsq] (Succ n) current
        Nothing -> Cons [?] (Conj [?] [?] n current) (encodeFrom xs [ord xsq] 1 x)

encode : [a:Type 0] -> (eq : (x:a@log) -> (y:a@log) -> Maybe (x=y) @log) -> List a -> List (And Nat a)
encode = \[a] eq xs .
  case xs [_] of 
    Nil -> Nil [?]
    Cons x xs -> encodeFrom [a] eq xs 1 x

decode : [a:Type 0] -> List (And Nat a) -> List a
decode = \[a]. ind decode xs =
 case xs [xsq] of 
   Nil -> Nil [?]
   Cons (Conj n x) xs -> append [?] (replicate [?] n x) (decode xs [ord xsq])


replicate_Succ : [a:Type 0] -> (n:Nat) -> (x:a@log) 
                 -> replicate [a] (Succ n) x = Cons [a] x (replicate [a] n x)
replicate_Succ = TRUSTME

append_Cons : [a:Type 0] -> (x:a@log) -> (xs:List a) -> (ys:List a) 
              -> append [?] (Cons [?] x xs) ys = Cons [?] x (append [?] xs ys)
append_Cons = TRUSTME

append_replicate_Succ : [a:Type 0] -> (n:Nat) -> (x:a@log) -> (ys: List a) 
                 -> append [?] (replicate [a] (Succ n) x) ys = append [?] (replicate [a] n x) (Cons [?] x ys)
append_replicate_Succ = TRUSTME


encodeFrom_spec : [a:Type 0] -> (eq : (x:a@log) -> (y:a@log) -> Maybe (x=y) @log) 
                  -> (xs:List a)
                  -> (n:Nat) -> (x0 : a@log) 
                  -> decode [?] (encodeFrom [?] eq xs n x0) = append [?] (replicate [?] n x0) xs
encodeFrom_spec = \[a] eq . ind encodeFrom_spec xs = \ n x0 .
  case xs [xsq] of 
    Nil -> 
     -- Note, this could be completely automated by using a "smart" join, which takes 
     -- congruence classes into account.
     let _ = (join : decode [?] (encodeFrom [?] eq (Nil [?]) n x0)
                   = append [?] (replicate [?] n x0) (Nil [?])) in
     _
    Cons x ys ->
     let _ = (join : (encodeFrom [?] eq (Cons [?] x ys) n x0)
                   = (case (eq x x0) [_] of
                        Just q -> encodeFrom [?] eq ys (Succ n) x0
                        Nothing -> Cons [?] (Conj [?] [?] n x0) (encodeFrom [?] eq ys 1 x) 
                      : List (And Nat a)))
     in case (eq x x0) [_] of
       Just q ->
          let _ = (join :  (case (Just [?] q) [_] of
                             Just q -> encodeFrom [?] eq ys (Succ n) x0
                             Nothing -> Cons [?] (Conj [?] [?] n x0) (encodeFrom [?] eq ys 1 x) 
                           : List (And Nat a))
                        = encodeFrom [?] eq ys (Succ n) x0) in
-- And therefore
           let _ = (_ : decode [?] (encodeFrom [?] eq xs n x0) = decode [?] (encodeFrom [?] eq ys (Succ n) x0)) in 
           let IH = (encodeFrom_spec ys [ord xsq] (Succ n) x0 
                      : decode [?] (encodeFrom [?] eq ys (Succ n) x0)
                      = append [?] (replicate [?] (Succ n) x0) ys) in
           let _ = append_replicate_Succ [a] n x0 ys in
           _
           --TRUSTME
       Nothing -> TRUSTME
