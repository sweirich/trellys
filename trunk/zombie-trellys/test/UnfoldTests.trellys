module UnfoldTests where

import Prelude

-----------------------------------------------------------------
-- Stepping rules for annotated things (including cast-shuffling)
-----------------------------------------------------------------

-- Stepping a function with a conv applied to it.
converted_lam : (p : ((n:Nat)->Nat)=((b:Bool)->Bool)) -> (b : Bool) -> Unit
converted_lam p b = 
  unfold ((conv ((\n . n) : Nat->Nat) by p at x.x) b) in
  let _ = (_ : ((conv ((\n . n) : Nat->Nat) by p at x.x) b)
             = b) in
    U

-- Same thing, but with a rec
converted_rec : (p : ((n:Nat)->Nat)=((b:Bool)->Bool)) -> (b : Bool) -> Unit
converted_rec p b = 
  unfold ((conv ((rec f n = n) : Nat->Nat) by p at x.x) b) in
  let _ = (_ : ((conv ((rec f n = n) : Nat->Nat) by p at x.x) b)
             = b) in
    U

-- Same thing, but with an ind
converted_ind : (p : ((n:Nat)->Nat)=((b:Bool)->Bool)) -> (b : Bool) -> Unit
converted_ind p b = 
  unfold ((conv ((ind f n = n) : Nat->Nat) by p at x.x) b) in
  let _ = (_ : ((conv ((ind f n = n) : Nat->Nat) by p at x.x) b)
             = b) in
    U

-- Stepping a function with a conv applied to it, when the function has a 
-- dependent type.

data T1 (n:Nat) : Type where
  mkT1 of (m:Nat) (_ : n = m)

data T2 (b:Bool) : Type where
  mkT2

converted_lam_dep :  (p : ((n:Nat)->T1 n)= ((b:Bool)->T2 b)) -> (b:Bool) 
		     -> (q : Nat = Bool)   --This is just used to be able to state what it should reduce to
		     -> Unit
converted_lam_dep p b q = 
  unfold ((conv ((\n . mkT1 n _) : (n:Nat)->T1 n) by p at x.x) b) in
  let _ = (_ : ((conv ((\n . mkT1 n _) : (n:Nat)->T1 n) by p at x.x) b)
         = (mkT1 (conv b by q at x.x) _ : T1 (conv b by q at x.x))) in
    U

-- The same thing with a rec instead of a lam
converted_rec_dep :  (p : ((n:Nat)->T1 n)= ((b:Bool)->T2 b)) -> (b:Bool) 
		     -> (q : Nat = Bool)
		     -> Unit
converted_rec_dep p b q = 
  unfold ((conv ((rec f n = mkT1 n _) : (n:Nat)->T1 n) by p at x.x) b) in
  let _ = (_ : ((conv ((rec f n = mkT1 n _) : (n:Nat)->T1 n) by p at x.x) b)
         = (mkT1 (conv b by q at x.x) _ : T1 (conv b by q at x.x))) in
    U

-- The same thing with an ind instead of a lam
converted_ind_dep :  (p : ((n:Nat)->T1 n)= ((b:Bool)->T2 b)) -> (b:Bool) 
		     -> (q : Nat = Bool)
		     -> Unit
converted_ind_dep p b q = 
  unfold ((conv ((ind f n = mkT1 n _) : (n:Nat)->T1 n) by p at x.x) b) in
  let _ = (_ : ((conv ((ind f n = mkT1 n _) : (n:Nat)->T1 n) by p at x.x) b)
         = (mkT1 (conv b by q at x.x) _ : T1 (conv b by q at x.x))) in
    U

-- Stepping a lambda with a conv applied to it, but with the template of the
-- conv already having an arrow type.
converted_lam_2 : (p : Nat = Bool) -> (q : Nat = Unit) -> (b:Bool) -> Unit
converted_lam_2 p q b = 
  unfold ((conv ((\n . Succ n) : Nat->Nat) by p,q at x y. x->y) b) in
  let _ = (_ : ((conv ((\n . Succ n) : Nat->Nat) by p,q at x y. x->y) b)
             = Succ (conv b by (sym1 Type Type Nat Bool p) at x.x)) in
    U

-- The same thing, with an rec instead of a lam
converted_rec_2 : (p : Nat = Bool) -> (q : Nat = Unit) -> (b:Bool) -> Unit
converted_rec_2 p q b = 
  unfold ((conv ((rec f n = Succ n) : Nat->Nat) by p,q at x y. x->y) b) in
  let _ = (_ : ((conv ((rec f n = Succ n) : Nat->Nat) by p,q at x y. x->y) b)
             = Succ (conv b by (sym1 Type Type Nat Bool p) at x.x)) in
    U

-- The same thing, with an ind instead of a lam
converted_ind_2 : (p : Nat = Bool) -> (q : Nat = Unit) -> (b:Bool) -> Unit
converted_ind_2 p q b = 
  unfold ((conv ((ind f n = Succ n) : Nat->Nat) by p,q at x y. x->y) b) in
  let _ = (_ : ((conv ((ind f n = Succ n) : Nat->Nat) by p,q at x y. x->y) b)
             = Succ (conv b by (sym1 Type Type Nat Bool p) at x.x)) in
    U

-- Stepping an ind with a dependent type.
-- (tricky points: right type annotation on the
--   introduced lambda).
-- Stepping a case-expression
-- (tricky points: substitute the right thing for xq).
ind_refl : (x:Nat) -> (x=x)
ind_refl = ind ih x =
  case x [xq] of
   Zero -> join
   Succ x' -> let _ = ih x' [ord xq] in _


ind_step : (ind_refl 1) = (join : 1 = 1)
ind_step = 
  unfold (ind_refl 1) in
    _

-- Stepping an ind with dependent type with a conversion
-- applied to it.

{-


ind_step_conv : 
  (p : ((x:Nat)->(x=x)) = ((y:Bool)->(y=y))) ->
  ((conv ind_refl by p at x.x) True) = (True = True)
ind_step_conv p = 
  unfold ((conv ind_refl by p at x.x) True) in
    _
-}


-----------------------------------------------------------------
-- Stepping things which are stuck, by using equational reasoning
-----------------------------------------------------------------

log f : Nat -> Nat
f = \x.x

-- This is stuck on a non-value, but we can work 
-- around that since (pred n) is logical.
log foo : (n:Nat) -> f (pred n) = (pred n)
foo = \n.
  unfold 2 (f (pred n)) in 
    _

