module Unify where

import Prelude
import Product
import Fin
import Vectors
import List
import Maybe

		 
-- A formula with n free variables
data Formula (n : Nat) : Type 0 where
  Var of (_ :Fin n)
  And of (_ :Formula n) (_ :Formula n)
  Lit of (_ :Bool)

-- apply a substitution to a formula
log subst : [n:Nat] -> Vector (Formula n) n -> Formula n ->  Formula n
subst = \ [n] v . 
 ind rs f =   
   case f [f_eq] of 
	  Var x -> lookup [Formula n][n] x v
	  And f1 f2 -> And (rs f1 [ord f_eq]) (rs f2 [ord f_eq])
	  Lit b -> Lit b

log subst1 : [n:Nat] -> Fin n -> Formula n -> Formula n -> Formula n
subst1 = \ [n] v u. 
 ind rs f =   
   case f [f_eq] of 
     Var x -> case (eq_fin [n] x v) [_] of 
         True -> u 
         False -> f
     And f1 f2 -> And (rs f1 [ord f_eq]) (rs f2 [ord f_eq])
     Lit b -> Lit b

log subst1_pair : [n:Nat] -> Fin n -> Formula n 
	 -> Times (Formula n) (Formula n) -> Times (Formula n) (Formula n)
subst1_pair = \[n] fn form z. 
  case z [z_eq] of 
    Pair x y -> Pair (subst1 [n] fn form x) (subst1 [n] fn form y)

log occurs : [n:Nat] -> Fin n -> Formula n -> Bool
occurs = \ [n] fn. 
  ind occ f = 
    case f [f_eq] of 
      Var fn1 -> eq_fin [n] fn fn1
      And f1 f2 -> and (occ f1 [ord f_eq]) (occ f2 [ord f_eq])
      Lit _ -> False

prog unify : (n:Nat) 
           -> (fs : List (Times (Formula n) (Formula n)))
           -> Maybe (Vector (Maybe (Formula n)) n)
unify = \ n . 
  rec uni fs = 
     case fs [_] of 
        Nil -> Just (repeat [Maybe (Formula n)] Nothing n)
        Cons (Prod f1 f2) xs -> 
           case f1 [_], f2 [_] of 
              Var x , _ -> 
                case (occurs x f2) [_] of 
                  True -> Nothing 
                  False -> 
                    case (uni (map [?][?] (subst1_pair [n] x f2) xs)) [_] of 
                      Nothing -> Nothing
                      Just s  -> Just (set [Formula n][n] x (Just f2) s)
              _ , Var x -> TRUSTME
              (And b1 b2) , (And c1 c2) -> unify 
                       (Cons (Prod b1 c1) 
                            (Cons (Prod b2 c2) xs))
              Lit True, Lit True -> unify xs
              Lit False, Lit False -> unify xs
              _ , _ -> Nothing

{-
log interp : [n : Nat] -> Env n -> Formula n -> Bool
interp = \ [n] e .
 ind interp f =  
   case f [f_eq] of 
      Var fn -> lookup [n] fn e
      And f1 f2 -> and (interp f1 [ord f_eq]) (interp f2 [ord f_eq])
      Lit b  -> b



-}

{-
prog isSat : [n:Nat] -> Formula n -> Maybe (Env n)
isSat = 
  rec isSat [n] f = 
     case f of 
	    Var x 
-}


{-
log Subst : Type 0 
subst = Nat -> Formula

data Sat (f : Formulat) : Type 0
  isSat : 
-}