module Unify2 where

import Prelude
import Product
import Fin
import List
import Maybe

usually log

-- We use natural numbers for variables everywhere

data Term : Type where
  leaf 
  branch of (t1 : Term) (t2 : Term)
  var of (x : Nat)


-- notFreeIn x t = True if x is not free in t. 
notFreeIn : Nat -> Term -> Bool
notFreeIn = \x . ind go t = case t [eqt] of 
  leaf -> False
  branch t1 t2 -> and (go t1 [ord eqt]) (go t2 [ord eqt])
  var y -> not (nat_eq x y) 
    

Substitution : Type
Substitution = Nat -> Maybe Term

empty : Substitution
empty = unfold Substitution in
          \ x . Nothing

singleton : Nat -> Term -> Substitution
singleton x t = unfold Substitution in
                 \y. case (eq x y) [_] of
                       True -> Just t
                       False -> Nothing 

-- apply a substitution to a term
log ap : Substitution -> Term -> Term
ap s = ind go t = case t [eqt] of
                      leaf -> leaf
                      branch t1 t2 -> branch (go t1 [ord eqt]) 
                                             (go t2 [ord eqt])
                      var x -> unfold Substitution in
                                 case (s x) of 
                                   Just t -> t
                                   Nothing -> var x 

log compose : Substitution -> Substitution -> Substitution
compose = unfold Substitution in
  \ s' s x . case (s x) of
               Just t ->  Just (ap s' t)
               Nothing -> s' x

log apCompose : (s1 : Substitution) -> (s2 : Substitution) ->
                    (t : Term) -> 
                    ap (compose s1 s2) t = ap s1 (ap s2 t)
apCompose s1 s2 = ind IH t =
  case t [teq] of
    leaf -> unfold (ap (compose s1 s2) t) in
            unfold (ap s1 (ap s2 t)) in
	      _
    branch t1 t2 -> 
      unfold (ap (compose s1 s2) t) in
      unfold (ap s1 (ap s2 t)) in
      let _ = IH t1 in
      let _ = IH t2 in
      _

    var x -> 
      unfold Substitution in
      unfold (ap (compose s1 s2) t) in
      unfold (ap s1 (ap s2 t)) in
      case (s2 x) [_] of 
        Just t' -> _
        Nothing -> _
       

log varSingleton : (x : Nat) -> (t : Term) -> t = ap (singleton x t) (var x)
varSingleton x t = 
  case (eq_nat x x) of 
    True  -> unfold (ap (singleton x t) (var x)) in _
    False -> unfold (ap (singleton x t) (var x)) in _

singletonNotFree : (t : Term) -> (x : Nat) -> (s : Term) ->
                   (notFreeIn x t = True) -> (ap (singleton x s) t = t)
singletonNotFree = TRUSTME

data Unify (t1 : Term) (t2 : Term) : Type where
  no 
  yes of (s : Substitution) (pf : ap s t1 = ap s t2)

prog unify : (t1 : Term) -> (t2 : Term) -> Unify t1 t2
rec unify t1 = \ t2 . 
  case t1 , t2 of
    leaf, leaf -> yes empty _
    leaf, branch _ _ -> no
    branch _ _ , leaf -> no
    branch t11 t12, branch t21 t22 ->
      case (unify t11 t21) of
        no -> no 
        yes s p -> 
          case (unify (ap s t12) (ap s t22)) of
            no -> no
	    yes s' p' ->
	      let s'' = compose s' s in
	      let [_] = (pjoin:  ap s'' (branch t11 t12)
   		               = branch (ap s'' t11) (ap s'' t12)) in
	      let [_] = (pjoin:  ap s'' (branch t21 t22)
			       = branch (ap s'' t21) (ap s'' t22)) in
	      let [_] = (apCompose s' s t11) in
	      let [_] = (apCompose s' s t12) in
	      let [_] = (apCompose s' s t21) in
	      let [_] = (apCompose s' s t22) in
		yes s'' _
    t , (var x) -> 
      case (notFreeIn x t) of
        False -> no
        True  -> 
           let [_] = varSingleton x t in
           let [_] = singletonNotFree t x t _ in
             yes (singleton x t) _
    (var x) , t -> 
      case (unify t (var x)) of
        no -> no
        yes s p -> yes s _ 
