module Unify2 where

import Prelude
import Product
import Fin
import List
import Maybe

usually log

-- We use natural numbers for variables everywhere

data Dec (p : Type) : Type where
  Yes of (p)
  No  of (p -> Void)

-- equality for natural numbers is decidable

dec_eq : (n1 : Nat) -> (n2 : Nat) -> Dec (n1 = n2)
ind dec_eq x = \ y . 
  case x [x_eq], y [y_eq] of 
     Zero, Zero -> Yes _
     Succ m, Succ n -> case (dec_eq m [ord x_eq] n) [_] of 
                         Yes _ -> Yes _
                         No pf -> No (\x. pf (sm_eq_Sn__m_eq_n m n _))
     Zero , Succ n -> No (\x. contra (_ : (0 = Succ n)))
     Succ m , Zero -> No (\x. contra (_ : (Succ m = 0)))

data Term : Type where
  leaf 
  branch of (t1 : Term) (t2 : Term)
  var of (x : Nat)


-- notFreeIn x t = True if x is not free in t. 
notFreeIn : Nat -> Term -> Bool
notFreeIn = \x. ind IH t = case t [teq] of 
    leaf -> True
    branch t1 t2 -> or (IH t1 [ord teq]) (IH t2 [ord teq])
    var y -> case (dec_eq x y) [_] of 
                 Yes _ -> False
                 No  _ -> True

Substitution : Type
Substitution = Nat -> Maybe Term

empty : Substitution
empty = unfold Substitution in
         \ x . Nothing

singleton : Nat -> Term -> Substitution
singleton x t = unfold Substitution in
                 \y. case (dec_eq x y) [_] of
                       Yes _ -> Just t
                       No  _ -> Nothing

-- apply a substitution to a term
log ap : Substitution -> Term -> Term
ap s = ind go t = case t [eqt] of
                      leaf -> leaf
                      branch t1 t2 -> branch (go t1 [ord eqt]) 
                                             (go t2 [ord eqt])
                      var x -> unfold Substitution in
                                 case (s x) of 
                                   Just t -> t
                                   Nothing -> var x

log compose : Substitution -> Substitution -> Substitution
compose = unfold Substitution in
  \ s' s x . case (s x) of
               Just t -> Just (ap s' t)
               Nothing -> s' x

log apCompose : (s1 : Substitution) -> (s2 : Substitution) ->
                    (t : Term) -> 
                    ap (compose s1 s2) t = ap s1 (ap s2 t)
apCompose s1 s2 = ind IH t =
  let s' = compose s1 s2 in
  case t [teq] of
    leaf -> unfold (ap s' t) in
				unfold (ap s1 (ap s2 t)) in
            _

    branch t1 t2 -> unfold (ap s' t) in
	                 unfold (ap s2 t) in 
						  let t1' = ap s2 t1 in 
						  let t2' = ap s2 t2 in
						  unfold (ap s1 (branch t1' t2')) in
						  let [_] = IH t1 [ord teq] in
                    let [_] = IH t2 [ord teq] in
                    _
    var x -> TRUSTME {-
             unfold Substitution in
             let _ = (join : (ap s' (var x)) = 
                         (case (s' x) of { Just t -> t; Nothing -> var x } : Term)) in
			    let _ = (join : (compose s1 s2 x) = 
                         (case (s2 x) of { Just t -> Just (ap s1 t); Nothing -> s1 x } : Maybe Term)) in 
             case (s2 x) [_] of
               Just u  -> let t' = ap s1 u in
								  let _ = (_ : (ap s' t) = (case (s' x) [_] of { Just u -> u ; Nothing -> var x } : Term)) in
                          let _ = (join : (case (Just u) [_] of { Just u -> Just t' ; Nothing -> s1 x } : Maybe Term) = Just t') in
								  let _ = (join : (compose s1 s2 x) = (case (s2 x) [_] of { Just u -> Just (ap s1 u) ; Nothing -> s1 x } : Maybe Term)) in
								  let _ = (join : (case (Just t') [_] of { Just u -> u ; Nothing -> var x } : Term) = t') in
								  -- let _ = (_ : (ap s' t) = t') in
								  -- let _ = (_ : ap s1 (ap s2 t) = ap s1 u) in
                          TRUSTME
               Nothing -> let _ = (join : (compose s1 s2 x) = (case (s2 x) [_] of { Just u -> Just (ap s1 u) ; Nothing -> s1 x } : Maybe Term)) in
                          let _ = (join : (case (Nothing : Maybe Term) [_] of { Just u -> Just t' ; Nothing -> s1 x } : Maybe Term) = s1 x) in
								  TRUSTME  -}

       
            

log varSingleton : (x : Nat) -> (t : Term) -> t = ap (singleton x t) (var x)
varSingleton x t = 
   case (dec_eq x x) [eqx] of 
     Yes p  -> 
	    unfold Substitution in
		 {- SCW: these next three shouldn't be necessary, if unfold keeps going. Would like to be able to say either:
		 unfold (ap (singleton x t) (var x)) in _
       --  or just
       join  -- using the checked type
		 -}
		 let _ = (join : (ap (singleton x t) (var x)) = (case (singleton x t x) [_] of {  Just t -> t ;  Nothing -> var x } : Term)) in 
       let _ = (join : ((singleton x t) x) = (case (dec_eq x x) [_] of { Yes _ -> Just t; No _ -> Nothing } : Maybe Term)) in
       let _ = (join : (case (Yes p)  [_] of { Yes _ -> Just t; No _ -> Nothing } : Maybe Term) = (Just t)) in 
       let _ = (join : (case (Just t) [_] of { Just t -> t ; Nothing -> var x } : Term) = t) in
		 _
     No p -> case (p _) [_] of {}

singletonNotFree : (t : Term) -> (x : Nat) -> (s : Term) ->
                   (notFreeIn x t = True) -> (ap (singleton x s) t = t)
singletonNotFree = ind IH t = \ x s p . 
  unfold Substitution in
  let s' = singleton x s in
  unfold (singleton x s) in
  case t [eqt] of 
    leaf -> 
            unfold (notFreeIn x leaf) in
            unfold (ap s' leaf) in 
            _
    var y -> unfold (ap s' (var y)) in
             case (dec_eq x y) [_] of 
                Yes pf -> unfold (notFreeIn x (var y)) in
                          contra (p : False = True)
                No q  -> unfold (ap s' (var y)) in _
    branch t1 t2 -> unfold (ap s' (branch t1 t2)) in
                    let _ = (join : notFreeIn x (branch t1 t2) = or (notFreeIn x t1) (notFreeIn x t2)) in
                    case (notFreeIn x t1) [_] of 
                       False -> let _ = (or False (notFreeIn x t2)) = False in
							           let _ = (_ : notFreeIn x t = False) in
                                TRUSTME -- contra (p : False = True)
                       True  -> case (notFreeIn x t2) [_] of 
                                   False -> unfold (or True False) in 
					    let _ = (_ : notFreeIn x t = False) in
                                            contra (p : False = True)
                                   True  -> let _ = IH t1 [ord eqt] x s _ in 
                                            let _ = IH t2 [ord eqt] x s _ in
                                            _


data Unify (t1 : Term) (t2 : Term) : Type where
  no 
  yes of (s : Substitution) (pf : ap s t1 = ap s t2)

prog unify : (t1 : Term) -> (t2 : Term) -> Unify t1 t2
rec unify t1 = \ t2 . 
  case t1 , t2 of
    leaf, leaf -> yes empty _
    leaf, branch _ _ -> no
    branch _ _ , leaf -> no
    branch t11 t12, branch t21 t22 ->
      case (unify t11 t21) of
        no -> no 
        yes s p -> 
          case (unify (ap s t12) (ap s t22)) of
            no -> no
	    yes s' p' ->
	      let s'' = compose s' s in
	      let [_] = (pjoin:  ap s'' (branch t11 t12)
   		               = branch (ap s'' t11) (ap s'' t12)) in
	      let [_] = (pjoin:  ap s'' (branch t21 t22)
			       = branch (ap s'' t21) (ap s'' t22)) in
	      let [_] = (apCompose s' s t11) in
	      let [_] = (apCompose s' s t12) in
	      let [_] = (apCompose s' s t21) in
	      let [_] = (apCompose s' s t22) in
		yes s'' _
    t , (var x) -> 
      case (notFreeIn x t) of
        False -> no
        True  -> 
           let [_] = varSingleton x t in
           let [_] = singletonNotFree t x t _ in
             yes (singleton x t) _
    (var x) , t -> 
      case (unify t (var x)) of
        no -> no
        yes s p -> yes s _ 
