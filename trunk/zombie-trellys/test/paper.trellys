module Paper where

-- wish list for the implementation
{-

	* join -> refl ?
	* join/all unfold/all
	* infix operators
	* automatic unfolding for logical terms
	* TUnboxP and TUnboxL
   * automatic inference of [ord]
-}

-- Prelude for examples

data Bool : Type where
  True 
  False

data Nat : Type where
  Zero 
  Succ of (_ : Nat)


plus : Nat -> Nat -> Nat
ind plus n m =
  case n [cw] of
    Zero -> m
    Succ pred -> Succ (plus pred [ord cw] m)

minus : Nat -> Nat -> Nat
ind minus n m =
   case n [cn] of
     Zero -> Zero
     Succ pred -> case m [cm] of
                    Zero -> n
                    Succ mpred -> minus pred [ord cn] mpred

-- 'x > y'
gt : Nat -> Nat -> Bool
ind gt x y =
   case x [xpf] of
        Zero    -> False
        Succ x' -> case y of
                   Zero -> True
                   Succ y' -> gt x' [ord xpf] y' 
-- 'x < y'
lt : Nat -> Nat -> Bool
lt x y = gt y x

eq : Nat -> Nat -> Bool
ind eq x y = 
  case x [xpf], y [_] of 
     Zero, Zero -> True
     Succ x', Succ y' -> eq x' [ord xpf] y'
     _ , _ -> False

log void : Type
void = True = False

---------------------------------

log not : Bool -> Bool
not b = if b then False else True


prog div : Nat -> Nat -> Nat
rec div n m = if (lt n m) then 0
    else (plus 1 (div (minus n m) m))

log div63 : div 6 3 = 2
div63 = join   
  -- change to refl? note, 100 is NOT enough
  -- maybe no # should tell the type inferencer to do as many as necessary. 

-- this function diverges at 0, is an identity function everywhere else
prog silly : Nat -> Nat
rec silly x = case x of 
  Zero -> silly x
  Succ Zero -> x
  Succ (Succ n) -> Succ (silly (Succ n))

log lemma_silly : (n : Nat) -> (((n = 0) -> void) @ log) -> (silly n = n)
ind lemma_silly n pf = 
  case n [n_eq] of 
    Zero -> unfold void in 
            contra (pf n_eq : True = False)
    Succ m -> case m [m_eq] of
        Zero -> unfold (silly (Succ Zero)) in _
        (Succ n') -> 
		   let not_zero = ((\pf . contra (_ : (Succ n') = 0)) : (m = 0) -> void) in
         let ih = lemma_silly m [ord n_eq] not_zero in
			let _  = (join : (silly (Succ (Succ n'))) = Succ (silly (Succ n'))) in
			-- why can't CC derive this last equality?
			let _  = (conv _ by ih at x . (Succ x = silly n) : Succ m = silly n) in
         _

log diverge : (f : Nat -> Nat @ prog) -> (x : Nat) -> Type
diverge f x = (y : Nat) -> (f x = y) -> void 

-- can't prove this
-- log silly_diverge : diverge silly 0

data Maybe (a : Type 0) : Type 0 where
  Just    of ( _ : a @ prog)
  Nothing 

prog maybe_map : [a : Type 0] => [b : Type 0] => 
	 ((a @ log) -> b @ prog) -> (Maybe a @ prog) -> Maybe b
maybe_map = \ [a] [b] f n . 
  case  n [_] of
    Just x -> Just (f x) 
    _      -> Nothing 

log lemma_maybe : (f : (Nat @ log) -> Nat @ prog) -> (x:Nat) -> maybe_map f (Just x) = (Just (f x) : Maybe Nat)
lemma_maybe f x = unfold (maybe_map f (Just x)) in _


prog mplus : [A : Type] => Maybe A -> Maybe A -> Maybe A 
mplus [A] x y = case x of 
            Just z  -> x
            Nothing -> y

log idl : [A : Type] => (y:Maybe A @ P) -> mplus Nothing y = y
idl [A] y = join

-- need to remove the parameter from Nothing. It's interfering with 
-- the unfolding!
-- Also, why does this stop working when I add the @ prog?

log idr : [A : Type] => (x:Maybe A) -> mplus x Nothing = x 
idr [A] x = case x of 
        Just x1 -> unfold (mplus (Just x1) Nothing) in _
        Nothing -> unfold (mplus (Nothing : Maybe A) Nothing) in _

